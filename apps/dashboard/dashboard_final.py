# -*- coding: utf-8 -*-
import os
import sys
import importlib
from pathlib import Path
# Добавляем корневую директорию проекта в sys.path для импорта utils
# Файл находится в apps/dashboard/, поэтому нужно подняться на 3 уровня вверх
project_root = Path(__file__).parent.parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

import json
import base64
import re
from io import BytesIO
from collections import Counter
import urllib.parse as _urlparse
import locale

import pandas as pd
import numpy as np
import streamlit as st
import requests
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

# Импорт из локальных модулей utils
from utils.calculations import calculate_unit_economics, calculate_daily_profit
from utils.formatters import (
    format_thousands, format_thousands_with_spaces,
    fmt_rub, fmt_units, fmt_rub_kpi, fmt_units_kpi,
    fmt_date, parse_thousands_input, sort_df
)
from utils.prophet_forecast import (
    PROPHET_AVAILABLE, prepare_data_for_prophet,
    create_prophet_forecast, plot_prophet_forecast, plot_prophet_components
)
from utils.wb_utils import build_wb_product_url, extract_sku_from_url, extract_sku_from_filename
from utils.image_cache import (
    load_url_cache, save_url_cache, get_url_cache_with_state,
    get_cached_image_path, ensure_image_cached, get_cache_status,
    load_image_bytes, img_data_uri, get_cached_images_for_sku, img_path_for
)
from utils.image_analysis import (
    extract_dominant_colors_from_image, get_color_name_russian, analyze_style_from_image
)
from utils.wb_api_images import (
    get_product_image_urls_from_wb_api, get_product_name_from_wb, build_screenshot_url
)
from utils.file_cache import (
    save_file_cache, load_file_cache, get_file_cache_info,
    get_all_cached_files, save_file_to_cache
)
from utils.reports import (
    load_report_from_tovar_folder, find_and_load_reports_from_tovar
)
from utils.size_reports import find_and_load_size_reports
try:
    from utils.size_reports import normalize_size
except ImportError:
    def normalize_size(val):
        return val
try:
    from utils.reports import get_last_report_load_error
except ImportError:
    def get_last_report_load_error():
        return None
from utils.wgsn_reader import read_wgsn_files
from utils.data_processing import (
    read_table as read_table_base, get_file_statistics, get_analysis_period
)
from utils.ai_analysis import (
    analyze_combination_products_with_ai_core,
    analyze_wgsn_trends_with_ai_core,
    analyze_image_with_ai_core
)
try:
    from utils.ai_analysis import analyze_reviews_with_ai_core
except ImportError:
    def analyze_reviews_with_ai_core(*args, **kwargs):
        return {"error": "Функция анализа отзывов недоступна. Обновите utils.ai_analysis."}
try:
    from utils.ai_analysis import analyze_marketing_images_with_ai_core
except ImportError:
    def analyze_marketing_images_with_ai_core(*args, **kwargs):
        return {"error": "Функция маркетинг-анализа недоступна. Обновите utils.ai_analysis."}
from utils.otziv_reports import find_and_load_otziv_reports

# Импорт OpenAI с обработкой ошибок
try:
    import openai
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False
    # OpenAI не установлен - функциональность анализа изображений через нейросеть недоступна

# Импорт python-docx для чтения файлов WGSN
try:
    from docx import Document
    DOCX_AVAILABLE = True
except ImportError:
    DOCX_AVAILABLE = False
    # python-docx не установлен - функциональность чтения WGSN файлов недоступна

# Настройка локали для правильного отображения чисел с пробелами
try:
    locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')
except:
    try:
        locale.setlocale(locale.LC_ALL, 'Russian_Russia.1251')
    except:
        pass

try:
    from PIL import Image
except Exception:
    Image = None

st.set_page_config(page_title="WB Dashboard — Анализ товаров", layout="wide")

# CSS стили для улучшения отображения таблиц
st.markdown("""
<style>
/* Убираем только ограничения по максимальной высоте */
.stDataFrame {
    max-height: none !important;
}
.stDataFrame > div {
    max-height: none !important;
}
div[data-testid="stDataFrame"] {
    max-height: none !important;
}
</style>
""", unsafe_allow_html=True)

# ================= ФУНКЦИИ ДЛЯ РАБОТЫ С ПАРАМЕТРАМИ =================

def is_valid_param_name(param_name: str) -> bool:
    """
    Проверяет, является ли имя параметра валидным.
    Исключает артикулы и другие недопустимые значения.
    """
    if not param_name or not isinstance(param_name, str):
        return False
    
    param_name_clean = param_name.strip()
    
    # Исключаем пустые значения
    if not param_name_clean:
        return False
    
    # Исключаем артикулы (чисто числовые значения длиной более 6 цифр)
    if param_name_clean.isdigit() and len(param_name_clean) >= 6:
        return False
    
    # Исключаем служебные поля
    excluded_names = ["Артикул", "URL", "Статус", "Параметры", "sku", "SKU"]
    if param_name_clean in excluded_names:
        return False
    
    return True

def save_param_value(sku: str, param: str, value: str, save_history: bool = True):
    """Сохраняет значение параметра для товара с сохранением истории изменений"""
    # Проверяем валидность имени параметра
    if not is_valid_param_name(param):
        return
    
    # ВАЖНО: Проверяем удаленные параметры только из session_state текущего проекта
    deleted_params = st.session_state.get("deleted_params", set())
    if not isinstance(deleted_params, set):
        deleted_params = set(deleted_params) if deleted_params else set()
        st.session_state["deleted_params"] = deleted_params
    
    if param in deleted_params:
        # Параметр был удален в текущем проекте, не сохраняем его
        return
    
    if "param_values" not in st.session_state:
        st.session_state["param_values"] = {}
    if param not in st.session_state["param_values"]:
        st.session_state["param_values"][param] = {}
    
    # Проверяем, есть ли старое значение
    old_value = st.session_state["param_values"][param].get(sku, None)
    
    # Сохраняем новое значение в правильной структуре: param_values[param][sku] = value
    st.session_state["param_values"][param][sku] = value
    
    # Если значение изменилось и нужно сохранить историю
    if save_history and old_value is not None and old_value != value:
        add_param_history(sku, param, old_value, value)

def add_param_history(sku: str, param: str, old_value: str, new_value: str):
    """Добавляет запись в историю изменений параметра (без сохранения в файл - сохраняется пакетами)"""
    if "param_history" not in st.session_state:
        st.session_state["param_history"] = []
    
    history_entry = {
        "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
        "sku": str(sku),
        "param": param,
        "old_value": old_value,
        "new_value": new_value
    }
    
    st.session_state["param_history"].append(history_entry)
    
    # НЕ сохраняем историю в файл здесь - сохраняется пакетами после обработки товара

def get_param_history(sku: str = None, param: str = None):
    """Получает историю изменений параметров с фильтрацией"""
    history = st.session_state.get("param_history", [])
    
    if sku:
        history = [h for h in history if h["sku"] == str(sku)]
    if param:
        history = [h for h in history if h["param"] == param]
    
    # Сортируем по дате (новые сверху)
    history.sort(key=lambda x: x["timestamp"], reverse=True)
    
    return history


def filter_skus_by_analysis(skus: list) -> list:
    """
    Фильтрует артикулы по текущей видимой выборке в разделе "Анализ данных".
    """
    if not skus:
        return skus
    allowed = st.session_state.get("analysis_filtered_skus", [])
    if not allowed:
        return skus
    allowed_set = {str(s).replace(".0", "") for s in allowed}
    return [s for s in skus if str(s).replace(".0", "") in allowed_set]


def filter_skus_by_analysis_with_details(skus: list):
    """
    Фильтрует артикулы по текущей видимой выборке в разделе "Анализ данных"
    и возвращает список исключенных артикулов.
    """
    if not skus:
        return skus, []
    allowed = st.session_state.get("analysis_filtered_skus", [])
    if not allowed:
        return skus, []
    allowed_set = {str(s).replace(".0", "") for s in allowed}
    filtered = []
    excluded = []
    for sku in skus:
        sku_key = str(sku).replace(".0", "")
        if sku_key in allowed_set:
            filtered.append(sku)
        else:
            excluded.append(sku)
    return filtered, excluded


def load_ai_cache(cache_file: str) -> dict:
    try:
        if os.path.exists(cache_file):
            with open(cache_file, "r", encoding="utf-8") as f:
                return json.load(f)
    except Exception:
        pass
    return {}


def save_ai_cache(cache_file: str, cache_data: dict) -> None:
    try:
        with open(cache_file, "w", encoding="utf-8") as f:
            json.dump(cache_data, f, ensure_ascii=False, indent=2)
    except Exception:
        pass

def save_param_history_to_file():
    """Сохраняет историю изменений параметров в файл"""
    history = st.session_state.get("param_history", [])
    current_file = st.session_state.get("cached_file_name", None)
    
    if history and current_file:
        try:
            file_hash = hash(current_file) % 1000000
            history_file = f"param_history_{file_hash}.json"
            
            history_data = {
                "file_name": current_file,
                "history": history,
                "last_updated": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S")
            }
            
            with open(history_file, "w", encoding="utf-8") as f:
                json.dump(history_data, f, ensure_ascii=False, indent=2)
            
            return True
        except Exception as e:
            return False
    
    return False

def load_param_history_from_file():
    """Загружает историю изменений параметров из файла"""
    current_file = st.session_state.get("cached_file_name", None)
    
    if current_file:
        try:
            file_hash = hash(current_file) % 1000000
            history_file = f"param_history_{file_hash}.json"
            
            if os.path.exists(history_file):
                with open(history_file, "r", encoding="utf-8") as f:
                    history_data = json.load(f)
                
                # Проверяем, что файл соответствует текущему файлу
                if history_data.get("file_name") == current_file:
                    st.session_state["param_history"] = history_data.get("history", [])
                    return True
        except Exception as e:
            pass
    
    # Если файл не найден или не соответствует, инициализируем пустую историю
    if "param_history" not in st.session_state:
        st.session_state["param_history"] = []
    
    return False

def get_param_values():
    """Получает все сохраненные значения параметров, исключая удаленные параметры"""
    param_values = st.session_state.get("param_values", {})
    
    # Загружаем список удаленных параметров
    if "deleted_params" not in st.session_state:
        st.session_state["deleted_params"] = load_deleted_params_from_file()
    
    deleted_params = st.session_state.get("deleted_params", set())
    
    # Фильтруем удаленные параметры
    if deleted_params:
        param_values = {k: v for k, v in param_values.items() if k not in deleted_params}
    
    return param_values

def get_hierarchy_params():
    """Получает список иерархических параметров из session_state или возвращает значения по умолчанию"""
    if "hierarchy_params" in st.session_state:
        return st.session_state["hierarchy_params"]
    # Значения по умолчанию
    return ["Тип", "Рукав", "Ворот"]

def get_subtype_params():
    """Получает список параметров подтипа из session_state или возвращает значения по умолчанию"""
    if "subtype_params" in st.session_state:
        return st.session_state["subtype_params"]
    # Значения по умолчанию
    return ["Рукав", "Ворот"]

def get_visual_params():
    """Получает список визуальных параметров из session_state или возвращает значения по умолчанию"""
    if "visual_params" in st.session_state:
        return st.session_state["visual_params"]
    # Значения по умолчанию
    return ["Цвет", "Принт", "Логотип", "Строчка", "Шов", "Строчка шов"]

def save_hierarchy_config():
    """Сохраняет конфигурацию иерархии параметров в файл"""
    try:
        # Получаем удаленные параметры
        deleted_params = st.session_state.get("deleted_params", set())
        if not isinstance(deleted_params, set):
            deleted_params = set(deleted_params) if deleted_params else set()
        
        # Фильтруем удаленные параметры из иерархии
        hierarchy_params = [p for p in st.session_state.get("hierarchy_params", []) if p not in deleted_params]
        subtype_params = [p for p in st.session_state.get("subtype_params", ["Рукав", "Ворот"]) if p not in deleted_params]
        visual_params = [p for p in st.session_state.get("visual_params", ["Цвет", "Принт", "Логотип", "Строчка", "Шов", "Строчка шов"]) if p not in deleted_params]
        
        hierarchy_config = {
            "hierarchy_params": hierarchy_params,
            "subtype_params": subtype_params,
            "visual_params": visual_params
        }
        with open("hierarchy_config.json", "w", encoding="utf-8") as f:
            json.dump(hierarchy_config, f, ensure_ascii=False, indent=2)
        return True
    except Exception as e:
        return False

def load_hierarchy_config():
    """Загружает конфигурацию иерархии параметров из файла"""
    try:
        if os.path.exists("hierarchy_config.json"):
            with open("hierarchy_config.json", "r", encoding="utf-8") as f:
                hierarchy_config = json.load(f)
                
                # Получаем удаленные параметры
                deleted_params = st.session_state.get("deleted_params", set())
                if not isinstance(deleted_params, set):
                    deleted_params = set(deleted_params) if deleted_params else set()
                
                # Фильтруем удаленные параметры при загрузке
                hierarchy_params_loaded = hierarchy_config.get("hierarchy_params", [])
                subtype_params_loaded = hierarchy_config.get("subtype_params", ["Рукав", "Ворот"])
                visual_params_loaded = hierarchy_config.get("visual_params", ["Цвет", "Принт", "Логотип", "Строчка", "Шов", "Строчка шов"])
                
                # Удаляем удаленные параметры из загруженных списков
                st.session_state["hierarchy_params"] = [p for p in hierarchy_params_loaded if p not in deleted_params]
                st.session_state["subtype_params"] = [p for p in subtype_params_loaded if p not in deleted_params]
                st.session_state["visual_params"] = [p for p in visual_params_loaded if p not in deleted_params]
                return True
    except Exception as e:
        pass
    return False

def auto_build_params_from_table(df, uploaded_filename):
    """
    Автоматически строит параметры и иерархию из колонок таблицы для новой уникальной таблицы.
    Определяет параметры из колонок, которые не являются стандартными.
    """
    if df is None or df.empty:
        return
    
    # Стандартные колонки, которые не являются параметрами
    standard_columns = {
        "Артикул", "URL", "Статус", "Параметры", "Выручка", "Заказы", 
        "Средняя цена", "Позиция в выдаче", "Дата создания", "Упущенная выручка",
        "Изображение", "Ссылка", "Выкупы", "Продажи", "Средняя цена без СПП",
        "Цена (с СПП)", "Прибыль", "Стоимость за 1000 показов", "Бренд", "Поставщик",
        "Предмет", "Название", "Буст на позицию", "Буст с позиции", "Дельта", "Тип рекламы",
        # Служебные колонки - данные, а не параметры
        "Остаток", "Остатки", "Остатки на конец периода", "Остаток на конец периода",
        "Дней в наличии", "Дней в продаже", "Дни в наличии", "Дни в продаже",
        "Базовая цена", "Базовая цена, ₽", "Средняя цена без СПП", "Средняя цена",
        "Дата", "Дата начала", "Дата конца", "Период", "Конец периода",
        "Stock", "Stock Days", "Days in Stock", "Days Available",
        "Реализация", "Реализация, шт", "Возврат", "Возврат, шт",
        "Выкуп, %", "Процент выкупа", "Выкуп процент", "Выкуп",
        "Оборачиваемость", "Оборачиваемость, раз", "Оборачиваемость (раз)",
        "Рейтинг", "Отзывы", "Вопросы", "Рейтинг товара",
        "Конверсия", "Конверсия, %", "Процент конверсии",
        "Показы", "Клики", "CTR", "CPC", "CPA", "ROAS",
        "Расход", "Расходы", "Бюджет", "Бюджет рекламы",
        "Продано", "Продано, шт", "Заказано", "Заказано, шт",
        "Начало периода", "Конец периода", "Период расчета",
        "Расчет заказа", "Рекомендуемый заказ", "Оптимальный заказ"
    }
    
    # Ключевые слова для исключения служебных колонок (даже если они не в standard_columns)
    exclude_keywords = [
        "остат", "остатки", "остаток",
        "дней", "дни", "день",
        "период", "периода", "периоды",
        "конец", "начало", "дата",
        "цена", "цена,", "стоимость", "прибыль", "выручка", "расход",
        "расчет", "рекоменд", "оптимальн",
        "реализац", "возврат", "выкуп",
        "оборачиваемость", "конверсия",
        "рейтинг", "отзыв", "вопрос",
        "показ", "клик", "ctr", "cpc", "cpa", "roas",
        "продано", "заказано", "заказ,", "продаж",
        "stock", "days", "period", "price", "revenue", "profit"
    ]
    
    def is_service_column(col_name):
        """Проверяет, является ли колонка служебной (данные, а не параметр)"""
        col_lower = str(col_name).lower()
        # Проверяем по ключевым словам
        for keyword in exclude_keywords:
            if keyword in col_lower:
                return True
        return False
    
    # Определяем параметры из колонок таблицы (исключая стандартные и служебные)
    param_columns = [
        col for col in df.columns 
        if col not in standard_columns 
        and not is_service_column(col)
        and is_valid_param_name(col)
    ]
    
    if not param_columns:
        return
    
    # Проверяем, является ли это новой таблицей (по имени файла или хэшу)
    current_file_hash = f"{uploaded_filename}_{len(df)}"
    last_file_hash = st.session_state.get("last_processed_file_hash", None)
    
    # Если это новая таблица, строим параметры и иерархию заново
    if current_file_hash != last_file_hash:
        # Инициализируем param_values и param_options, если их нет
        if "param_values" not in st.session_state:
            st.session_state["param_values"] = {}
        if "param_options" not in st.session_state:
            st.session_state["param_options"] = {}
        
        # Создаем param_values и param_options из колонок таблицы
        param_values_new = {}
        param_options_new = {}
        
        for param_col in param_columns:
            param_values_new[param_col] = {}
            param_options_new[param_col] = []
            
            # Заполняем значения параметров из таблицы
            if "Артикул" in df.columns:
                for idx, row in df.iterrows():
                    sku = str(row.get("Артикул", "")).replace(".0", "")
                    if sku and sku != "nan":
                        value = row.get(param_col)
                        if pd.notna(value) and str(value).strip():
                            param_values_new[param_col][sku] = str(value).strip()
            
            # Собираем уникальные варианты значений для параметра
            unique_values = df[param_col].dropna().astype(str).str.strip().unique()
            param_options_new[param_col] = sorted([v for v in unique_values if v]) if len(unique_values) > 0 else []
        
        # Обновляем param_values и param_options, дополняя существующие (не перезаписывая полностью)
        for param_name, param_data in param_values_new.items():
            if param_name not in st.session_state["param_values"]:
                st.session_state["param_values"][param_name] = {}
            # Дополняем значениями из новой таблицы
            st.session_state["param_values"][param_name].update(param_data)
        
        for param_name, options in param_options_new.items():
            if param_name not in st.session_state["param_options"]:
                st.session_state["param_options"][param_name] = []
            # Объединяем варианты значений, убирая дубликаты
            existing_options = set(st.session_state["param_options"][param_name])
            new_options = set(options)
            st.session_state["param_options"][param_name] = sorted(list(existing_options | new_options))
        
        # Автоматически строим иерархию на основе найденных параметров
        # Типичные иерархические параметры (приоритет)
        hierarchy_candidates = ["Тип", "Категория", "Группа", "Класс"]
        subtype_candidates = ["Рукав", "Ворот", "Подтип", "Разновидность"]
        visual_candidates = ["Цвет", "Принт", "Логотип", "Строчка", "Шов", "Строчка шов", "Расцветка", "Оттенок"]
        
        # Определяем иерархические параметры
        hierarchy_params_auto = [p for p in hierarchy_candidates if p in param_columns]
        if not hierarchy_params_auto:
            # Если стандартных нет, берем первые 2-3 параметра как иерархические
            hierarchy_params_auto = param_columns[:min(3, len(param_columns))]
        
        # Определяем параметры подтипа
        subtype_params_auto = [p for p in subtype_candidates if p in param_columns]
        
        # Определяем визуальные параметры
        visual_params_auto = [p for p in visual_candidates if p in param_columns]
        # Дополняем остальными параметрами, которые не попали в другие категории
        remaining_params = [p for p in param_columns if p not in hierarchy_params_auto and p not in subtype_params_auto]
        visual_params_auto.extend(remaining_params[:min(5, len(remaining_params))])
        
        # Обновляем иерархию, если её еще нет или она не соответствует новым параметрам
        if "hierarchy_params" not in st.session_state or not st.session_state.get("hierarchy_params"):
            st.session_state["hierarchy_params"] = hierarchy_params_auto
        else:
            # Дополняем существующую иерархию новыми параметрами
            existing_hierarchy = set(st.session_state["hierarchy_params"])
            new_hierarchy = existing_hierarchy | set(hierarchy_params_auto)
            st.session_state["hierarchy_params"] = list(new_hierarchy)
        
        if "subtype_params" not in st.session_state or not st.session_state.get("subtype_params"):
            st.session_state["subtype_params"] = subtype_params_auto
        else:
            existing_subtype = set(st.session_state["subtype_params"])
            new_subtype = existing_subtype | set(subtype_params_auto)
            st.session_state["subtype_params"] = list(new_subtype)
        
        if "visual_params" not in st.session_state or not st.session_state.get("visual_params"):
            st.session_state["visual_params"] = visual_params_auto
        else:
            existing_visual = set(st.session_state["visual_params"])
            new_visual = existing_visual | set(visual_params_auto)
            st.session_state["visual_params"] = list(new_visual)
        
        # Сохраняем хэш обработанного файла
        st.session_state["last_processed_file_hash"] = current_file_hash
        
        # Сохраняем конфигурацию иерархии в файл
        save_hierarchy_config()

def save_mass_analysis_progress(skus_to_process: list, processed_skus: set, results: list, settings: dict):
    """Сохраняет прогресс массового анализа"""
    try:
        progress_data = {
            "skus_to_process": skus_to_process,
            "processed_skus": list(processed_skus),
            "results": results,
            "settings": settings,
            "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        with open("mass_analysis_progress.json", "w", encoding="utf-8") as f:
            json.dump(progress_data, f, ensure_ascii=False, indent=2)
        return True
    except Exception as e:
        return False

def load_mass_analysis_progress():
    """Загружает сохраненный прогресс массового анализа"""
    try:
        if os.path.exists("mass_analysis_progress.json"):
            with open("mass_analysis_progress.json", "r", encoding="utf-8") as f:
                progress_data = json.load(f)
            return progress_data
    except Exception as e:
        pass
    return None

def clear_mass_analysis_progress():
    """Удаляет сохраненный прогресс массового анализа"""
    try:
        if os.path.exists("mass_analysis_progress.json"):
            os.remove("mass_analysis_progress.json")
        return True
    except Exception as e:
        return False

def save_excluded_params_settings():
    """Сохраняет настройки исключения параметров в файл"""
    try:
        excluded_params = st.session_state.get("excluded_params", [])
        excluded_param_values = st.session_state.get("excluded_param_values", {})
        
        settings = {
            "excluded_params": excluded_params,
            "excluded_param_values": excluded_param_values,
            "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        
        with open("excluded_params_settings.json", "w", encoding="utf-8") as f:
            json.dump(settings, f, ensure_ascii=False, indent=2)
        
        return True
    except Exception as e:
        st.error(f"Ошибка сохранения настроек исключения параметров: {e}")
        return False

def load_excluded_params_settings():
    """Загружает настройки исключения параметров из файла"""
    try:
        if os.path.exists("excluded_params_settings.json"):
            with open("excluded_params_settings.json", "r", encoding="utf-8") as f:
                settings = json.load(f)
                
            if "excluded_params" in settings:
                st.session_state["excluded_params"] = settings["excluded_params"]
            else:
                st.session_state["excluded_params"] = []
                
            if "excluded_param_values" in settings:
                st.session_state["excluded_param_values"] = settings["excluded_param_values"]
            else:
                st.session_state["excluded_param_values"] = {}
                
            return True
    except Exception as e:
        # Не показываем ошибку, просто используем значения по умолчанию
        pass
    return False

def save_full_project(project_name: str = None):
    """Сохраняет полный проект в JSON файл, включая данные файла"""
    try:
        # Если проект уже существует, используем его ID, иначе создаем новый
        import hashlib
        current_project_id = st.session_state.get("current_project_id", None)
        
        if current_project_id and project_name:
            # Обновляем существующий проект - используем старый ID
            project_id = current_project_id
        else:
            # Создаем новый проект - генерируем новый ID
            project_id = hashlib.md5(
                (project_name or f"Проект_{pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')}").encode('utf-8')
            ).hexdigest()[:12]
        
        project_name_final = project_name or f"Проект_{pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')}"
        
        # Получаем данные файла, если они есть
        cached_file_name = st.session_state.get("cached_file_name", None)
        cached_file_data = None
        file_data_base64 = None
        
        # Пытаемся загрузить файл из кеша или из session_state
        if cached_file_name:
            # Сначала проверяем session_state
            if "cached_file_data" in st.session_state and st.session_state["cached_file_data"]:
                cached_file_data = st.session_state["cached_file_data"]
            else:
                # Пытаемся загрузить из file_cache
                cache_dir = "file_cache"
                cache_path = os.path.join(cache_dir, cached_file_name)
                if os.path.exists(cache_path):
                    with open(cache_path, "rb") as f:
                        cached_file_data = f.read()
            
            # Кодируем файл в base64 для сохранения в JSON
            if cached_file_data:
                file_data_base64 = base64.b64encode(cached_file_data).decode('utf-8')
        
        # Собираем все данные проекта
        project_data = {
            "project_version": "1.1",
            "project_id": project_id,
            "export_date": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
            "project_name": project_name_final,
            
            # Параметры (только для этого проекта)
            "param_values": get_param_values(),
            "param_options": st.session_state.get("param_options", {}),
            
            # Иерархия параметров
            "hierarchy_params": st.session_state.get("hierarchy_params", []),
            "subtype_params": st.session_state.get("subtype_params", []),
            "visual_params": st.session_state.get("visual_params", []),
            
            # Удаленные параметры
            "deleted_params": list(st.session_state.get("deleted_params", set())),
            
            # Исключенные параметры
            "excluded_params": st.session_state.get("excluded_params", []),
            "excluded_param_values": st.session_state.get("excluded_param_values", {}),
            
            # Настройки главной страницы
            "main_page_settings": {
                "search": st.session_state.get("search", ""),
                "spp": st.session_state.get("spp", 25),
                "buyout_pct": st.session_state.get("buyout_pct", 25),
                "revenue_min": st.session_state.get("revenue_min", 0),
                "revenue_max": st.session_state.get("revenue_max", 1000000),
                "price_min": st.session_state.get("price_min", 0),
                "price_max": st.session_state.get("price_max", 10000),
                "show_images": st.session_state.get("show_images", False),
                "sort_column": st.session_state.get("sort_column", "Выручка"),
                "sort_descending": st.session_state.get("sort_descending", True)
            },
            
            # Информация о загруженном файле
            "cached_file_name": cached_file_name,
            "cached_file_data_base64": file_data_base64,  # Данные файла в base64
            "file_size": len(cached_file_data) if cached_file_data else 0,
            
            # История параметров (опционально)
            "param_history": load_param_history_from_file() if os.path.exists("param_history.json") else {}
        }
        
        # Обновляем метаданные файла с информацией о проекте для восстановления при перезагрузке
        if cached_file_name:
            try:
                meta_data = {
                    "filename": cached_file_name,
                    "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "size": len(cached_file_data) if cached_file_data else 0,
                    "project_id": project_id,
                    "project_name": project_name_final
                }
                with open("file_cache_meta.json", "w", encoding="utf-8") as f:
                    json.dump(meta_data, f, ensure_ascii=False, indent=2)
            except Exception:
                pass  # Не критично
        
        # Конвертируем в JSON строку
        project_json = json.dumps(project_data, ensure_ascii=False, indent=2, default=str)
        
        # Обновляем session_state с информацией о проекте
        st.session_state["current_project_id"] = project_id
        st.session_state["current_project_name"] = project_name_final
        
        return project_json, project_data["project_name"], project_id
    except Exception as e:
        import traceback
        st.error(f"Ошибка сохранения проекта: {e}\n{traceback.format_exc()}")
        return None, None, None

def load_full_project(project_json: str):
    """Загружает полный проект из JSON файла, включая восстановление файла данных"""
    try:
        project_data = json.loads(project_json)
        
        # Проверяем версию проекта
        project_version = project_data.get("project_version", "1.0")
        project_id = project_data.get("project_id", None)
        project_name = project_data.get("project_name", "Проект")
        
        # Восстанавливаем файл данных, если он есть
        cached_file_name = project_data.get("cached_file_name", None)
        file_data_base64 = project_data.get("cached_file_data_base64", None)
        
        if cached_file_name and file_data_base64:
            try:
                # Декодируем файл из base64
                file_data = base64.b64decode(file_data_base64)
                
                # Сохраняем файл в кеш
                cache_dir = "file_cache"
                if not os.path.exists(cache_dir):
                    os.makedirs(cache_dir)
                
                cache_path = os.path.join(cache_dir, cached_file_name)
                with open(cache_path, "wb") as f:
                    f.write(file_data)
                
                # Сохраняем в session_state для немедленного использования
                st.session_state["cached_file_data"] = file_data
                st.session_state["cached_file_name"] = cached_file_name
                
                # Обновляем метаданные кеша
                meta_data = {
                    "filename": cached_file_name,
                    "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "size": len(file_data),
                    "project_id": project_id,
                    "project_name": project_name
                }
                with open("file_cache_meta.json", "w", encoding="utf-8") as f:
                    json.dump(meta_data, f, ensure_ascii=False, indent=2)
                
            except Exception as e:
                st.warning(f"⚠️ Не удалось восстановить файл данных: {e}")
        
        # Очищаем старые параметры перед загрузкой новых
        # Это важно для изоляции параметров между проектами
        st.session_state["param_values"] = {}
        st.session_state["param_options"] = {}
        st.session_state["hierarchy_params"] = []
        st.session_state["subtype_params"] = []
        st.session_state["visual_params"] = []
        st.session_state["deleted_params"] = set()
        st.session_state["excluded_params"] = []
        st.session_state["excluded_param_values"] = {}
        
        # Загружаем параметры проекта
        if "param_values" in project_data:
            st.session_state["param_values"] = project_data["param_values"]
        if "param_options" in project_data:
            st.session_state["param_options"] = project_data["param_options"]
        
        # Загружаем иерархию параметров
        if "hierarchy_params" in project_data:
            st.session_state["hierarchy_params"] = project_data["hierarchy_params"]
        if "subtype_params" in project_data:
            st.session_state["subtype_params"] = project_data["subtype_params"]
        if "visual_params" in project_data:
            st.session_state["visual_params"] = project_data["visual_params"]
        
        # Загружаем удаленные параметры
        if "deleted_params" in project_data:
            deleted_params = project_data["deleted_params"]
            st.session_state["deleted_params"] = set(deleted_params) if isinstance(deleted_params, list) else deleted_params
        
        # Загружаем исключенные параметры
        if "excluded_params" in project_data:
            st.session_state["excluded_params"] = project_data["excluded_params"]
        if "excluded_param_values" in project_data:
            st.session_state["excluded_param_values"] = project_data["excluded_param_values"]
        
        # Загружаем настройки главной страницы
        if "main_page_settings" in project_data:
            main_settings = project_data["main_page_settings"]
            st.session_state["search"] = main_settings.get("search", "")
            st.session_state["spp"] = main_settings.get("spp", 25)
            st.session_state["buyout_pct"] = main_settings.get("buyout_pct", 25)
            st.session_state["revenue_min"] = main_settings.get("revenue_min", 0)
            st.session_state["revenue_max"] = main_settings.get("revenue_max", 1000000)
            st.session_state["price_min"] = main_settings.get("price_min", 0)
            st.session_state["price_max"] = main_settings.get("price_max", 10000)
            st.session_state["show_images"] = main_settings.get("show_images", False)
            st.session_state["sort_column"] = main_settings.get("sort_column", "Выручка")
            st.session_state["sort_descending"] = main_settings.get("sort_descending", True)
        
        # Устанавливаем флаг загрузки проекта, чтобы избежать конфликтов
        st.session_state["project_loading"] = True
        
        # Сохраняем все данные в файлы (с привязкой к текущему файлу проекта)
        # ВАЖНО: НЕ вызываем save_deleted_params_to_file() здесь, так как это сохранит
        # deleted_params в глобальный файл, что затронет все проекты.
        # deleted_params уже загружены из проекта и находятся в session_state.
        save_param_values_to_file()
        save_hierarchy_config()
        # save_deleted_params_to_file() - НЕ вызываем при загрузке проекта!
        save_excluded_params_settings()
        save_main_page_data_to_file()
        
        # Снимаем флаг загрузки
        st.session_state["project_loading"] = False
        
        # Загружаем историю параметров, если есть
        if "param_history" in project_data and project_data["param_history"]:
            try:
                with open("param_history.json", "w", encoding="utf-8") as f:
                    json.dump(project_data["param_history"], f, ensure_ascii=False, indent=2)
            except Exception:
                pass
        
        # Сохраняем ID проекта в session_state для отслеживания
        if project_id:
            st.session_state["current_project_id"] = project_id
            st.session_state["current_project_name"] = project_name
        
        return True, project_name
    except Exception as e:
        import traceback
        st.error(f"Ошибка загрузки проекта: {e}\n{traceback.format_exc()}")
        return False, None

def save_mass_analysis_results(results: list):
    """Сохраняет результаты массового анализа в отдельный файл для постоянного хранения"""
    try:
        # Очищаем удаленные параметры перед сохранением
        cleaned_results = remove_deleted_params_from_mass_results(results)
        with open("mass_analysis_results.json", "w", encoding="utf-8") as f:
            json.dump(cleaned_results, f, ensure_ascii=False, indent=2)
        return True
    except Exception as e:
        return False

def load_mass_analysis_results():
    """Загружает сохраненные результаты массового анализа"""
    try:
        if os.path.exists("mass_analysis_results.json"):
            with open("mass_analysis_results.json", "r", encoding="utf-8") as f:
                results = json.load(f)
            results = results if isinstance(results, list) else []
            # Очищаем удаленные параметры из результатов
            results = remove_deleted_params_from_mass_results(results)
            return results
    except Exception as e:
        pass
    return []

def remove_deleted_params_from_mass_results(results: list) -> list:
    """Удаляет удаленные параметры из результатов массового анализа"""
    if not results:
        return results
    
    # Получаем список удаленных параметров
    deleted_params = set()
    if "deleted_params" in st.session_state:
        deleted_params = st.session_state["deleted_params"]
    else:
        deleted_params = load_deleted_params_from_file()
        # Сохраняем в session_state для будущих использований
        if deleted_params:
            st.session_state["deleted_params"] = deleted_params
    
    if not deleted_params:
        return results
    
    # Список обязательных полей, которые не являются параметрами
    required_fields = {"Артикул", "URL", "Статус", "Параметры"}
    
    cleaned_results = []
    for result in results:
        # Создаем копию результата без удаленных параметров
        # Сохраняем обязательные поля и параметры, которые не были удалены
        cleaned_result = {
            k: v for k, v in result.items() 
            if k in required_fields or k not in deleted_params
        }
        cleaned_results.append(cleaned_result)
    
    return cleaned_results

def export_mass_analysis_results_to_csv(results: list):
    """Экспортирует результаты массового анализа в CSV"""
    try:
        if not results:
            return None
        
        df = pd.DataFrame(results)
        
        # Убеждаемся, что колонка Артикул есть и в правильном формате
        if "Артикул" in df.columns:
            df["Артикул"] = df["Артикул"].astype(str).str.replace(".0", "", regex=False)
        
        # Сортируем колонки: сначала основные, потом параметры
        main_cols = ["Артикул", "URL", "Статус", "Параметры"]
        param_cols = [col for col in df.columns if col not in main_cols]
        column_order = [col for col in main_cols if col in df.columns] + sorted(param_cols)
        
        if column_order:
            df = df[column_order]
        
        csv_data = df.to_csv(encoding='utf-8-sig', index=False)
        return csv_data
    except Exception as e:
        st.error(f"Ошибка экспорта в CSV: {e}")
        return None

def import_mass_analysis_results_from_csv(csv_data: str):
    """Импортирует результаты массового анализа из CSV и применяет параметры"""
    try:
        import io
        df = pd.read_csv(io.StringIO(csv_data), encoding='utf-8-sig')
        
        results = []
        applied_count = 0
        
        # Инициализируем param_values если нет
        if "param_values" not in st.session_state:
            st.session_state["param_values"] = {}
        if "param_options" not in st.session_state:
            st.session_state["param_options"] = {}
        
        for _, row in df.iterrows():
            # Получаем артикул
            sku_raw = row.get("Артикул", "")
            if pd.isna(sku_raw) or not sku_raw:
                continue
            
            sku = str(int(sku_raw)) if isinstance(sku_raw, (int, float)) else str(sku_raw).replace(".0", "")
            
            # Создаем запись результата
            result_row = {
                "Артикул": sku,
                "URL": row.get("URL", ""),
                "Статус": row.get("Статус", "✅ Импортировано"),
                "Параметры": row.get("Параметры", "")
            }
            
            # Извлекаем параметры из строки (если есть колонка Параметры)
            params_dict = {}
            if "Параметры" in row and pd.notna(row["Параметры"]):
                params_str = str(row["Параметры"])
                for param_pair in params_str.split(", "):
                    if ":" in param_pair:
                        param_name, param_value = param_pair.split(":", 1)
                        param_name = param_name.strip()
                        param_value = param_value.strip()
                        if param_name and param_value:
                            params_dict[param_name] = param_value
            
            # Также проверяем отдельные колонки параметров (но исключаем служебные)
            # Используем ту же логику фильтрации, что и в auto_build_params_from_table
            standard_cols = {
                "Артикул", "URL", "Статус", "Параметры", "Выручка", "Заказы", 
                "Средняя цена", "Позиция в выдаче", "Дата создания", "Упущенная выручка",
                "Изображение", "Ссылка", "Выкупы", "Продажи", "Средняя цена без СПП",
                "Цена (с СПП)", "Прибыль", "Стоимость за 1000 показов", "Бренд", "Поставщик",
                "Предмет", "Название", "Буст на позицию", "Буст с позиции", "Дельта", "Тип рекламы",
                "Остаток", "Остатки", "Остатки на конец периода", "Остаток на конец периода",
                "Дней в наличии", "Дней в продаже", "Дни в наличии", "Дни в продаже",
                "Базовая цена", "Базовая цена, ₽", "Дата", "Дата начала", "Дата конца", "Период", "Конец периода",
                "Stock", "Stock Days", "Days in Stock", "Days Available",
                "Реализация", "Реализация, шт", "Возврат", "Возврат, шт",
                "Выкуп, %", "Процент выкупа", "Выкуп процент", "Выкуп",
                "Оборачиваемость", "Оборачиваемость, раз", "Оборачиваемость (раз)",
                "Рейтинг", "Отзывы", "Вопросы", "Рейтинг товара",
                "Конверсия", "Конверсия, %", "Процент конверсии",
                "Показы", "Клики", "CTR", "CPC", "CPA", "ROAS",
                "Расход", "Расходы", "Бюджет", "Бюджет рекламы",
                "Продано", "Продано, шт", "Заказано", "Заказано, шт",
                "Начало периода", "Конец периода", "Период расчета",
                "Расчет заказа", "Рекомендуемый заказ", "Оптимальный заказ"
            }
            
            exclude_keywords = [
                "остат", "остатки", "остаток",
                "дней", "дни", "день",
                "период", "периода", "периоды",
                "конец", "начало", "дата",
                "цена", "цена,", "стоимость", "прибыль", "выручка", "расход",
                "расчет", "рекоменд", "оптимальн",
                "реализац", "возврат", "выкуп",
                "оборачиваемость", "конверсия",
                "рейтинг", "отзыв", "вопрос",
                "показ", "клик", "ctr", "cpc", "cpa", "roas",
                "продано", "заказано", "заказ,", "продаж",
                "stock", "days", "period", "price", "revenue", "profit"
            ]
            
            def is_service_column(col_name):
                """Проверяет, является ли колонка служебной (данные, а не параметр)"""
                col_lower = str(col_name).lower()
                for keyword in exclude_keywords:
                    if keyword in col_lower:
                        return True
                return False
            
            param_cols = [
                col for col in df.columns 
                if col not in standard_cols 
                and not is_service_column(col)
                and is_valid_param_name(col)
            ]
            
            for param_name in param_cols:
                param_value = row.get(param_name)
                if pd.notna(param_value) and str(param_value).strip():
                    params_dict[param_name] = str(param_value).strip()
            
            # Применяем параметры к param_values
            if params_dict:
                # Загружаем список удаленных параметров
                if "deleted_params" not in st.session_state:
                    st.session_state["deleted_params"] = load_deleted_params_from_file()
                
                deleted_params = st.session_state.get("deleted_params", set())
                
                for param_name, param_value in params_dict.items():
                    # Пропускаем невалидные параметры
                    if not is_valid_param_name(param_name):
                        continue
                    
                    # Пропускаем удаленные параметры
                    if param_name in deleted_params:
                        continue
                    
                    # Сохраняем параметр
                    save_param_value(sku, param_name, str(param_value), save_history=True)
                    
                    # Обновляем param_options
                    if param_name not in st.session_state["param_options"]:
                        st.session_state["param_options"][param_name] = []
                    if param_value and str(param_value) not in st.session_state["param_options"][param_name]:
                        st.session_state["param_options"][param_name].append(str(param_value))
                    
                    applied_count += 1
            
            # Добавляем параметры в результат
            result_row.update(params_dict)
            results.append(result_row)
        
        # Сохраняем результаты в session_state
        if "mass_analysis_results" not in st.session_state:
            st.session_state["mass_analysis_results"] = []
        
        # Объединяем с существующими результатами (обновляем по артикулу)
        existing_results = {str(r.get("Артикул", "")).replace(".0", ""): r for r in st.session_state["mass_analysis_results"]}
        for result in results:
            sku = str(result.get("Артикул", "")).replace(".0", "")
            existing_results[sku] = result
        
        st.session_state["mass_analysis_results"] = list(existing_results.values())
        
        # Сохраняем результаты и параметры в файлы
        save_mass_analysis_results(st.session_state["mass_analysis_results"])
        save_param_values_to_file()
        
        return len(results), applied_count
    except Exception as e:
        st.error(f"Ошибка импорта из CSV: {e}")
        return 0, 0

def export_product_params_to_csv():
    """Экспортирует параметры товаров в CSV файл для редактирования"""
    try:
        # Получаем данные
        df = st.session_state.get("df")
        if df is None:
            df = st.session_state.get("display_df")
        
        if df is None or "Артикул" not in df.columns:
            return None
        
        param_values = get_param_values()
        if not param_values:
            return None
        
        # Создаем DataFrame с артикулами
        export_data = []
        all_skus = df["Артикул"].dropna().unique()
        
        for sku in all_skus:
            sku_str = str(sku).replace(".0", "")
            row = {"Артикул": sku_str}
            
            # Добавляем все параметры
            for param_name, param_dict in param_values.items():
                value = param_dict.get(sku_str, "")
                row[param_name] = value if value else ""
            
            export_data.append(row)
        
        export_df = pd.DataFrame(export_data)
        
        # Сортируем колонки: сначала Артикул, потом параметры по алфавиту
        param_cols = sorted([col for col in export_df.columns if col != "Артикул"])
        column_order = ["Артикул"] + param_cols
        export_df = export_df[column_order]
        
        csv_data = export_df.to_csv(index=False, encoding='utf-8-sig')
        return csv_data
    except Exception as e:
        st.error(f"Ошибка экспорта параметров в CSV: {e}")
        return None

def import_product_params_from_csv(csv_data: str):
    """Импортирует параметры товаров из CSV файла и применяет их"""
    try:
        import io
        df = pd.read_csv(io.StringIO(csv_data), encoding='utf-8-sig')
        
        if "Артикул" not in df.columns:
            return 0, 0
        
        # Инициализируем param_values если нет
        if "param_values" not in st.session_state:
            st.session_state["param_values"] = {}
        if "param_options" not in st.session_state:
            st.session_state["param_options"] = {}
        
        param_values = st.session_state["param_values"]
        param_options = st.session_state["param_options"]
        
        imported_count = 0
        updated_count = 0
        
        # Получаем список колонок параметров (все кроме Артикул)
        param_columns = [col for col in df.columns if col != "Артикул"]
        
        for _, row in df.iterrows():
            sku_raw = row.get("Артикул", "")
            if pd.isna(sku_raw) or not sku_raw:
                continue
            
            sku = str(int(sku_raw)) if isinstance(sku_raw, (int, float)) else str(sku_raw).replace(".0", "")
            imported_count += 1
            
            # Обновляем параметры для этого артикула
            for param_name in param_columns:
                value = row.get(param_name, "")
                
                # Пропускаем пустые значения
                if pd.isna(value) or (isinstance(value, str) and not value.strip()):
                    continue
                
                value_str = str(value).strip()
                
                # Инициализируем параметр если его нет
                if param_name not in param_values:
                    param_values[param_name] = {}
                
                # Обновляем значение
                old_value = param_values[param_name].get(sku, "")
                param_values[param_name][sku] = value_str
                
                # Добавляем значение в param_options если его там нет
                if param_name not in param_options:
                    param_options[param_name] = []
                
                if value_str and value_str not in param_options[param_name]:
                    param_options[param_name].append(value_str)
                
                # Считаем обновления
                if old_value != value_str:
                    updated_count += 1
        
        # Сохраняем обновленные данные
        st.session_state["param_values"] = param_values
        st.session_state["param_options"] = param_options
        
        return imported_count, updated_count
    except Exception as e:
        st.error(f"Ошибка импорта параметров из CSV: {e}")
        return 0, 0

def apply_mass_analysis_results_to_params(results: list):
    """Автоматически применяет параметры из результатов массового анализа к param_values"""
    try:
        applied_count = 0
        
        if "param_values" not in st.session_state:
            st.session_state["param_values"] = {}
        if "param_options" not in st.session_state:
            st.session_state["param_options"] = {}
        
        for result in results:
            # Пропускаем неуспешные результаты
            status = result.get("Статус", "")
            if not status.startswith("✅"):
                continue
            
            sku_raw = result.get("Артикул", "")
            if not sku_raw:
                continue
            
            sku = str(int(sku_raw)) if isinstance(sku_raw, (int, float)) else str(sku_raw).replace(".0", "")
            
            # Извлекаем параметры из результата
            params_dict = {}
            
            # Получаем параметры из колонки "Параметры" если есть
            if "Параметры" in result and result["Параметры"]:
                params_str = str(result["Параметры"])
                for param_pair in params_str.split(", "):
                    if ":" in param_pair:
                        param_name, param_value = param_pair.split(":", 1)
                        param_name = param_name.strip()
                        param_value = param_value.strip()
                        if param_name and param_value:
                            params_dict[param_name] = param_value
            
            # Также берем параметры из всех ключей результата (кроме служебных)
            excluded_keys = ["Артикул", "URL", "Статус", "Параметры"]
            for key, value in result.items():
                if key not in excluded_keys and value and str(value).strip():
                    params_dict[key] = str(value).strip()
            
            # Применяем параметры
            if params_dict:
                # Загружаем список удаленных параметров
                if "deleted_params" not in st.session_state:
                    st.session_state["deleted_params"] = load_deleted_params_from_file()
                
                deleted_params = st.session_state.get("deleted_params", set())
                
                for param_name, param_value in params_dict.items():
                    # Пропускаем невалидные параметры
                    if not is_valid_param_name(param_name):
                        continue
                    
                    # Пропускаем удаленные параметры
                    if param_name in deleted_params:
                        continue
                    
                    # Сохраняем параметр с историей
                    save_param_value(sku, param_name, str(param_value), save_history=True)
                    
                    # Обновляем param_options
                    if param_name not in st.session_state["param_options"]:
                        st.session_state["param_options"][param_name] = []
                    if param_value and str(param_value) not in st.session_state["param_options"][param_name]:
                        st.session_state["param_options"][param_name].append(str(param_value))
                    
                    applied_count += 1
        
        return applied_count
    except Exception as e:
        st.error(f"Ошибка применения параметров: {e}")
        return 0

def save_param_values_to_file():
    """Сохраняет параметры в файл, привязанные к текущему файлу/проекту"""
    param_values = get_param_values()
    current_file = st.session_state.get("cached_file_name", None)
    
    # ВАЖНО: deleted_params берутся ТОЛЬКО из session_state текущего проекта,
    # а не из глобального файла. Это обеспечивает изоляцию между проектами.
    deleted_params = st.session_state.get("deleted_params", set())
    
    # Если deleted_params не установлены, инициализируем пустым set
    if not isinstance(deleted_params, set):
        deleted_params = set(deleted_params) if deleted_params else set()
        st.session_state["deleted_params"] = deleted_params
    
    # Удаляем удаленные параметры из param_values перед сохранением
    if deleted_params:
        param_values = {k: v for k, v in param_values.items() if k not in deleted_params}
    
    # Получаем param_options для сохранения
    param_options = st.session_state.get("param_options", {})
    # Также удаляем удаленные параметры из param_options
    if deleted_params:
        param_options = {k: v for k, v in param_options.items() if k not in deleted_params}
    
    if param_values and current_file:
        try:
            # Создаем имя файла на основе текущего файла
            file_hash = hash(current_file) % 1000000  # Простой хеш для имени файла
            param_file = f"param_values_{file_hash}.json"
            
            # Сохраняем параметры с информацией о файле, включая param_options и deleted_params
            param_data = {
                "file_name": current_file,
                "param_values": param_values,
                "param_options": param_options,  # Добавляем варианты параметров
                "deleted_params": list(deleted_params) if deleted_params else [],  # Сохраняем удаленные параметры
                "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S")
            }
            
            with open(param_file, "w", encoding="utf-8") as f:
                json.dump(param_data, f, ensure_ascii=False, indent=2)
            
            # Также сохраняем в общий реестр файлов
            update_file_params_registry(current_file, param_file)
            return True
        except Exception as e:
            st.error(f"Ошибка сохранения параметров: {e}")
            return False
    elif param_values and not current_file:
        # Fallback для случаев, когда нет текущего файла
        try:
            # Сохраняем и param_values, и param_options в глобальный файл
            global_data = {
                "param_values": param_values,
                "param_options": param_options
            }
            with open("param_values_global.json", "w", encoding="utf-8") as f:
                json.dump(global_data, f, ensure_ascii=False, indent=2)
            return True
        except Exception:
            return False
    elif param_options and not param_values:
        # Сохраняем только param_options, если нет param_values
        try:
            if current_file:
                file_hash = hash(current_file) % 1000000
                param_file = f"param_values_{file_hash}.json"
                param_data = {
                    "file_name": current_file,
                    "param_values": {},
                    "param_options": param_options,
                    "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S")
                }
                with open(param_file, "w", encoding="utf-8") as f:
                    json.dump(param_data, f, ensure_ascii=False, indent=2)
                update_file_params_registry(current_file, param_file)
                return True
            else:
                global_data = {"param_values": {}, "param_options": param_options}
                with open("param_values_global.json", "w", encoding="utf-8") as f:
                    json.dump(global_data, f, ensure_ascii=False, indent=2)
            return True
        except Exception:
            return False
    return False

def update_file_params_registry(file_name, param_file):
    """Обновляет реестр файлов и их параметров"""
    try:
        registry_file = "file_params_registry.json"
        registry = {}
        
        if os.path.exists(registry_file):
            with open(registry_file, "r", encoding="utf-8") as f:
                registry = json.load(f)
        
        registry[file_name] = {
            "param_file": param_file,
            "last_updated": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        
        with open(registry_file, "w", encoding="utf-8") as f:
            json.dump(registry, f, ensure_ascii=False, indent=2)
            
    except Exception as e:
        st.error(f"Ошибка обновления реестра: {e}")

def save_deleted_params_to_file():
    """
    Сохраняет список удаленных параметров только для текущего проекта/файла.
    НЕ сохраняет в глобальный файл, чтобы не затрагивать другие проекты.
    Удаленные параметры сохраняются только в файл параметров текущего проекта.
    """
    try:
        # Получаем текущие удаленные параметры из session_state
        current_deleted = st.session_state.get("deleted_params", set())
        
        # Убеждаемся, что это set
        if not isinstance(current_deleted, set):
            current_deleted = set(current_deleted) if current_deleted else set()
            st.session_state["deleted_params"] = current_deleted
        
        # ВАЖНО: Не сохраняем в глобальный файл deleted_params.json,
        # чтобы не затрагивать другие проекты. Удаленные параметры
        # сохраняются только вместе с проектом через save_full_project()
        # или в файл параметров текущего проекта через save_param_values_to_file()
        
        # Очищаем только файлы параметров ТЕКУЩЕГО проекта от удаленных параметров
        current_file = st.session_state.get("cached_file_name", None)
        if current_deleted and current_file:
            # Очищаем только файл параметров текущего проекта
            try:
                file_hash = hash(current_file) % 1000000
                param_file = f"param_values_{file_hash}.json"
                
                if os.path.exists(param_file):
                    with open(param_file, "r", encoding="utf-8") as f:
                        param_data = json.load(f)
                    
                    if isinstance(param_data, dict) and "param_values" in param_data:
                        # Удаляем удаленные параметры только из текущего файла проекта
                        cleaned_params = {k: v for k, v in param_data.get("param_values", {}).items() if k not in current_deleted}
                        cleaned_options = {k: v for k, v in param_data.get("param_options", {}).items() if k not in current_deleted}
                        
                        param_data["param_values"] = cleaned_params
                        param_data["param_options"] = cleaned_options
                        # Сохраняем deleted_params в файл проекта
                        param_data["deleted_params"] = list(current_deleted)
                        
                        with open(param_file, "w", encoding="utf-8") as f:
                            json.dump(param_data, f, ensure_ascii=False, indent=2)
            except Exception as e:
                # Не критично, продолжаем
                pass
        
        return True
    except Exception as e:
        import traceback
        if hasattr(st, 'error'):
            st.error(f"Ошибка сохранения deleted_params: {e}\n{traceback.format_exc()}")
        else:
            print(f"Ошибка сохранения deleted_params: {e}\n{traceback.format_exc()}")
        return False

def clean_deleted_params_from_all_files(deleted_params: set):
    """Удаляет удаленные параметры из всех файлов параметров"""
    if not deleted_params:
        return
    
    import glob
    
    # Очищаем все файлы param_values*.json (включая param_values.json без подчеркивания)
    param_files = glob.glob("param_values*.json")
    cleaned_count = 0
    for param_file in param_files:
        try:
            with open(param_file, "r", encoding="utf-8") as f:
                param_data = json.load(f)
            
            # Поддерживаем оба формата: новый (с file_name) и старый (прямой словарь)
            if isinstance(param_data, dict) and "param_values" in param_data:
                # Новый формат
                file_params = param_data.get("param_values", {})
                file_options = param_data.get("param_options", {})
                
                # Удаляем удаленные параметры
                cleaned_params = {k: v for k, v in file_params.items() if k not in deleted_params}
                cleaned_options = {k: v for k, v in file_options.items() if k not in deleted_params}
                
                # Обновляем данные
                param_data["param_values"] = cleaned_params
                param_data["param_options"] = cleaned_options
                
                # Проверяем, были ли изменения
                if cleaned_params != file_params or cleaned_options != file_options:
                    # Сохраняем обратно
                    with open(param_file, "w", encoding="utf-8") as f:
                        json.dump(param_data, f, ensure_ascii=False, indent=2)
                    cleaned_count += 1
            else:
                # Старый формат - прямой словарь
                if isinstance(param_data, dict):
                    cleaned_params = {k: v for k, v in param_data.items() if k not in deleted_params}
                    if cleaned_params != param_data:
                        with open(param_file, "w", encoding="utf-8") as f:
                            json.dump(cleaned_params, f, ensure_ascii=False, indent=2)
                        cleaned_count += 1
        except Exception as e:
            # Пропускаем файлы с ошибками, но не прерываем процесс
            continue
    
    # Очищаем глобальный файл
    if os.path.exists("param_values_global.json"):
        try:
            with open("param_values_global.json", "r", encoding="utf-8") as f:
                global_data = json.load(f)
            
            # Поддерживаем оба формата
            if isinstance(global_data, dict) and "param_values" in global_data:
                original_params = global_data.get("param_values", {})
                original_options = global_data.get("param_options", {})
                
                cleaned_params = {k: v for k, v in original_params.items() if k not in deleted_params}
                cleaned_options = {k: v for k, v in original_options.items() if k not in deleted_params}
                
                if cleaned_params != original_params or cleaned_options != original_options:
                    global_data["param_values"] = cleaned_params
                    global_data["param_options"] = cleaned_options
                    with open("param_values_global.json", "w", encoding="utf-8") as f:
                        json.dump(global_data, f, ensure_ascii=False, indent=2)
                    cleaned_count += 1
            else:
                # Старый формат
                if isinstance(global_data, dict):
                    cleaned_global = {k: v for k, v in global_data.items() if k not in deleted_params}
                    if cleaned_global != global_data:
                        with open("param_values_global.json", "w", encoding="utf-8") as f:
                            json.dump(cleaned_global, f, ensure_ascii=False, indent=2)
                        cleaned_count += 1
        except Exception:
            pass
    
    # Очищаем table_cache.json
    if os.path.exists("table_cache.json"):
        try:
            with open("table_cache.json", "r", encoding="utf-8") as f:
                table_cache_data = json.load(f)
            
            if isinstance(table_cache_data, dict):
                changed = False
                # Очищаем param_values
                if "param_values" in table_cache_data:
                    original = table_cache_data["param_values"]
                    table_cache_data["param_values"] = {
                        k: v for k, v in original.items() 
                        if k not in deleted_params
                    }
                    if table_cache_data["param_values"] != original:
                        changed = True
                
                # Очищаем param_options
                if "param_options" in table_cache_data:
                    original = table_cache_data["param_options"]
                    table_cache_data["param_options"] = {
                        k: v for k, v in original.items() 
                        if k not in deleted_params
                    }
                    if table_cache_data["param_options"] != original:
                        changed = True
                
                if changed:
                    with open("table_cache.json", "w", encoding="utf-8") as f:
                        json.dump(table_cache_data, f, ensure_ascii=False, indent=2)
                    cleaned_count += 1
        except Exception:
            pass
    
    # Возвращаем количество очищенных файлов
    return cleaned_count
    
    # Возвращаем количество очищенных файлов
    return cleaned_count
    
    # Очищаем глобальный файл
    if os.path.exists("param_values_global.json"):
        try:
            with open("param_values_global.json", "r", encoding="utf-8") as f:
                global_data = json.load(f)
            
            # Поддерживаем оба формата
            if isinstance(global_data, dict) and "param_values" in global_data:
                cleaned_params = {k: v for k, v in global_data.get("param_values", {}).items() if k not in deleted_params}
                cleaned_options = {k: v for k, v in global_data.get("param_options", {}).items() if k not in deleted_params}
                global_data["param_values"] = cleaned_params
                global_data["param_options"] = cleaned_options
            else:
                # Старый формат
                global_data = {k: v for k, v in global_data.items() if k not in deleted_params} if isinstance(global_data, dict) else {}
            
            with open("param_values_global.json", "w", encoding="utf-8") as f:
                json.dump(global_data, f, ensure_ascii=False, indent=2)
        except Exception:
            pass
    
    # Очищаем table_cache.json
    if os.path.exists("table_cache.json"):
        try:
            with open("table_cache.json", "r", encoding="utf-8") as f:
                table_cache_data = json.load(f)
            
            if isinstance(table_cache_data, dict):
                # Очищаем param_values
                if "param_values" in table_cache_data:
                    table_cache_data["param_values"] = {
                        k: v for k, v in table_cache_data["param_values"].items() 
                        if k not in deleted_params
                    }
                
                # Очищаем param_options
                if "param_options" in table_cache_data:
                    table_cache_data["param_options"] = {
                        k: v for k, v in table_cache_data["param_options"].items() 
                        if k not in deleted_params
                    }
                
                # Сохраняем обратно
                with open("table_cache.json", "w", encoding="utf-8") as f:
                    json.dump(table_cache_data, f, ensure_ascii=False, indent=2)
        except Exception:
            pass

def load_deleted_params_from_file():
    """Загружает список удаленных параметров из файла"""
    try:
        if os.path.exists("deleted_params.json"):
            with open("deleted_params.json", "r", encoding="utf-8") as f:
                deleted_params_list = json.load(f)
            # Конвертируем list обратно в set
            return set(deleted_params_list) if isinstance(deleted_params_list, list) else set()
    except Exception:
        pass
    return set()

def create_html_report_with_charts(filtered_df, full_df, analysis_period=None):
    """
    Создает HTML отчет с графиками на основе данных дашборда
    
    Args:
        filtered_df: Отфильтрованный DataFrame с данными
        full_df: Полный DataFrame (для сравнения)
        analysis_period: Словарь с информацией о периоде анализа
        
    Returns:
        str: HTML код отчета
    """
    try:
        from plotly.graph_objects import Figure
        import plotly.express as px
        import plotly.io as pio
    except ImportError:
        return "<html><body><h1>Ошибка: plotly не установлен</h1></body></html>"
    
    html_parts = []
    
    # Начало HTML документа
    html_parts.append("""
    <!DOCTYPE html>
    <html lang="ru">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Отчет по анализу товаров Wildberries</title>
        <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                margin: 0;
                padding: 20px;
                background-color: #f5f5f5;
            }
            .container {
                max-width: 1400px;
                margin: 0 auto;
                background-color: white;
                padding: 30px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            }
            h1 {
                color: #1f77b4;
                border-bottom: 3px solid #1f77b4;
                padding-bottom: 10px;
            }
            h2 {
                color: #2c3e50;
                margin-top: 30px;
                border-left: 4px solid #3498db;
                padding-left: 15px;
            }
            .stats-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 20px;
                margin: 20px 0;
            }
            .stat-card {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 20px;
                border-radius: 10px;
                text-align: center;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            }
            .stat-card h3 {
                margin: 0 0 10px 0;
                font-size: 14px;
                opacity: 0.9;
            }
            .stat-card .value {
                font-size: 28px;
                font-weight: bold;
            }
            .chart-container {
                margin: 30px 0;
                background: white;
                padding: 20px;
                border-radius: 10px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            }
            table {
                width: 100%;
                border-collapse: collapse;
                margin: 20px 0;
            }
            th, td {
                padding: 12px;
                text-align: left;
                border-bottom: 1px solid #ddd;
            }
            th {
                background-color: #3498db;
                color: white;
            }
            tr:hover {
                background-color: #f5f5f5;
            }
            .info-box {
                background-color: #e8f4f8;
                border-left: 4px solid #3498db;
                padding: 15px;
                margin: 20px 0;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>📊 Отчет по анализу товаров Wildberries</h1>
    """)
    
    # Информация о периоде анализа
    if analysis_period:
        period_str = analysis_period.get('period_str', 'N/A')
        html_parts.append(f"""
            <div class="info-box">
                <strong>📅 Период анализа:</strong> {period_str}<br>
                <strong>📄 Дата создания отчета:</strong> {datetime.now().strftime("%d.%m.%Y %H:%M:%S")}
            </div>
        """)
    
    # Статистика
    html_parts.append("<h2>📈 Общая статистика</h2>")
    html_parts.append("<div class='stats-grid'>")
    
    stats = []
    if "Выручка" in filtered_df.columns:
        total_revenue = filtered_df["Выручка"].sum()
        stats.append(("Общая выручка", f"{total_revenue:,.0f} ₽"))
    
    if "Заказы" in filtered_df.columns:
        total_orders = filtered_df["Заказы"].sum()
        stats.append(("Общие заказы", f"{total_orders:,.0f} шт"))
    
    stats.append(("Всего товаров", f"{len(filtered_df):,}"))
    
    if "Средняя цена" in filtered_df.columns:
        avg_price = filtered_df["Средняя цена"].mean()
        stats.append(("Средняя цена", f"{avg_price:,.0f} ₽"))
    
    if "Выручка" in filtered_df.columns:
        avg_revenue = filtered_df["Выручка"].mean()
        stats.append(("Средняя выручка", f"{avg_revenue:,.0f} ₽"))
    
    if "Прибыль" in filtered_df.columns:
        total_profit = filtered_df["Прибыль"].sum()
        stats.append(("Общая прибыль", f"{total_profit:,.0f} ₽"))
    
    for stat_name, stat_value in stats:
        html_parts.append(f"""
            <div class="stat-card">
                <h3>{stat_name}</h3>
                <div class="value">{stat_value}</div>
            </div>
        """)
    
    html_parts.append("</div>")
    
    # Графики
    html_parts.append("<h2>📊 Графики</h2>")
    
    # График 1: Топ-20 товаров по выручке
    if "Выручка" in filtered_df.columns and "Артикул" in filtered_df.columns:
        top_20 = filtered_df.nlargest(20, "Выручка")
        fig = px.bar(
            top_20,
            x="Артикул",
            y="Выручка",
            title="Топ-20 товаров по выручке",
            labels={"Выручка": "Выручка, ₽", "Артикул": "Артикул"}
        )
        fig.update_layout(height=500, showlegend=False)
        fig.update_xaxes(tickangle=-45)
        chart_html = pio.to_html(fig, div_id=f"chart_{len(html_parts)}", include_plotlyjs=False)
        html_parts.append(f'<div class="chart-container">{chart_html}</div>')
    
    # График 2: Распределение выручки
    if "Выручка" in filtered_df.columns:
        fig = px.histogram(
            filtered_df,
            x="Выручка",
            nbins=30,
            title="Распределение выручки по товарам",
            labels={"Выручка": "Выручка, ₽", "count": "Количество товаров"}
        )
        fig.update_layout(height=400, showlegend=False)
        chart_html = pio.to_html(fig, div_id=f"chart_{len(html_parts)}", include_plotlyjs=False)
        html_parts.append(f'<div class="chart-container">{chart_html}</div>')
    
    # График 3: Заказы vs Выручка
    if "Заказы" in filtered_df.columns and "Выручка" in filtered_df.columns:
        fig = px.scatter(
            filtered_df,
            x="Заказы",
            y="Выручка",
            size="Выручка",
            title="Зависимость выручки от количества заказов",
            labels={"Заказы": "Количество заказов", "Выручка": "Выручка, ₽"}
        )
        fig.update_layout(height=500, showlegend=False)
        chart_html = pio.to_html(fig, div_id=f"chart_{len(html_parts)}", include_plotlyjs=False)
        html_parts.append(f'<div class="chart-container">{chart_html}</div>')
    
    # График 4: Топ-10 по заказам
    if "Заказы" in filtered_df.columns and "Артикул" in filtered_df.columns:
        top_10_orders = filtered_df.nlargest(10, "Заказы")
        fig = px.bar(
            top_10_orders,
            x="Артикул",
            y="Заказы",
            title="Топ-10 товаров по количеству заказов",
            labels={"Заказы": "Заказы, шт", "Артикул": "Артикул"}
        )
        fig.update_layout(height=400, showlegend=False)
        fig.update_xaxes(tickangle=-45)
        chart_html = pio.to_html(fig, div_id=f"chart_{len(html_parts)}", include_plotlyjs=False)
        html_parts.append(f'<div class="chart-container">{chart_html}</div>')
    
    # График 5: Динамика по датам (если есть)
    if "Дата создания" in filtered_df.columns and "Выручка" in filtered_df.columns:
        try:
            daily_data = filtered_df.groupby(filtered_df["Дата создания"].dt.date).agg({
                "Выручка": "sum",
                "Заказы": "sum" if "Заказы" in filtered_df.columns else "count"
            }).reset_index()
            daily_data = daily_data.sort_values("Дата создания")
            
            fig = go.Figure()
            fig.add_trace(go.Scatter(
                x=daily_data["Дата создания"],
                y=daily_data["Выручка"],
                mode='lines+markers',
                name='Выручка',
                line=dict(color='#1f77b4', width=2)
            ))
            if "Заказы" in daily_data.columns:
                fig.add_trace(go.Scatter(
                    x=daily_data["Дата создания"],
                    y=daily_data["Заказы"] * 100,  # Масштабируем для визуализации
                    mode='lines+markers',
                    name='Заказы (x100)',
                    yaxis='y2',
                    line=dict(color='#ff7f0e', width=2)
                ))
                fig.update_layout(
                    yaxis2=dict(title="Заказы (x100)", overlaying='y', side='right')
                )
            
            fig.update_layout(
                title="Динамика выручки и заказов по датам",
                xaxis_title="Дата",
                yaxis_title="Выручка, ₽",
                height=500,
                hovermode='x unified'
            )
            chart_html = pio.to_html(fig, div_id=f"chart_{len(html_parts)}", include_plotlyjs=False)
            html_parts.append(f'<div class="chart-container">{chart_html}</div>')
        except Exception as e:
            pass  # Пропускаем график, если есть ошибка
    
    # Таблица с данными (топ-50)
    html_parts.append("<h2>📋 Данные (Топ-50 товаров)</h2>")
    
    # Подготавливаем данные для таблицы
    export_df = filtered_df.head(50).copy()
    
    # Убираем столбцы, которые не нужны в HTML
    columns_to_remove = ["Изображение"]
    for col in columns_to_remove:
        if col in export_df.columns:
            export_df = export_df.drop(columns=[col])
    
    # Форматируем числовые значения
    if "Выручка" in export_df.columns:
        export_df["Выручка"] = export_df["Выручка"].apply(lambda x: f"{x:,.0f} ₽" if pd.notna(x) else "")
    if "Средняя цена" in export_df.columns:
        export_df["Средняя цена"] = export_df["Средняя цена"].apply(lambda x: f"{x:,.0f} ₽" if pd.notna(x) else "")
    if "Заказы" in export_df.columns:
        export_df["Заказы"] = export_df["Заказы"].apply(lambda x: f"{x:,.0f}" if pd.notna(x) else "")
    
    # Создаем HTML таблицу
    html_parts.append('<table>')
    html_parts.append('<thead><tr>')
    for col in export_df.columns:
        html_parts.append(f'<th>{col}</th>')
    html_parts.append('</tr></thead>')
    html_parts.append('<tbody>')
    
    for _, row in export_df.iterrows():
        html_parts.append('<tr>')
        for col in export_df.columns:
            value = row[col]
            if pd.isna(value):
                value = ""
            html_parts.append(f'<td>{value}</td>')
        html_parts.append('</tr>')
    
    html_parts.append('</tbody></table>')
    
    # Закрытие HTML
    html_parts.append("""
        </div>
    </body>
    </html>
    """)
    
    return "\n".join(html_parts)

def load_param_values_from_file():
    """
    Загружает параметры ТОЛЬКО для текущего проекта/файла.
    НЕ объединяет параметры из всех файлов, чтобы не смешивать проекты.
    """
    import glob
    
    # ВАЖНО: deleted_params берутся ТОЛЬКО из session_state текущего проекта
    deleted_params = st.session_state.get("deleted_params", set())
    if not isinstance(deleted_params, set):
        deleted_params = set(deleted_params) if deleted_params else set()
        st.session_state["deleted_params"] = deleted_params
    
    all_param_values = {}
    all_param_options = {}
    
    # КРИТИЧЕСКИ ВАЖНО: Загружаем параметры ТОЛЬКО для текущего файла/проекта
    # НЕ загружаем из всех файлов, чтобы не смешивать проекты!
    current_file = st.session_state.get("cached_file_name", None)
    
    # Если есть текущий файл, загружаем параметры только для него
    if current_file:
        try:
            registry_file = "file_params_registry.json"
            if os.path.exists(registry_file):
                with open(registry_file, "r", encoding="utf-8") as f:
                    registry = json.load(f)
                
                if current_file in registry:
                    param_file = registry[current_file]["param_file"]
                    if os.path.exists(param_file):
                        with open(param_file, "r", encoding="utf-8") as f:
                            param_data = json.load(f)
                            file_params = param_data.get("param_values", {}) if isinstance(param_data, dict) else {}
                            file_options = param_data.get("param_options", {}) if isinstance(param_data, dict) else {}
                            
                            # Загружаем deleted_params из файла проекта, если они там есть
                            file_deleted_params = param_data.get("deleted_params", [])
                            if file_deleted_params:
                                # Объединяем с существующими deleted_params
                                if not isinstance(deleted_params, set):
                                    deleted_params = set(deleted_params) if deleted_params else set()
                                deleted_params.update(file_deleted_params)
                                st.session_state["deleted_params"] = deleted_params
                            
                            # Загружаем параметры только из файла текущего проекта
                            for param_name, sku_values in file_params.items():
                                # Пропускаем удаленные параметры
                                if param_name in deleted_params:
                                    continue
                                    
                                if param_name and isinstance(sku_values, dict):
                                    if param_name not in all_param_values:
                                        all_param_values[param_name] = {}
                                    all_param_values[param_name].update(sku_values)
                                    
                                    # Загружаем варианты из file_options
                                    if param_name in file_options and isinstance(file_options[param_name], list):
                                        all_param_options[param_name] = list(file_options[param_name])
                                    else:
                                        if param_name not in all_param_options:
                                            all_param_options[param_name] = []
                                        for value in sku_values.values():
                                            if value and str(value) not in all_param_options[param_name]:
                                                all_param_options[param_name].append(str(value))
        except Exception:
            pass
    else:
        # Если нет текущего файла, загружаем из всех файлов (для обратной совместимости)
        # Но это должно происходить только если проект не загружен
        if not st.session_state.get("current_project_id", None):
            # Загружаем параметры из всех файлов param_values_*.json (только для обратной совместимости)
            param_files = glob.glob("param_values*.json")
            
            for param_file in param_files:
                try:
                    with open(param_file, "r", encoding="utf-8") as f:
                        param_data = json.load(f)
                        
                    # Поддерживаем оба формата: новый (с file_name) и старый (прямой словарь)
                    if isinstance(param_data, dict) and "param_values" in param_data:
                        # Новый формат
                        file_params = param_data.get("param_values", {})
                        file_options = param_data.get("param_options", {})
                    else:
                        # Старый формат
                        file_params = param_data if isinstance(param_data, dict) else {}
                        file_options = {}
                    
                    # Объединяем параметры из всех файлов (пропускаем удаленные)
                    for param_name, sku_values in file_params.items():
                        # Пропускаем удаленные параметры
                        if param_name in deleted_params:
                            continue
                            
                        if param_name and isinstance(sku_values, dict):
                            if param_name not in all_param_values:
                                all_param_values[param_name] = {}
                            all_param_values[param_name].update(sku_values)
                            
                            # Загружаем варианты из file_options если есть
                            if param_name in file_options and isinstance(file_options[param_name], list):
                                if param_name not in all_param_options:
                                    all_param_options[param_name] = []
                                for option in file_options[param_name]:
                                    if option and str(option) not in all_param_options[param_name]:
                                        all_param_options[param_name].append(str(option))
                            else:
                                if param_name not in all_param_options:
                                    all_param_options[param_name] = []
                                for value in sku_values.values():
                                    if value and str(value) not in all_param_options[param_name]:
                                        all_param_options[param_name].append(str(value))
                except Exception as e:
                    continue
    
            # Также проверяем глобальный файл (только если проект не загружен)
    if os.path.exists("param_values_global.json"):
        try:
            with open("param_values_global.json", "r", encoding="utf-8") as f:
                global_data = json.load(f)
                if isinstance(global_data, dict) and "param_values" in global_data:
                    global_params = global_data.get("param_values", {})
                    global_options = global_data.get("param_options", {})
                else:
                    global_params = global_data if isinstance(global_data, dict) else {}
                    global_options = {}
                
                if isinstance(global_params, dict):
                    for param_name, sku_values in global_params.items():
                        if param_name in deleted_params:
                            continue
                        if param_name and isinstance(sku_values, dict):
                            if param_name not in all_param_values:
                                all_param_values[param_name] = {}
                            all_param_values[param_name].update(sku_values)
                            
                            if param_name in global_options and isinstance(global_options[param_name], list):
                                if param_name not in all_param_options:
                                    all_param_options[param_name] = []
                                for option in global_options[param_name]:
                                    if option and str(option) not in all_param_options[param_name]:
                                        all_param_options[param_name].append(str(option))
                            else:
                                if param_name not in all_param_options:
                                    all_param_options[param_name] = []
                                for value in sku_values.values():
                                    if value and str(value) not in all_param_options[param_name]:
                                        all_param_options[param_name].append(str(value))
        except Exception:
            pass
    
    # Убеждаемся, что deleted_params установлены (уже должны быть в session_state)
    # deleted_params уже могли быть загружены из файла проекта выше
    if "deleted_params" not in st.session_state:
        # Если проект не загружается, загружаем из файла для обратной совместимости
        if not st.session_state.get("project_loading", False):
            st.session_state["deleted_params"] = load_deleted_params_from_file()
        else:
            st.session_state["deleted_params"] = set()
    
    # Обновляем deleted_params для фильтрации
    deleted_params = st.session_state.get("deleted_params", set())
    if not isinstance(deleted_params, set):
        deleted_params = set(deleted_params) if deleted_params else set()
        st.session_state["deleted_params"] = deleted_params
    
    # Устанавливаем объединенные параметры
    if all_param_values or all_param_options:
        if all_param_values:
            st.session_state["param_values"] = all_param_values
        if all_param_options:
            # Объединяем с существующими param_options если есть
            # НО исключаем удаленные параметры
            existing_options = st.session_state.get("param_options", {})
            for param_name, options in all_param_options.items():
                # Пропускаем удаленные параметры
                if param_name in deleted_params:
                    continue
                if param_name not in existing_options:
                    existing_options[param_name] = options
                else:
                    # Объединяем варианты, сохраняя порядок из файла
                    combined = list(existing_options[param_name])
                    for option in options:
                        if option and str(option) not in combined:
                            combined.append(str(option))
                    existing_options[param_name] = combined
            st.session_state["param_options"] = existing_options
        # Создаем param_options из значений только если их еще нет в файлах
        # Но сначала удаляем удаленные параметры из param_values в session_state
        if deleted_params and "param_values" in st.session_state:
            params_to_remove = [p for p in st.session_state["param_values"].keys() if p in deleted_params]
            for param_name in params_to_remove:
                del st.session_state["param_values"][param_name]
        
        if not all_param_options:
            create_param_options_from_values()
        return True
    else:
        st.session_state["param_values"] = {}
        st.session_state["param_options"] = {}
        return False
                
def create_param_options_from_values():
    """Создает param_options на основе загруженных данных"""
    if "param_options" not in st.session_state:
        st.session_state["param_options"] = {}
    
    # Получаем список удаленных параметров
    deleted_params = st.session_state.get("deleted_params", load_deleted_params_from_file())
    if deleted_params:
        st.session_state["deleted_params"] = deleted_params
        # Убеждаемся, что это set
        if not isinstance(deleted_params, set):
            deleted_params = set(deleted_params)
            st.session_state["deleted_params"] = deleted_params
    
    # Получаем param_values через функцию, которая фильтрует удаленные параметры
    param_values = get_param_values()
    
    # Дополнительная проверка - удаляем удаленные параметры еще раз на всякий случай
    if deleted_params:
        params_to_remove = [p for p in param_values.keys() if p in deleted_params]
        for param_name in params_to_remove:
            if param_name in param_values:
                del param_values[param_name]
        if params_to_remove:
            st.session_state["param_values"] = param_values
    for param_name, param_data in param_values.items():
        # Пропускаем невалидные параметры (артикулы и т.д.)
        if not is_valid_param_name(param_name):
            continue
        
        # Пропускаем удаленные параметры
        if param_name in deleted_params:
            continue
        
        # Собираем все уникальные значения для каждого параметра
        unique_values = list(set([v for v in param_data.values() if v and v.strip()]))
        if unique_values:
            # Если параметр уже есть в param_options, объединяем значения
            if param_name in st.session_state["param_options"]:
                existing_values = st.session_state["param_options"][param_name]
                combined_values = list(set(existing_values + unique_values))
                st.session_state["param_options"][param_name] = sorted(combined_values)
            else:
                st.session_state["param_options"][param_name] = sorted(unique_values)
        elif param_name == "Крой":
            # Для параметра "Крой" добавляем стандартные варианты, если нет данных
            st.session_state["param_options"][param_name] = ["Классический", "Приталенный", "Свободный", "Оверсайз"]
        else:
            # Если параметр есть в param_values, но нет вариантов, добавляем его в param_options с пустым списком
            if param_name not in st.session_state["param_options"]:
                st.session_state["param_options"][param_name] = []

def save_main_page_data_to_file():
    """Сохраняет данные главной страницы в файл, привязанные к текущему файлу"""
    current_file = st.session_state.get("cached_file_name", None)
    
    try:
        main_page_data = {
            "search": st.session_state.get("search", ""),
            "spp": st.session_state.get("spp", 25),
            "buyout_pct": st.session_state.get("buyout_pct", 25),
            "revenue_min": st.session_state.get("revenue_min", 0),
            "revenue_max": st.session_state.get("revenue_max", 1000000),
            "price_min": st.session_state.get("price_min", 0),
            "price_max": st.session_state.get("price_max", 10000),
            "show_images": st.session_state.get("show_images", False),
            "sort_column": st.session_state.get("sort_column", "Выручка"),
            "sort_descending": st.session_state.get("sort_descending", True)
        }
        
        if current_file:
            # Сохраняем настройки для конкретного файла
            file_hash = hash(current_file) % 1000000
            settings_file = f"main_page_settings_{file_hash}.json"
            
            settings_data = {
                "file_name": current_file,
                "settings": main_page_data,
                "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S")
            }
            
            with open(settings_file, "w", encoding="utf-8") as f:
                json.dump(settings_data, f, ensure_ascii=False, indent=2)
            
            # Обновляем реестр настроек файлов
            update_file_settings_registry(current_file, settings_file)
        else:
            # Fallback для случаев, когда нет текущего файла
            with open("main_page_data_global.json", "w", encoding="utf-8") as f:
                json.dump(main_page_data, f, ensure_ascii=False, indent=2)
        
        return True
    except Exception as e:
        st.error(f"Ошибка сохранения настроек: {e}")
        return False

def update_file_settings_registry(file_name, settings_file):
    """Обновляет реестр файлов и их настроек"""
    try:
        registry_file = "file_settings_registry.json"
        registry = {}
        
        if os.path.exists(registry_file):
            with open(registry_file, "r", encoding="utf-8") as f:
                registry = json.load(f)
        
        registry[file_name] = {
            "settings_file": settings_file,
            "last_updated": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        
        with open(registry_file, "w", encoding="utf-8") as f:
            json.dump(registry, f, ensure_ascii=False, indent=2)
            
    except Exception as e:
        st.error(f"Ошибка обновления реестра настроек: {e}")

def load_main_page_data_from_file():
    """Загружает данные главной страницы из файла, привязанные к текущему файлу"""
    current_file = st.session_state.get("cached_file_name", None)
    
    if current_file:
        try:
            # Пытаемся загрузить настройки для текущего файла
            registry_file = "file_settings_registry.json"
            if os.path.exists(registry_file):
                with open(registry_file, "r", encoding="utf-8") as f:
                    registry = json.load(f)
                
                if current_file in registry:
                    settings_file = registry[current_file]["settings_file"]
                    if os.path.exists(settings_file):
                        with open(settings_file, "r", encoding="utf-8") as f:
                            settings_data = json.load(f)
                            data = settings_data.get("settings", {})
                            
                            # Загружаем данные в session_state
                            st.session_state["search"] = data.get("search", "")
                            st.session_state["spp"] = data.get("spp", 25)
                            st.session_state["buyout_pct"] = data.get("buyout_pct", 25)
                            st.session_state["revenue_min"] = data.get("revenue_min", 0)
                            st.session_state["revenue_max"] = data.get("revenue_max", 1000000)
                            st.session_state["price_min"] = data.get("price_min", 0)
                            st.session_state["price_max"] = data.get("price_max", 10000)
                            st.session_state["show_images"] = data.get("show_images", False)
                            st.session_state["sort_column"] = data.get("sort_column", "Выручка")
                            st.session_state["sort_descending"] = data.get("sort_descending", True)
                            return True
            
            # Если настройки для файла не найдены, инициализируем значения по умолчанию
            st.session_state["search"] = ""
            st.session_state["spp"] = 25
            st.session_state["buyout_pct"] = 25
            st.session_state["revenue_min"] = 0
            st.session_state["revenue_max"] = 1000000
            st.session_state["price_min"] = 0
            st.session_state["price_max"] = 10000
            st.session_state["show_images"] = False
            st.session_state["sort_column"] = "Выручка"
            st.session_state["sort_descending"] = True
            return True
            
        except Exception as e:
            st.error(f"Ошибка загрузки настроек: {e}")
            return False
    else:
        # Fallback для случаев, когда нет текущего файла
        try:
            if os.path.exists("main_page_data_global.json"):
                with open("main_page_data_global.json", "r", encoding="utf-8") as f:
                    data = json.load(f)
                    
                    # Загружаем данные в session_state
                    st.session_state["search"] = data.get("search", "")
                    st.session_state["spp"] = data.get("spp", 25)
                    st.session_state["buyout_pct"] = data.get("buyout_pct", 25)
                    st.session_state["revenue_min"] = data.get("revenue_min", 0)
                    st.session_state["revenue_max"] = data.get("revenue_max", 1000000)
                    st.session_state["price_min"] = data.get("price_min", 0)
                    st.session_state["price_max"] = data.get("price_max", 10000)
                    st.session_state["show_images"] = data.get("show_images", False)
                    st.session_state["sort_column"] = data.get("sort_column", "Выручка")
                    st.session_state["sort_descending"] = data.get("sort_descending", True)
                    return True
        except Exception:
            pass
    return False

# ВАЖНО: НЕ загружаем deleted_params из глобального файла при старте!
# Удаленные параметры должны быть изолированы для каждого проекта.
# Они загружаются только при загрузке проекта через load_full_project().
# Инициализируем deleted_params пустым set, если его нет
if "deleted_params" not in st.session_state:
    st.session_state["deleted_params"] = set()

# ВАЖНО: НЕ очищаем все файлы при старте!
# Это нарушает изоляцию проектов. Очистка должна происходить только
# для файла текущего проекта при удалении параметра.
# Удаляем удаленные параметры только из session_state текущего проекта
if "files_cleaned_on_startup" not in st.session_state:
    deleted_params = st.session_state.get("deleted_params", set())
    if deleted_params:
        # Удаляем удаленные параметры только из session_state текущего проекта
        # НЕ очищаем файлы других проектов!
        if "param_values" in st.session_state:
            for param_name in list(st.session_state["param_values"].keys()):
                if param_name in deleted_params:
                    del st.session_state["param_values"][param_name]
        if "param_options" in st.session_state:
            for param_name in list(st.session_state["param_options"].keys()):
                if param_name in deleted_params:
                    del st.session_state["param_options"][param_name]
    st.session_state["files_cleaned_on_startup"] = True

# Загружаем параметры ТОЛЬКО после очистки файлов
if "param_values" not in st.session_state:
    load_param_values_from_file()
    load_param_history_from_file()
    
    # После загрузки еще раз удаляем удаленные параметры из session_state
    deleted_params = st.session_state.get("deleted_params", set())
    if deleted_params:
        if "param_values" in st.session_state:
            for param_name in list(st.session_state["param_values"].keys()):
                if param_name in deleted_params:
                    del st.session_state["param_values"][param_name]
        if "param_options" in st.session_state:
            for param_name in list(st.session_state["param_options"].keys()):
                if param_name in deleted_params:
                    del st.session_state["param_options"][param_name]

# КРИТИЧЕСКИ ВАЖНО: ВСЕГДА фильтруем удаленные параметры при каждом rerun
# Это последняя линия защиты от восстановления удаленных параметров
# ВАЖНО: Используем ТОЛЬКО deleted_params из session_state текущего проекта,
# НЕ загружаем из глобального файла, чтобы не нарушать изоляцию проектов
if "deleted_params" in st.session_state:
    # Используем только deleted_params из session_state текущего проекта
    current_deleted_params = st.session_state.get("deleted_params", set())
    if not isinstance(current_deleted_params, set):
        deleted_params = set(current_deleted_params) if current_deleted_params else set()
    else:
        deleted_params = current_deleted_params
    
    # Убеждаемся, что это set
    if not isinstance(deleted_params, set):
        deleted_params = set(deleted_params) if deleted_params else set()
    
    # Обновляем session_state
    st.session_state["deleted_params"] = deleted_params
else:
    # ВАЖНО: НЕ загружаем из глобального файла! Используем только deleted_params из session_state текущего проекта
    deleted_params = st.session_state.get("deleted_params", set())
    if not isinstance(deleted_params, set):
        deleted_params = set(deleted_params) if deleted_params else set()
    st.session_state["deleted_params"] = deleted_params

# Удаляем удаленные параметры из всех мест в session_state
if deleted_params:
    # Удаляем из param_values
    if "param_values" in st.session_state:
        params_to_remove = [p for p in st.session_state["param_values"].keys() if p in deleted_params]
        for param_name in params_to_remove:
            del st.session_state["param_values"][param_name]
    
    # Удаляем из param_options
    if "param_options" in st.session_state:
        params_to_remove = [p for p in st.session_state["param_options"].keys() if p in deleted_params]
        for param_name in params_to_remove:
            del st.session_state["param_options"][param_name]

# Автоматическая загрузка настроек исключения параметров при запуске
if "excluded_params_loaded" not in st.session_state:
    load_excluded_params_settings()
    st.session_state["excluded_params_loaded"] = True

# Автоматическая загрузка результатов массового анализа при запуске
# Инициализируем пустым списком, если еще не загружено
if "mass_analysis_results" not in st.session_state:
    st.session_state["mass_analysis_results"] = []

# Загружаем результаты из файлов при каждом запуске (если еще не загружены)
if not st.session_state.get("mass_analysis_results", []):
    # Сначала пытаемся загрузить из сохраненных результатов
    saved_results = load_mass_analysis_results()
    if saved_results:
        st.session_state["mass_analysis_results"] = saved_results
    else:
        # Если нет сохраненных результатов, пытаемся загрузить из прогресса
        saved_progress = load_mass_analysis_progress()
        if saved_progress and saved_progress.get("results"):
            st.session_state["mass_analysis_results"] = saved_progress["results"]
            # Сохраняем результаты в отдельный файл для постоянного хранения
            save_mass_analysis_results(saved_progress["results"])

# Автоматическая загрузка данных главной страницы при запуске приложения
if "main_page_data_loaded" not in st.session_state:
    load_main_page_data_from_file()
    st.session_state["main_page_data_loaded"] = True

def get_url_cache():
    """Обёртка для совместимости"""
    return get_url_cache_with_state(st.session_state)

def get_cached_images_for_sku(sku: str, max_images: int = 3) -> list:
    """
    Получает пути к кешированным изображениям товара по артикулу.
    Использует уже скачанные изображения из кеша.
    
    Args:
        sku: Артикул товара
        max_images: Максимальное количество изображений (по умолчанию 3)
        
    Returns:
        Список путей к изображениям
    """
    images = []
    sku_clean = str(sku).replace(".0", "")
    
    # Проверяем основное изображение (обычно это первое фото товара)
    main_image = get_cached_image_path(sku_clean)
    if main_image and os.path.exists(main_image):
        images.append(main_image)
    
    # Если нужно больше изображений, можно искать дополнительные
    # (например, с суффиксами _1, _2 и т.д.)
    if len(images) < max_images:
        cache_dir = os.path.join(_cache_dir(), "imgs")
        if os.path.exists(cache_dir):
            # Ищем дополнительные изображения с суффиксами
            for suffix in range(1, max_images):
                for ext in ("jpg", "png", "jpeg", "webp", "JPG", "PNG", "JPEG", "WEBP"):
                    additional_path = os.path.join(cache_dir, f"{sku_clean}_{suffix}.{ext}")
                    if os.path.exists(additional_path) and additional_path not in images:
                        images.append(additional_path)
                        break
    
    return images[:max_images]

def analyze_image_with_ai(image_path_or_url: str, api_key: str = None, selected_params: list = None, product_name: str = None, sku: str = None) -> dict:
    """
    Анализирует изображение товара через нейросеть (OpenAI Vision API).
    Обёртка для analyze_image_with_ai_core, которая получает данные из session_state.
    Работает как с локальными файлами, так и с URL.
    
    Args:
        image_path_or_url: Путь к локальному файлу изображения или URL
        api_key: API ключ OpenAI (если None, берется из secrets.toml или session_state)
        selected_params: Список параметров для анализа
        product_name: Название товара (если доступно)
        sku: Артикул товара (для получения названия, если product_name не указан)
        
    Returns:
        Словарь с определенными параметрами
    """
    if not OPENAI_AVAILABLE:
        return {}
    
    # Получаем API ключ
    if not api_key:
        try:
            api_key = st.secrets.get('openai_api_key', '')
        except:
            pass
        
        if not api_key:
            api_key = st.session_state.get('openai_api_key')
    
    if not api_key:
        return {}
    
    # Получаем данные из session_state
    param_options = st.session_state.get("param_options", {})
    hierarchy_params = get_hierarchy_params()
    subtype_params = get_subtype_params()
    visual_params = get_visual_params()
    debug_mode = st.session_state.get('debug_ai_analysis', False)
    
    try:
        # Вызываем core-функцию
        result = analyze_image_with_ai_core(
            image_path_or_url=image_path_or_url,
            api_key=api_key,
            param_options=param_options,
            hierarchy_params=hierarchy_params,
            subtype_params=subtype_params,
            visual_params=visual_params,
            selected_params=selected_params,
            product_name=product_name,
            sku=sku,
            debug_mode=debug_mode
        )
        
        # Показываем предупреждения
        if result.get("_warning"):
            st.warning(result["_warning"])
        
        # Показываем debug-информацию
        if debug_mode and result.get("_debug_response"):
            with st.expander("🔍 Отладочная информация (ответ API)", expanded=False):
                st.code(result["_debug_response"])
        
        return result.get("params", {})
        
    except Exception as e:
        # Логируем ошибку для отладки
        error_msg = str(e)
        error_type = type(e).__name__
        
        # Проверяем тип ошибки и показываем соответствующее сообщение
        if "api_key" in error_msg.lower() or "authentication" in error_msg.lower() or "401" in error_msg:
            st.error(f"❌ Ошибка аутентификации: Проверьте правильность API ключа OpenAI")
        elif "rate limit" in error_msg.lower() or "quota" in error_msg.lower() or "429" in error_msg:
            st.error(f"❌ Превышен лимит запросов к API. Попробуйте позже.")
        elif "invalid" in error_msg.lower() and ("image" in error_msg.lower() or "format" in error_msg.lower()):
            st.error(f"❌ Не удалось обработать изображение. Проверьте формат файла.")
        elif "timeout" in error_msg.lower() or "APITimeoutError" in error_type:
            st.error(f"❌ Превышено время ожидания ответа от API. Попробуйте позже.")
        elif "connection" in error_msg.lower() or "network" in error_msg.lower():
            st.error(f"❌ Ошибка подключения к API. Проверьте интернет-соединение.")
        else:
            # Для отладки показываем краткую информацию об ошибке
            st.warning(f"⚠️ Ошибка при анализе изображения: {error_type}")
            # В режиме отладки можно показать полную ошибку
            if debug_mode:
                st.error(f"Детали ошибки: {error_msg[:200]}")
        
        return {}

def analyze_image_for_params(image_url: str) -> dict:
    """
    Анализирует изображение товара и определяет параметры (цвет, стиль и т.д.).
    Использует нейросеть для анализа (не скачивает изображение).
    
    Args:
        image_url: URL изображения товара
        
    Returns:
        Словарь с определенными параметрами
    """
    # Используем нейросеть для анализа
    return analyze_image_with_ai(image_url)

# get_product_image_urls_from_wb_api теперь импортируется из utils.wb_api_images

def get_screenshotapi_image_urls(sku: str, token: str = None, max_images: int = 5) -> list:
    """
    Генерирует URL-ы для получения изображений товара через screenshotapi.net.
    
    Args:
        sku: Артикул товара
        token: API токен screenshotapi.net (если None, берется из session_state или secrets)
        max_images: Максимальное количество изображений (по умолчанию 5)
        
    Returns:
        Список URL-ов изображений
    """
    image_urls = []
    
    try:
        # Получаем токен если не передан
        if not token:
            try:
                token = st.secrets.get('screenshotapi_token', '')
            except:
                pass
            
            if not token:
                token = st.session_state.get('screenshotapi_token', '')
        
        if not token:
            # Если токена нет, возвращаем пустой список
            return []
        
        # Формируем URL страницы товара
        product_url = build_wb_product_url(sku, host="https://global.wildberries.ru")
        encoded_url = _urlparse.quote(product_url, safe="")
        
        # Базовый URL для screenshotapi.net
        base_url = "https://shot.screenshotapi.net/v3/screenshot"
        
        # Первое изображение - основное (из главного слайдера)
        # Увеличиваем timeout и добавляем больше времени на загрузку
        first_image_url = (
            f"{base_url}?token={token}"
            f"&fresh=true"
            f"&url={encoded_url}"
            f"&width=1370"
            f"&height=544"
            f"&output=image"
            f"&file_type=png"
            f"&wait_for_event=load"
            f"&wait_for=2000"
            f"&selector_to_click=.mainSlider--JxK8z%20img"
        )
        image_urls.append(first_image_url)
        
        # Остальные 4 изображения - из вертикального слайдера
        for i in range(2, min(6, max_images + 1)):  # nth-child от 2 до 5
            additional_image_url = (
                f"{base_url}?token={token}"
                f"&fresh=true"
                f"&url={encoded_url}"
                f"&output=image"
                f"&file_type=png"
                f"&wait_for_event=load"
                f"&selector_to_click=.swiper-vertical%20.swiper-slide%3Anth-child({i})%20img"
            )
            image_urls.append(additional_image_url)
        
    except Exception as e:
        # В случае ошибки возвращаем пустой список
        pass
    
    return image_urls[:max_images]

def has_downloaded_images(sku: str, min_images: int = 1) -> bool:
    """
    Проверяет, есть ли у товара скачанные изображения через screenshotapi.
    
    Args:
        sku: Артикул товара
        min_images: Минимальное количество изображений для считания, что фото есть (по умолчанию 1)
        
    Returns:
        True, если есть хотя бы min_images скачанных изображений
    """
    try:
        sku_clean = str(sku).replace(".0", "")
        cached_count = 0
        
        # Проверяем наличие изображений в кеше (формат: {sku}_screenshotapi_{index})
        for idx in range(5):  # Проверяем до 5 изображений
            cache_key = f"{sku_clean}_screenshotapi_{idx}"
            cached_path = get_cached_image_path(cache_key)
            if cached_path and os.path.exists(cached_path):
                cached_count += 1
                if cached_count >= min_images:
                    return True
        
        return False
    except Exception:
        return False

def get_screenshotapi_images_with_status(sku: str, token: str = None, max_images: int = 5) -> list:
    """
    Получает изображения товара через screenshotapi.net с информацией о статусе (в кеше или скачивается).
    
    Args:
        sku: Артикул товара
        token: API токен screenshotapi.net (если None, берется из session_state или secrets)
        max_images: Максимальное количество изображений (по умолчанию 5)
        
    Returns:
        Список словарей с информацией о каждом изображении:
        [{"index": 1, "path": "...", "status": "cached"|"downloading"|"downloaded"|"error", "url": "..."}, ...]
    """
    images_info = []
    
    try:
        # Получаем URL изображений
        image_urls = get_screenshotapi_image_urls(sku, token=token, max_images=max_images)
        
        if not image_urls:
            return []
        
        # Проверяем каждое изображение
        for idx, img_url in enumerate(image_urls):
            cache_key = f"{sku}_screenshotapi_{idx}"
            
            # Проверяем, есть ли изображение в кеше
            cached_path = get_cached_image_path(cache_key)
            if cached_path and os.path.exists(cached_path):
                images_info.append({
                    "index": idx + 1,
                    "path": cached_path,
                    "status": "cached",
                    "url": img_url
                })
            else:
                # Изображение нужно скачать
                images_info.append({
                    "index": idx + 1,
                    "path": None,
                    "status": "downloading",
                    "url": img_url,
                    "cache_key": cache_key
                })
        
    except Exception as e:
        pass
    
    return images_info

@st.cache_data(ttl=3600)  # Кэш на 1 час
def load_report_from_tovar_folder_cached(filepath: str) -> pd.DataFrame:
    """Обёртка с кешированием для load_report_from_tovar_folder"""
    return load_report_from_tovar_folder(filepath)

def find_reports_with_missing(skus: tuple, tovar_folder: str = "Tovar") -> tuple:
    """
    Безопасно получает отчеты и причины отсутствия, даже если старая версия функции без return_missing.
    """
    # Перезагружаем модуль, чтобы применялись последние правки парсера
    import utils.reports as reports_module
    reports_module = importlib.reload(reports_module)
    try:
        return reports_module.find_and_load_reports_from_tovar(skus, tovar_folder, return_missing=True)
    except TypeError:
        # Фоллбек для старой сигнатуры
        reports = reports_module.find_and_load_reports_from_tovar(skus, tovar_folder)
        missing = {}
        skus_str = [str(sku).replace(".0", "") for sku in skus]
        if not os.path.exists(tovar_folder):
            for sku in skus_str:
                missing[sku] = "Папка Tovar не найдена"
            return reports, missing
        files = os.listdir(tovar_folder)
        for sku in skus_str:
            filename = None
            for candidate in files:
                file_sku = extract_sku_from_filename(candidate)
                if file_sku == sku:
                    filename = candidate
                    break
            if not filename:
                missing[sku] = "Отчет не найден в папке Tovar"
                continue
            filepath = os.path.join(tovar_folder, filename)
            report_data = reports_module.load_report_from_tovar_folder(filepath)
            if report_data is None:
                last_error = reports_module.get_last_report_load_error() if hasattr(reports_module, "get_last_report_load_error") else None
                if last_error:
                    missing[sku] = f"Не удалось прочитать файл: {filename} ({last_error})"
                else:
                    missing[sku] = f"Не удалось прочитать файл: {filename}"
            elif report_data.empty:
                missing[sku] = f"Файл пустой или без данных: {filename}"
        return reports, missing


def enrich_missing_reports(missing_reports: dict, skus: list, tovar_folder: str = "Tovar") -> dict:
    """
    Уточняет причины ошибок чтения, если они слишком общие.
    """
    if not missing_reports:
        return missing_reports
    if not os.path.exists(tovar_folder):
        return missing_reports

    import utils.reports as reports_module
    reports_module = importlib.reload(reports_module)
    files = os.listdir(tovar_folder)
    sku_to_file = {}
    for filename in files:
        file_sku = extract_sku_from_filename(filename)
        if file_sku:
            sku_to_file[file_sku] = filename

    enriched = dict(missing_reports)
    for sku in skus:
        sku_str = str(sku).replace(".0", "")
        reason = enriched.get(sku_str)
        if not reason:
            continue
        if "Не удалось прочитать файл" in reason and "(" not in reason:
            filename = sku_to_file.get(sku_str)
            if not filename:
                continue
            filepath = os.path.join(tovar_folder, filename)
            report_data = reports_module.load_report_from_tovar_folder(filepath)
            if report_data is not None and not report_data.empty:
                # Парсер уже исправился — убираем из списка проблемных
                enriched.pop(sku_str, None)
                continue
            last_error = reports_module.get_last_report_load_error() if hasattr(reports_module, "get_last_report_load_error") else None
            if last_error:
                enriched[sku_str] = f"Не удалось прочитать файл: {filename} ({last_error})"
                continue
            # Фоллбек: пытаемся открыть файл напрямую, чтобы получить исключение
            try:
                _ = pd.read_excel(filepath)
                # Если файл читается, но парсер вернул None, значит проблема в структуре данных
                try:
                    raw_df = pd.read_excel(filepath, header=None)
                    header_idx = None
                    keywords = ['дата', 'артикул', 'заказ', 'продаж', 'выручк', 'средн']
                    for i in range(min(len(raw_df), 60)):
                        row_values = raw_df.iloc[i].astype(str).str.strip().str.lower()
                        if not any(('дата' in val or val == 'date') for val in row_values):
                            continue
                        hits = 0
                        for val in row_values:
                            for kw in keywords:
                                if kw in val:
                                    hits += 1
                                    break
                        if hits >= 2:
                            header_idx = i
                            break
                    if header_idx is not None:
                        cols = [str(c) for c in list(raw_df.iloc[header_idx])[:12]]
                        enriched[sku_str] = (
                            f"Не удалось прочитать файл: {filename} "
                            f"(заголовок на строке {header_idx + 1}, колонки: {', '.join(cols)})"
                        )
                    else:
                        enriched[sku_str] = f"Не удалось прочитать файл: {filename} (не найден заголовок с датой)"
                except Exception:
                    enriched[sku_str] = f"Не удалось прочитать файл: {filename} (неожиданный формат данных)"
            except Exception as e:
                err_msg = str(e).strip()
                if err_msg:
                    enriched[sku_str] = f"Не удалось прочитать файл: {filename} ({type(e).__name__}: {err_msg})"
                else:
                    enriched[sku_str] = f"Не удалось прочитать файл: {filename} ({type(e).__name__})"
    return enriched

# find_and_load_reports_from_tovar теперь импортируется из utils.reports

def analyze_combination_products_with_ai(combo_products_df, combination_key: str, category: str = "Рашрашд мужской (компрессионная одежда)") -> dict:
    """
    Анализирует товары в комбинации с помощью ИИ для получения рекомендаций по улучшению.
    Обёртка для analyze_combination_products_with_ai_core, которая получает API ключ из session_state.
    
    Args:
        combo_products_df: DataFrame с товарами комбинации
        combination_key: Ключ комбинации (параметры)
        category: Категория товаров (по умолчанию "Рашрашд мужской (компрессионная одежда)")
        
    Returns:
        Словарь с анализом и рекомендациями
    """
    if not OPENAI_AVAILABLE:
        return {
            "error": "OpenAI не доступен. Установите библиотеку openai для использования этой функции."
        }
    
    # Получаем API ключ
    api_key = st.session_state.get('openai_api_key', '')
    if not api_key:
        try:
            api_key = st.secrets.get('openai_api_key', '')
        except:
            pass
    
    if not api_key:
        return {
            "error": "API ключ OpenAI не найден. Укажите ключ в настройках."
        }
    
    return analyze_combination_products_with_ai_core(
        combo_products_df=combo_products_df,
        combination_key=combination_key,
        category=category,
        api_key=api_key
    )

def get_category_cagr_analysis(category: str = "Рашрашд мужской (компрессионная одежда)") -> dict:
    """
    Возвращает информацию о CAGR (Compound Annual Growth Rate) для категории.
    
    Args:
        category: Категория товаров
        
    Returns:
        Словарь с информацией о CAGR и анализом рынка
    """
    # Данные о CAGR для компрессионной одежды (примерные значения на основе рыночных данных)
    cagr_data = {
        "Рашрашд мужской (компрессионная одежда)": {
            "cagr_5_years": 8.5,  # Примерный CAGR за 5 лет
            "market_size_2024": "2.5 млрд руб",  # Размер рынка в 2024
            "projected_growth_2025": 9.2,  # Прогнозируемый рост в 2025
            "key_drivers": [
                "Рост популярности фитнеса и здорового образа жизни",
                "Увеличение спроса на функциональную одежду",
                "Развитие e-commerce и онлайн-продаж",
                "Расширение ассортимента и улучшение качества продукции"
            ],
            "trends": [
                "Фокус на экологичных материалах",
                "Технологичные ткани с улучшенными свойствами",
                "Персонализация и кастомизация",
                "Интеграция умных технологий"
            ],
            "competition_level": "Высокий",
            "market_maturity": "Растущий рынок"
        }
    }
    
    # Если категория не найдена, возвращаем общие данные
    if category not in cagr_data:
        return {
            "cagr_5_years": 7.0,
            "market_size_2024": "N/A",
            "projected_growth_2025": 7.5,
            "key_drivers": ["Общие рыночные факторы"],
            "trends": ["Общие тренды рынка"],
            "competition_level": "Средний",
            "market_maturity": "Стабильный"
        }
    
    return cagr_data[category]

# read_wgsn_files теперь импортируется из utils.wgsn_reader

def analyze_wgsn_trends_with_ai(wgsn_content: dict, category: str = "Рашрашд мужской (компрессионная одежда)", combination_key: str = "") -> dict:
    """
    Анализирует содержимое файлов WGSN с помощью ИИ для получения трендов и рекомендаций.
    Обёртка для analyze_wgsn_trends_with_ai_core, которая получает API ключ из session_state.
    
    Args:
        wgsn_content: Словарь с содержимым файлов WGSN
        category: Категория товаров
        combination_key: Ключ комбинации параметров
        
    Returns:
        Словарь с анализом трендов WGSN
    """
    if not OPENAI_AVAILABLE:
        return {
            "error": "OpenAI не доступен. Установите библиотеку openai для использования этой функции."
        }
    
    if "error" in wgsn_content:
        return wgsn_content
    
    # Получаем API ключ
    api_key = st.session_state.get('openai_api_key', '')
    if not api_key:
        try:
            api_key = st.secrets.get('openai_api_key', '')
        except:
            pass
    
    if not api_key:
        return {
            "error": "API ключ OpenAI не найден. Укажите ключ в настройках."
        }
    
    return analyze_wgsn_trends_with_ai_core(
        wgsn_content=wgsn_content,
        category=category,
        combination_key=combination_key,
        api_key=api_key
    )

def get_product_params_from_images(url: str, api_key: str = None, max_images: int = 5, selected_params: list = None) -> dict:
    """
    Определяет параметры товара по фотографиям через нейросеть.
    Использует screenshotapi.net для получения изображений товара.
    Оптимизировано для использования кешированных изображений - не скачивает повторно уже имеющиеся.
    
    Args:
        url: URL товара Wildberries
        api_key: API ключ OpenAI (если None, берется из session_state)
        max_images: Максимальное количество изображений для анализа (по умолчанию 5)
        selected_params: Список параметров для анализа (если None, анализируются все)
        
    Returns:
        Словарь с определенными параметрами
    """
    sku = extract_sku_from_url(url)
    if not sku:
        return {}
    
    all_params = {}
    
    try:
        import time
        
        # Получаем API ключ если не передан
        if not api_key:
            api_key = st.session_state.get('openai_api_key', '')
        
        if not api_key:
            return {}
        
        # Сначала проверяем, какие изображения уже есть в кеше
        sku_clean = str(sku).replace(".0", "")
        cached_images = []
        images_to_download = []  # Список индексов изображений, которые нужно скачать
        
        # Проверяем наличие изображений в кеше
        for idx in range(max_images):
            cache_key = f"{sku_clean}_screenshotapi_{idx}"
            cached_path = get_cached_image_path(cache_key)
            
            if cached_path and os.path.exists(cached_path):
                # Изображение уже в кеше - используем его
                cached_images.append((idx, cached_path))
            else:
                # Изображение нужно скачать
                images_to_download.append(idx)
        
        # Если все изображения уже в кеше, используем их без дополнительных запросов
        if not images_to_download:
            # Все изображения в кеше - используем их
            image_paths = [path for _, path in sorted(cached_images)]
        else:
            # Нужно скачать некоторые изображения
            # Получаем URL изображений через screenshotapi.net только для недостающих
            image_urls = get_screenshotapi_image_urls(sku, max_images=max_images)
            
            if not image_urls:
                # Если не удалось получить URL, используем только кешированные
                image_paths = [path for _, path in sorted(cached_images)]
            else:
                # Скачиваем только недостающие изображения
                image_paths = [None] * max_images
                
                # Заполняем пути для уже кешированных изображений
                for idx, path in cached_images:
                    image_paths[idx] = path
                
                # Скачиваем недостающие изображения
                for idx in images_to_download:
                    if idx < len(image_urls):
                        cache_key = f"{sku_clean}_screenshotapi_{idx}"
                        img_url = image_urls[idx]
                        
                        # Скачиваем изображение (ensure_image_cached проверит кеш внутри себя)
                        cached_path = ensure_image_cached(cache_key, img_url, "PNG", timeout=30)
                        if cached_path and os.path.exists(cached_path):
                            image_paths[idx] = cached_path
                        
                        # Задержка между запросами только для новых скачиваний
                        if idx < len(images_to_download) - 1:  # Не делаем задержку после последнего
                            time.sleep(0.5)  # 500ms задержка между запросами
                
                # Убираем None значения
                image_paths = [path for path in image_paths if path is not None]
        
        if not image_paths:
            return {}
        
        # Анализируем каждое изображение через нейросеть
        image_params_list = []
        for img_path in image_paths:
            img_params = analyze_image_with_ai(img_path, api_key, selected_params=selected_params)
            if img_params:
                image_params_list.append(img_params)
        
        # Объединяем результаты всех изображений
        if image_params_list:
            # Для каждого параметра берем наиболее частый
            param_keys = set()
            for img_params in image_params_list:
                param_keys.update(img_params.keys())
            
            for key in param_keys:
                values = [p.get(key) for p in image_params_list if p.get(key)]
                if values:
                    value_counts = Counter(values)
                    all_params[key] = value_counts.most_common(1)[0][0]
        
    except Exception as e:
        pass
    
    return all_params

def determine_completeness(sku: str) -> str:
    """
    Определяет, является ли товар комплектом или одной вещью.
    Анализирует характеристики и описание товара через API Wildberries.
    
    Args:
        sku: Артикул товара
        
    Returns:
        "Комплект" или "Один"
    """
    try:
        api_url = f"https://card.wb.ru/cards/v1/detail?appType=1&curr=rub&dest=-1257786&spp=30&nm={sku}"
        
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'application/json',
        }
        
        response = requests.get(api_url, headers=headers, timeout=10)
        
        if response.status_code == 200:
            data = response.json()
            
            if 'data' in data and 'products' in data['data'] and len(data['data']['products']) > 0:
                product = data['data']['products'][0]
                
                # Собираем текст для анализа
                text_to_analyze = []
                
                # Получаем название товара
                if 'name' in product:
                    text_to_analyze.append(product['name'].lower())
                
                # Получаем описание
                if 'description' in product:
                    text_to_analyze.append(product['description'].lower())
                
                # Получаем характеристики
                if 'characteristics' in product:
                    for char in product['characteristics']:
                        if 'name' in char and 'value' in char:
                            text_to_analyze.append(f"{char['name']} {char['value']}".lower())
                
                # Объединяем весь текст
                full_text = " ".join(text_to_analyze)
                
                # Ключевые слова, указывающие на комплект
                kit_keywords = [
                    'комплект', 'набор', 'set', 'комплектация', 'в комплекте',
                    '2 шт', '3 шт', '4 шт', '5 шт', '6 шт', '7 шт', '8 шт', '9 шт', '10 шт',
                    'две', 'три', 'четыре', 'пять', 'шесть', 'семь', 'восемь', 'девять', 'десять',
                    'пара', 'пары', 'шт.', 'штук', 'штуки',
                    'включает', 'состоит из', 'содержит', 'в наборе',
                    'комплект из', 'набор из', 'комплектация из'
                ]
                
                # Проверяем наличие ключевых слов
                for keyword in kit_keywords:
                    if keyword in full_text:
                        return "Комплект"
                
                # Дополнительная проверка: ищем числа перед словами "шт", "штук", "предмет"
                import re
                quantity_patterns = [
                    r'\d+\s*(шт|штук|предмет|вещь|изделие)',
                    r'(две|три|четыре|пять|шесть|семь|восемь|девять|десять)\s*(шт|штук|предмет|вещь)',
                ]
                
                for pattern in quantity_patterns:
                    if re.search(pattern, full_text):
                        return "Комплект"
                
    except Exception as e:
        # В случае ошибки возвращаем "Один" по умолчанию
        pass
    
    # По умолчанию считаем, что это одна вещь
    return "Один"

def get_product_params_from_url(url: str) -> dict:
    """
    Пытается получить параметры товара по ссылке на Wildberries.
    
    ВАЖНО: Wildberries не предоставляет публичного API для получения параметров товара.
    Эта функция может работать только если:
    1. Используется официальный API Wildberries (требует токен)
    2. Используется парсинг HTML (может нарушать ToS Wildberries)
    
    Args:
        url: URL товара Wildberries
        
    Returns:
        Словарь с параметрами товара или пустой словарь
    """
    sku = extract_sku_from_url(url)
    if not sku:
        return {}
    
    params = {}
    
    try:
        # Попытка получить данные через API Wildberries (если доступен)
        # Для этого нужен токен API, который обычно хранится в secrets.toml
        api_url = f"https://card.wb.ru/cards/v1/detail?appType=1&curr=rub&dest=-1257786&spp=30&nm={sku}"
        
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'application/json',
        }
        
        response = requests.get(api_url, headers=headers, timeout=10)
        
        if response.status_code == 200:
            data = response.json()
            
            # Извлекаем параметры из ответа API
            if 'data' in data and 'products' in data['data'] and len(data['data']['products']) > 0:
                product = data['data']['products'][0]
                
                # Извлекаем характеристики товара
                if 'characteristics' in product:
                    for char in product['characteristics']:
                        if 'name' in char and 'value' in char:
                            param_name = char['name'].strip()
                            param_value = char['value'].strip()
                            if param_name and param_value:
                                params[param_name] = param_value
                
                # Извлекаем дополнительные данные
                if 'brand' in product:
                    params['Бренд'] = product['brand']
                if 'name' in product:
                    params['Название'] = product['name']
                if 'colors' in product and product['colors']:
                    params['Цвет'] = ', '.join([c.get('name', '') for c in product['colors'] if c.get('name')])
                
    except Exception as e:
        # Если API недоступен или произошла ошибка, возвращаем пустой словарь
        pass
    
    return params

def build_screenshot_url(page_url: str, key: str,
                         w: int = 400, h: int = 600,
                         fmt: str = "JPEG", profile: str = "D4",
                         base: str = "https://api.s-shot.ru"):
    q = _urlparse.quote(page_url, safe="")
    return f"{base.rstrip('/')}/{int(w)}x{int(h)}/{fmt}/{key}/{profile}/?{q}"
def screenshot_for_article(nm, conf):
    if not conf.get("key"):
        return ""
    page = build_wb_product_url(nm, conf.get("wb_host", "https://global.wildberries.ru"))
    return build_screenshot_url(
        page, conf.get("key", ""), conf.get("w", 400), conf.get("h", 600),
        conf.get("fmt", "JPEG"), conf.get("profile", "D4"), conf.get("base", "https://api.s-shot.ru")
    )

@st.cache_data(show_spinner=False)
def read_table(file_bytes: bytes, filename: str):
    """Обёртка для read_table из utils.data_processing"""
    return read_table_base(file_bytes, filename, error_callback=st.error)

def get_param_schemas():
    if "param_schemas" not in st.session_state:
        st.session_state["param_schemas"] = {}
    return st.session_state["param_schemas"]
def get_param_values():
    """Получает param_values из session_state, исключая удаленные параметры текущего проекта"""
    if "param_values" not in st.session_state:
        st.session_state["param_values"] = {}
    
    param_values = st.session_state["param_values"]
    
    # ВАЖНО: deleted_params берутся ТОЛЬКО из session_state текущего проекта,
    # а не из глобального файла. Это обеспечивает изоляцию между проектами.
    deleted_params = st.session_state.get("deleted_params", set())
    
    # Если deleted_params не установлены, инициализируем пустым set
    if not isinstance(deleted_params, set):
        deleted_params = set(deleted_params) if deleted_params else set()
        st.session_state["deleted_params"] = deleted_params
    
    # Фильтруем удаленные параметры
    if deleted_params:
        param_values = {k: v for k, v in param_values.items() if k not in deleted_params}
    
    return param_values

def kpi_row(df):
    total_rev = float(df["Выручка"].sum()) if "Выручка" in df.columns else float('nan')
    total_orders = df["Заказы"].sum() if "Заказы" in df.columns else np.nan
    avg_check = (df["Выручка"].sum() / df["Заказы"].sum()) if ("Выручка" in df.columns and "Заказы" in df.columns and df["Заказы"].sum() > 0) else np.nan
    lost_rev = df["Упущенная выручка"].sum() if "Упущенная выручка" in df.columns else np.nan
    sku_count = (df["Артикул"].nunique() if "Артикул" in df.columns else len(df)) if len(df) > 0 else 0
    rev_per_sku = (total_rev / sku_count) if (isinstance(total_rev, (int,float,np.floating)) and not pd.isna(total_rev) and sku_count > 0) else np.nan
    k1, k2, k3, k4, k5, k6 = st.columns(6)
    k1.metric("Выручка (в выборке)", fmt_rub_kpi(total_rev))
    k2.metric("Заказы (в выборке)", fmt_units_kpi(total_orders, "шт."))
    k3.metric("Средний чек", fmt_rub_kpi(avg_check))
    k4.metric("Упущенная выручка", fmt_rub_kpi(lost_rev))
    k5.metric("Выручка / Кол-во товаров", fmt_rub_kpi(rev_per_sku))
    k6.metric("Количество артикулов", fmt_units_kpi(sku_count, "шт."))

# Параметры уже загружены выше при инициализации

# Автоматическая загрузка конфигурации иерархии параметров
if "hierarchy_params" not in st.session_state:
    load_hierarchy_config()

# Автоматическая загрузка OpenAI API ключа из secrets.toml при запуске
if "openai_api_key" not in st.session_state:
    try:
        default_key = st.secrets.get('openai_api_key', '')
        if default_key:
            st.session_state['openai_api_key'] = default_key
    except:
        pass

# Автоматическая загрузка ScreenshotAPI токена из secrets.toml при запуске
if "screenshotapi_token" not in st.session_state:
    try:
        default_token = st.secrets.get('screenshotapi_token', '')
        if default_token:
            st.session_state['screenshotapi_token'] = default_token
        else:
            # Устанавливаем токен по умолчанию
            st.session_state['screenshotapi_token'] = 'MDA94V3-4C14RXS-KSE2KMK-T08BD9M'
    except:
        # Устанавливаем токен по умолчанию
        st.session_state['screenshotapi_token'] = 'MDA94V3-4C14RXS-KSE2KMK-T08BD9M'

# Автоматическая загрузка последней таблицы параметров при запуске
# ВАЖНО: НЕ загружаем из table_cache.json, если был загружен проект!
# Параметры должны загружаться только из файла проекта через load_param_values_from_file()
if "table_loaded" not in st.session_state:
    try:
        import json
        import os
        
        # Проверяем, был ли загружен проект (проверяем file_cache_meta.json)
        project_was_loaded = False
        if os.path.exists("file_cache_meta.json"):
            try:
                with open("file_cache_meta.json", "r", encoding="utf-8") as f:
                    meta_data = json.load(f)
                    project_id = meta_data.get("project_id")
                    project_name = meta_data.get("project_name")
                    
                    if project_id:
                        # Проект был загружен - восстанавливаем информацию о проекте
                        st.session_state["current_project_id"] = project_id
                        st.session_state["current_project_name"] = project_name
                        project_was_loaded = True
                        
                        # Восстанавливаем cached_file_name если есть
                        cached_file_name = meta_data.get("filename")
                        if cached_file_name:
                            st.session_state["cached_file_name"] = cached_file_name
                            # Проверяем, существует ли файл в кеше
                            cache_path = os.path.join("file_cache", cached_file_name)
                            if os.path.exists(cache_path):
                                with open(cache_path, "rb") as f:
                                    st.session_state["cached_file_data"] = f.read()
            except Exception:
                pass
        
        # Если проект был загружен, НЕ загружаем из table_cache.json!
        # Параметры будут загружены через load_param_values_from_file() из файла проекта
        if not project_was_loaded and os.path.exists("table_cache.json"):
            # Только если проект НЕ был загружен, загружаем из table_cache.json (для обратной совместимости)
            deleted_params = st.session_state.get("deleted_params", set())
            if not isinstance(deleted_params, set):
                deleted_params = set(deleted_params) if deleted_params else set()
                st.session_state["deleted_params"] = deleted_params
            
            with open("table_cache.json", "r", encoding="utf-8") as f:
                table_cache_data = json.load(f)
            
            # Восстанавливаем данные
            param_values_raw = table_cache_data.get("param_values", {})
            param_options_raw = table_cache_data.get("param_options", {})
            
            # Фильтруем невалидные и удаленные параметры
            if not isinstance(deleted_params, set):
                deleted_params = set(deleted_params) if deleted_params else set()
            
            st.session_state["param_values"] = {
                k: v for k, v in param_values_raw.items() 
                if is_valid_param_name(k) and k not in deleted_params
            }
            st.session_state["param_options"] = {
                k: v for k, v in param_options_raw.items() 
                if is_valid_param_name(k) and k not in deleted_params
            }
            
            # Дополнительная проверка - удаляем удаленные параметры еще раз
            if deleted_params:
                for param_name in list(st.session_state["param_values"].keys()):
                    if param_name in deleted_params:
                        del st.session_state["param_values"][param_name]
                for param_name in list(st.session_state["param_options"].keys()):
                    if param_name in deleted_params:
                        del st.session_state["param_options"][param_name]
            st.session_state["param_ratings"] = table_cache_data.get("param_ratings", {})
            st.session_state["deleted_params"] = deleted_params
            
            # Показываем уведомление о загрузке
            st.sidebar.success(f"📂 Автозагрузка: таблица параметров восстановлена")
        elif project_was_loaded:
            # Если проект был загружен, параметры загрузятся через load_param_values_from_file()
            # которая загрузит их из файла проекта
            pass
        
        # Отмечаем, что таблица загружена
        st.session_state["table_loaded"] = True
    except Exception as e:
        st.session_state["table_loaded"] = True  # Отмечаем, что попытка загрузки была

# Автоматическая загрузка последнего файла при запуске
# ВАЖНО: Если проект был загружен, параметры загружаются из проекта, а не из кеша
if "file_auto_loaded" not in st.session_state:
    try:
        import json
        import os
        
        # Проверяем наличие кешированного файла
        if os.path.exists("file_cache_meta.json"):
            with open("file_cache_meta.json", "r", encoding="utf-8") as f:
                meta_data = json.load(f)
            
            filename = meta_data.get("filename")
            project_id = meta_data.get("project_id")
            project_name = meta_data.get("project_name")
            cache_path = os.path.join("file_cache", filename) if filename else None
            
            # Если проект был загружен, восстанавливаем информацию о проекте
            if project_id:
                st.session_state["current_project_id"] = project_id
                st.session_state["current_project_name"] = project_name
                if filename:
                    st.session_state["cached_file_name"] = filename
                    if cache_path and os.path.exists(cache_path):
                        with open(cache_path, "rb") as f:
                            st.session_state["cached_file_data"] = f.read()
                
                # Загружаем параметры проекта из файла параметров
                # НЕ устанавливаем auto_load_file, чтобы не перезаписать параметры проекта
                load_param_values_from_file()
                load_main_page_data_from_file()
                
                st.sidebar.success(f"📂 Проект восстановлен: **{project_name}**")
            elif cache_path and os.path.exists(cache_path):
                # Если проекта нет, но есть кешированный файл - устанавливаем флаг для автозагрузки
                st.session_state["auto_load_file"] = True
                st.sidebar.info(f"📂 Найден кешированный файл: {filename}")
            
                st.session_state["file_auto_loaded"] = True
        else:
            st.session_state["file_auto_loaded"] = True
    except Exception as e:
        st.session_state["file_auto_loaded"] = True  # Отмечаем, что попытка загрузки была

# Инициализация session_state
if "schemas" not in st.session_state:
    st.session_state["schemas"] = {}

# Функции для работы с кешем файлов

# get_analysis_period теперь импортируется из utils.data_processing
# get_file_statistics теперь импортируется из utils.data_processing

# --- UI (урезанный пример, ключевые места с прибыль и миниатюрами) ---
with st.sidebar.expander("Загрузка файла", expanded=True):
    # Получаем список всех кешированных файлов
    cached_files = get_all_cached_files()
    
    if cached_files:
        st.write("**📂 Кешированные файлы:**")
        
        # Показываем последний использованный файл
        current_file_info = get_file_cache_info()
        if current_file_info:
            st.info(f"🔄 Текущий: {current_file_info['filename']}\n🕒 {current_file_info['timestamp']}")
        
        # Список всех файлов
        for i, file_info in enumerate(cached_files[:5]):  # Показываем только 5 последних
            col_file, col_load, col_del = st.columns([3, 1, 1])
            
            with col_file:
                file_size_mb = file_info["size"] / (1024 * 1024)
                st.caption(f"📄 {file_info['filename']}\n💾 {file_size_mb:.1f} MB • {file_info['timestamp']}")
            
            with col_load:
                if st.button("📂", key=f"load_{i}"):
                    # Загружаем выбранный файл
                    try:
                        with open(file_info["path"], "rb") as f:
                            file_data = f.read()
                        
                        # Обновляем метаданные
                        meta_data = {
                            "filename": file_info["filename"],
                            "timestamp": file_info["timestamp"],
                            "size": file_info["size"],
                            "last_used": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S")
                        }
                        
                        with open("file_cache_meta.json", "w", encoding="utf-8") as f:
                            json.dump(meta_data, f, ensure_ascii=False, indent=2)
                        
                        # Сохраняем в session_state
                        st.session_state["cached_file_data"] = file_data
                        st.session_state["cached_file_name"] = file_info["filename"]
                        st.session_state["file_loaded_from_cache"] = True
                        st.session_state["load_from_cache"] = True
                        
                        # Загружаем параметры и настройки для нового файла
                        load_param_values_from_file()
                        load_main_page_data_from_file()
                        st.rerun()
                    except Exception as e:
                        st.error(f"❌ Ошибка загрузки: {e}")
            
            with col_del:
                if st.button("🗑️", key=f"del_{i}"):
                    try:
                        import os
                        os.remove(file_info["path"])
                        st.success(f"✅ Файл {file_info['filename']} удален из кеша")
                        st.rerun()
                    except Exception as e:
                        st.error(f"❌ Ошибка удаления: {e}")
        
        # Кнопка очистки всего кеша
        if st.button("🗑️ Очистить весь кеш файлов", type="secondary"):
            try:
                import os
                import shutil
                
                # Удаляем все файлы кеша
                cache_dir = "file_cache"
                if os.path.exists(cache_dir):
                    shutil.rmtree(cache_dir)
                
                # Удаляем метаданные
                if os.path.exists("file_cache_meta.json"):
                    os.remove("file_cache_meta.json")
                
                # Очищаем session_state
                if "cached_file_data" in st.session_state:
                    del st.session_state["cached_file_data"]
                if "cached_file_name" in st.session_state:
                    del st.session_state["cached_file_name"]
                if "file_loaded_from_cache" in st.session_state:
                    del st.session_state["file_loaded_from_cache"]
                
                st.success("✅ Весь кеш файлов очищен!")
                st.rerun()
            except Exception as e:
                st.error(f"❌ Ошибка очистки кеша: {e}")
    else:
        st.info("📂 Кеш файлов пуст")
    
    # Кнопка для сброса текущего файла (если файл загружен)
    if st.session_state.get("file_loaded_from_cache", False):
        if st.button("🔄 Загрузить новый файл", type="secondary"):
            # Очищаем session_state
            if "cached_file_data" in st.session_state:
                del st.session_state["cached_file_data"]
            if "cached_file_name" in st.session_state:
                del st.session_state["cached_file_name"]

# --- Сохранение и загрузка проектов ---
with st.sidebar.expander("💾 Проекты", expanded=True):
    st.markdown("### 💾 Управление проектами")
    
    # Информация о текущем проекте
    current_file_name = st.session_state.get("cached_file_name", "Не загружен")
    current_project_name = st.session_state.get("current_project_name", None)
    
    if current_file_name != "Не загружен":
        st.success(f"📄 **Файл:** {current_file_name}")
    else:
        st.warning("⚠️ Файл данных не загружен")
    
    if current_project_name:
        st.info(f"📁 **Проект:** {current_project_name}")
    
    st.divider()
    
    # Сохранение проекта
    st.markdown("#### 📤 Сохранить проект")
    project_name = st.text_input(
        "Название проекта:",
        value=current_project_name or f"Проект_{pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')}",
        key="sidebar_project_name_input",
        help="Введите название проекта для сохранения"
    )
    
    if st.button("💾 Сохранить проект", type="primary", use_container_width=True, key="sidebar_save_project_btn"):
        with st.spinner("Сохраняю проект..."):
            project_json, saved_name, project_id = save_full_project(project_name)
            if project_json:
                file_size_mb = len(project_json.encode('utf-8')) / (1024 * 1024)
                st.success(f"✅ Проект '{saved_name}' готов!")
                st.download_button(
                    label=f"⬇️ Скачать ({file_size_mb:.2f} MB)",
                    data=project_json,
                    file_name=f"{saved_name}.json",
                    mime="application/json",
                    use_container_width=True,
                    key="sidebar_download_project_btn"
                )
                st.caption(f"🆔 ID: `{project_id}`")
            else:
                st.error("❌ Ошибка сохранения проекта")
    
    st.divider()
    
    # Загрузка проекта
    st.markdown("#### 📥 Загрузить проект")
    uploaded_project = st.file_uploader(
        "Выберите файл проекта:",
        type=["json"],
        key="sidebar_import_project_file",
        help="Загрузите сохраненный проект (.json)"
    )
    
    if uploaded_project:
        try:
            project_json = uploaded_project.read().decode('utf-8')
            project_data = json.loads(project_json)
            
            project_name_loaded = project_data.get("project_name", "Неизвестный проект")
            export_date = project_data.get("export_date", "Неизвестно")
            project_id = project_data.get("project_id", "N/A")
            cached_file_name = project_data.get("cached_file_name", None)
            file_size = project_data.get("file_size", 0)
            
            st.success(f"✅ **{project_name_loaded}**")
            st.caption(f"📅 {export_date} | ID: `{project_id}`")
            
            # Информация о проекте
            with st.expander("📋 Информация о проекте", expanded=False):
                if "param_options" in project_data:
                    st.metric("Параметров", len(project_data['param_options']))
                if "hierarchy_params" in project_data:
                    st.metric("Иерархических", len(project_data['hierarchy_params']))
                if cached_file_name:
                    st.metric("Файл данных", cached_file_name)
                    if file_size > 0:
                        st.caption(f"Размер: {file_size / 1024 / 1024:.2f} MB")
            
            st.warning("⚠️ Текущие параметры будут заменены!")
            
            if st.button("📥 Загрузить проект", type="primary", use_container_width=True, key="sidebar_load_project_btn"):
                with st.spinner("Загружаю проект..."):
                    success, loaded_name = load_full_project(project_json)
                    if success:
                        st.success(f"✅ Проект '{loaded_name}' загружен!")
                        st.info("🔄 Перезагрузите страницу для применения изменений.")
                        import time
                        time.sleep(2)
                        st.rerun()
                    else:
                        st.error("❌ Ошибка загрузки проекта")
                        
        except Exception as e:
            st.error(f"❌ Ошибка: {e}")
    
    st.divider()
    
    # Статистика текущего проекта
    st.markdown("#### 📊 Статистика")
    param_values = get_param_values()
    param_options = st.session_state.get("param_options", {})
    param_count = len(param_options) if param_options else 0
    values_count = sum(len(v) for v in param_values.values()) if param_values else 0
    
    col_stat1, col_stat2 = st.columns(2)
    with col_stat1:
        st.metric("Параметров", param_count)
    with col_stat2:
        st.metric("Значений", values_count)
    
    hierarchy_count = len(st.session_state.get('hierarchy_params', []))
    excluded_count = len(st.session_state.get('excluded_params', []))
    
    if hierarchy_count > 0:
        st.caption(f"🔗 Иерархических: {hierarchy_count}")
    if excluded_count > 0:
        st.caption(f"👁️ Скрытых: {excluded_count}")

# --- Загрузка нового файла (продолжение сайдбара) ---
with st.sidebar.expander("📤 Загрузить новый файл", expanded=False):
    uploaded_sidebar = st.file_uploader(
        "Excel/CSV с товарами", type=["xlsx", "xls", "csv"], key="main_uploader"
    )
    
    # Секция для загрузки товаров по ссылкам Wildberries
    st.markdown("---")
    with st.expander("🔗 Загрузка товаров по ссылкам Wildberries", expanded=False):
        st.info("💡 **Альтернативный способ:** Загрузите товары по ссылкам Wildberries. Система автоматически получит изображения и определит параметры через нейросеть OpenAI.")
        
        urls_input = st.text_area(
            "Введите ссылки на товары Wildberries (по одной на строку):",
            height=150,
            help="Каждая ссылка должна быть на отдельной строке.\nПример:\nhttps://www.wildberries.ru/catalog/12345678/detail.aspx\nhttps://global.wildberries.ru/catalog/87654321/detail.aspx",
            key="wb_urls_input"
        )
        
        # Настройки для загрузки по ссылкам
        col_delay1, col_delay2 = st.columns(2)
        with col_delay1:
            wb_rate_limit_delay = st.slider(
                "Задержка между запросами к WB (сек):",
                min_value=0.5,
                max_value=5.0,
                value=1.0,
                step=0.1,
                help="Помогает избежать rate limit при парсинге Wildberries",
                key="wb_delay_slider"
            )
        with col_delay2:
            max_images_per_url = st.slider(
                "Изображений на товар:",
                min_value=1,
                max_value=5,
                value=5,
                help="Количество изображений для анализа (рекомендуется 5)",
                key="max_images_url_slider"
            )
        
        if st.button("📥 Загрузить товары по ссылкам", type="primary", key="load_urls_btn"):
            if urls_input:
                urls = [url.strip() for url in urls_input.split('\n') if url.strip()]
                
                if urls:
                    progress_bar = st.progress(0)
                    status_text = st.empty()
                    
                    results = []
                    api_key = st.session_state.get('openai_api_key', '')
                    
                    if not api_key:
                        st.error("❌ Необходимо указать API ключ OpenAI в настройках (вкладка '⚙️ Установка параметров')")
                    else:
                        total_urls = len(urls)
                        success_count = 0
                        error_count = 0
                        
                        for idx, url in enumerate(urls):
                            status_text.text(f"Обработка товара {idx + 1}/{total_urls}: {url[:60]}...")
                            
                            # Извлекаем артикул
                            sku = extract_sku_from_url(url)
                            if not sku:
                                results.append({
                                    "URL": url,
                                    "Артикул": "Не найден",
                                    "Статус": "❌ Ошибка извлечения артикула"
                                })
                                error_count += 1
                                # Ограничиваем значение progress до максимум 1.0
                                progress_value = min((idx + 1) / total_urls, 1.0)
                                progress_bar.progress(progress_value)
                                continue
                            
                            # Получаем параметры через анализ изображений
                            try:
                                params = get_product_params_from_images(url, api_key, max_images=max_images_per_url)
                                
                                if params:
                                    result_row = {
                                        "URL": url,
                                        "Артикул": sku,
                                        "Статус": "✅ Успешно",
                                        **params
                                    }
                                    results.append(result_row)
                                    success_count += 1
                                    
                                    # Сохраняем параметры в session_state
                                    if "param_values" not in st.session_state:
                                        st.session_state["param_values"] = {}
                                    
                                    for param_name, param_value in params.items():
                                        if param_name not in st.session_state["param_values"]:
                                            st.session_state["param_values"][param_name] = {}
                                        st.session_state["param_values"][param_name][sku] = param_value
                                    
                                else:
                                    results.append({
                                        "URL": url,
                                        "Артикул": sku,
                                        "Статус": "⚠️ Параметры не определены"
                                    })
                                    error_count += 1
                            except Exception as e:
                                results.append({
                                    "URL": url,
                                    "Артикул": sku,
                                    "Статус": f"❌ Ошибка: {str(e)[:50]}"
                                })
                                error_count += 1
                            
                            # Обновляем прогресс
                            progress_bar.progress((idx + 1) / total_urls)
                            
                            # Задержка между товарами для избежания rate limit
                            import time
                            if idx < total_urls - 1:  # Не ждем после последнего товара
                                time.sleep(wb_rate_limit_delay)
                        
                        # Очищаем прогресс
                        progress_bar.empty()
                        status_text.empty()
                        
                        # Сохраняем результаты
                        if results:
                            results_df = pd.DataFrame(results)
                            st.session_state['url_loaded_products'] = results_df
                            
                            # Показываем статистику
                            st.success(f"✅ Обработка завершена!")
                            st.info(f"📊 **Статистика:** Успешно: {success_count} | Ошибок: {error_count} | Всего: {total_urls}")
                            
                            # Показываем результаты
                            st.dataframe(results_df, use_container_width=True)
                            
                            # Сохраняем параметры в файл
                            if success_count > 0:
                                if save_param_values_to_file():
                                    st.success("💾 Параметры сохранены в файл!")
                                else:
                                    st.warning("⚠️ Параметры сохранены в памяти, но не в файл")
                                
                                st.info("💡 **Совет:** Параметры товаров автоматически сохранены. Вы можете использовать их в массовом анализе или просмотреть в редакторе параметров.")
            else:
                st.warning("⚠️ Введите хотя бы одну ссылку на товар Wildberries")
    
    # Обработка загрузки из кеша (ручная или автоматическая)
    if st.session_state.get("load_from_cache", False) or st.session_state.get("auto_load_file", False):
        file_data, meta_data = load_file_cache()
        if file_data and meta_data:
            # Создаем объект, похожий на uploaded file
            class CachedFile:
                def __init__(self, data, name):
                    self.data = data
                    self.name = name
                
                def read(self):
                    return self.data
                
                def seek(self, pos):
                    pass  # Заглушка для совместимости
            
            uploaded = CachedFile(file_data, meta_data["filename"])
            
            # Сохраняем информацию о загруженном файле в session_state
            st.session_state["cached_file_data"] = file_data
            st.session_state["cached_file_name"] = meta_data["filename"]
            st.session_state["file_loaded_from_cache"] = True
            
            # ВАЖНО: Проверяем, есть ли информация о проекте в метаданных
            project_id = meta_data.get("project_id")
            project_name = meta_data.get("project_name")
            
            if project_id:
                # Если есть проект, восстанавливаем информацию о проекте
                st.session_state["current_project_id"] = project_id
                st.session_state["current_project_name"] = project_name
            else:
                # Если проекта нет, очищаем информацию о предыдущем проекте
                if "current_project_id" in st.session_state:
                    del st.session_state["current_project_id"]
                if "current_project_name" in st.session_state:
                    del st.session_state["current_project_name"]
                # Очищаем параметры предыдущего проекта
                st.session_state["param_values"] = {}
                st.session_state["param_options"] = {}
                st.session_state["deleted_params"] = set()
            
            # Загружаем параметры и настройки для файла (только из файла текущего проекта)
            load_param_values_from_file()
            load_main_page_data_from_file()
            
            if st.session_state.get("auto_load_file", False):
                if project_id:
                    st.success(f"🔄 Автозагрузка: проект '{project_name}' восстановлен из кеша")
                else:
                    st.success(f"🔄 Автозагрузка: файл восстановлен из кеша - {meta_data['filename']}")
                st.session_state["auto_load_file"] = False
            else:
                if project_id:
                    st.success(f"✅ Проект '{project_name}' загружен из кеша")
                else:
                    st.success(f"✅ Файл загружен из кеша: {meta_data['filename']}")
            
            # Сбрасываем флаги
            st.session_state["load_from_cache"] = False
        else:
            st.error("❌ Не удалось загрузить файл из кеша")
            st.session_state["load_from_cache"] = False
            st.session_state["auto_load_file"] = False
            uploaded = None
    else:
        # Проверяем, есть ли сохраненный файл в session_state
        if st.session_state.get("file_loaded_from_cache", False) and st.session_state.get("cached_file_data"):
            # Восстанавливаем файл из session_state
            class CachedFile:
                def __init__(self, data, name):
                    self.data = data
                    self.name = name
                
                def read(self):
                    return self.data
                
                def seek(self, pos):
                    pass  # Заглушка для совместимости
            
            uploaded = CachedFile(st.session_state["cached_file_data"], st.session_state["cached_file_name"])
        else:
            # Используем файл, загруженный через основную кнопку загрузки
            uploaded = st.session_state.get("uploaded_file", None)
    
    # Автоматическая загрузка последнего файла из кеша, если файл не загружен
    if uploaded is None and not st.session_state.get("auto_load_attempted", False):
        # Пытаемся загрузить последний файл из кеша
        file_data, meta_data = load_file_cache()
        if file_data and meta_data:
            # Создаем объект, похожий на uploaded file
            class CachedFile:
                def __init__(self, data, name):
                    self.data = data
                    self.name = name
                
                def read(self):
                    return self.data
                
                def seek(self, pos):
                    pass  # Заглушка для совместимости
            
            uploaded = CachedFile(file_data, meta_data["filename"])
            
            # Сохраняем информацию о загруженном файле в session_state
            st.session_state["cached_file_data"] = file_data
            st.session_state["cached_file_name"] = meta_data["filename"]
            st.session_state["file_loaded_from_cache"] = True
            st.session_state["auto_load_attempted"] = True
            
            # ВАЖНО: Проверяем, есть ли информация о проекте в метаданных
            project_id = meta_data.get("project_id")
            project_name = meta_data.get("project_name")
            
            if project_id:
                # Если есть проект, восстанавливаем информацию о проекте
                st.session_state["current_project_id"] = project_id
                st.session_state["current_project_name"] = project_name
            else:
                # Если проекта нет, очищаем информацию о предыдущем проекте
                if "current_project_id" in st.session_state:
                    del st.session_state["current_project_id"]
                if "current_project_name" in st.session_state:
                    del st.session_state["current_project_name"]
                # Очищаем параметры предыдущего проекта
                st.session_state["param_values"] = {}
                st.session_state["param_options"] = {}
                st.session_state["deleted_params"] = set()
            
            # Загружаем параметры и настройки для файла (только из файла текущего проекта)
            load_param_values_from_file()
            load_main_page_data_from_file()
            # Перезагружаем страницу для отображения данных
            st.rerun()
        else:
            # Если файла в кеше нет, пробуем найти последний файл в папке file_cache
            cached_files = get_all_cached_files()
            if cached_files:
                # Берем самый последний файл
                latest_file = cached_files[0]
                try:
                    with open(latest_file["path"], "rb") as f:
                        file_data = f.read()
                    
                    # Обновляем метаданные
                    meta_data = {
                        "filename": latest_file["filename"],
                        "timestamp": latest_file["timestamp"],
                        "size": latest_file["size"],
                        "last_used": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S")
                    }
                    
                    with open("file_cache_meta.json", "w", encoding="utf-8") as f:
                        json.dump(meta_data, f, ensure_ascii=False, indent=2)
                    
                    # Создаем объект CachedFile
                    class CachedFile:
                        def __init__(self, data, name):
                            self.data = data
                            self.name = name
                        
                        def read(self):
                            return self.data
                        
                        def seek(self, pos):
                            pass
                    
                    uploaded = CachedFile(file_data, latest_file["filename"])
                    
                    # Сохраняем информацию в session_state
                    st.session_state["cached_file_data"] = file_data
                    st.session_state["cached_file_name"] = latest_file["filename"]
                    st.session_state["file_loaded_from_cache"] = True
                    st.session_state["auto_load_attempted"] = True
                    
                    # Загружаем параметры и настройки
                    load_param_values_from_file()
                    load_main_page_data_from_file()
                    # Перезагружаем страницу для отображения данных
                    st.rerun()
                except Exception as e:
                    st.session_state["auto_load_attempted"] = True
            else:
                st.session_state["auto_load_attempted"] = True

# Если сайдбар скрыт/свернут, даём альтернативный загрузчик в основном контенте
uploaded_inline = None
if uploaded_sidebar is None:
    uploaded_inline = st.file_uploader(
        "Excel/CSV с товарами (основной блок)", type=["xlsx", "xls", "csv"], key="main_uploader_inline"
    )

# Файл из кеш-логики внутри сайдбара (может быть None)
uploaded_cached = locals().get("uploaded", None)

# Выбираем фактически загруженный файл (если есть)
uploaded = uploaded_sidebar or uploaded_inline or uploaded_cached
new_upload = uploaded_sidebar is not None or uploaded_inline is not None

# Автоматическое сохранение загруженного файла в кеш (только для нового файла)
if new_upload and uploaded is not None:
    file_data = uploaded.read()
    # Возвращаем указатель в начало для дальнейшего чтения
    uploaded.seek(0)
    
    # Сохраняем в кеш с улучшенной системой
    cache_saved = save_file_to_cache(file_data, uploaded.name)
    if cache_saved:
        st.success(f"💾 Файл автоматически сохранен в кеш: {uploaded.name}")
    else:
        st.warning("⚠️ Не удалось сохранить файл в кеш. Продолжаю без кеша.")
    
    # Сохраняем информацию в session_state в любом случае
    st.session_state["cached_file_data"] = file_data
    st.session_state["cached_file_name"] = uploaded.name
    st.session_state["file_loaded_from_cache"] = True
    st.session_state["uploaded_file"] = uploaded
    st.session_state["auto_load_attempted"] = True
    
    # ВАЖНО: При загрузке нового файла очищаем информацию о предыдущем проекте
    # Новый файл = новый проект, параметры загружаются только для этого файла
    if "current_project_id" in st.session_state:
        del st.session_state["current_project_id"]
    if "current_project_name" in st.session_state:
        del st.session_state["current_project_name"]
    
    # Очищаем параметры предыдущего проекта
    st.session_state["param_values"] = {}
    st.session_state["param_options"] = {}
    st.session_state["deleted_params"] = set()
    st.session_state["excluded_params"] = []
    
    # Загружаем параметры и настройки для нового файла (только из файла этого проекта)
    load_param_values_from_file()
    load_main_page_data_from_file()
    st.rerun()

with st.sidebar.expander("Скриншоты страниц (s-shot.ru)", expanded=True):
    sc_key = st.text_input("Ключ s-shot", value="KEYSV7S9IWCFGI50SA8")
    sc_base = st.text_input("Базовый URL", value="https://api.s-shot.ru")
    sc_host = st.text_input("Домен карточки WB", value="https://global.wildberries.ru")
    sc_w = st.number_input("Ширина", 100, 2000, 400, 10)
    sc_h = st.number_input("Высота", 100, 2000, 600, 10)
    sc_fmt = st.selectbox("Формат", ["JPEG","PNG"], 0)
    sc_profile = st.text_input("Профиль", value="D4")
    
    # Информация о кеше
    url_cache = get_url_cache_with_state(st.session_state)
    cached_count = len(url_cache)
    st.info(f"📦 В кеше: {cached_count} изображений")
    
    # Кнопки управления кешем
    col_cache1, col_cache2 = st.columns(2)
    if col_cache1.button("🗑️ Очистить кеш"):
        st.session_state["img_url_cache"] = {}
        save_url_cache({})
        st.rerun()
    
    if col_cache2.button("💾 Сохранить параметры"):
        if save_param_values_to_file():
            st.success("✅ Параметры сохранены!")
        else:
            st.error("❌ Ошибка сохранения параметров")
    
    # Кнопка сохранения данных главной страницы
    if st.button("💾 Сохранить настройки главной страницы", use_container_width=True):
        # Сохраняем текущие значения в session_state
        st.session_state["search"] = st.session_state.get("search_input", "")
        st.session_state["spp"] = st.session_state.get("spp_input", 25)
        st.session_state["buyout_pct"] = st.session_state.get("buyout_input", 25)
        st.session_state["revenue_min"] = st.session_state.get("revenue_min_input", 0)
        st.session_state["revenue_max"] = st.session_state.get("revenue_max_input", 1000000)
        st.session_state["price_min"] = st.session_state.get("price_min_input", 0)
        st.session_state["price_max"] = st.session_state.get("price_max_input", 10000)
        
        if save_main_page_data_to_file():
            st.success("✅ Настройки главной страницы сохранены!")
        else:
            st.error("❌ Ошибка сохранения настроек")
    
    st.divider()
    
    # Управление таблицей параметров
    st.write("**Управление таблицей параметров:**")
    
    # Кнопка сохранения
    if st.button("💾 Сохранить таблицу в кеш", use_container_width=True):
            # Получаем удаленные параметры для фильтрации
            deleted_params = st.session_state.get("deleted_params", load_deleted_params_from_file())
            param_values = st.session_state.get("param_values", {})
            param_options = st.session_state.get("param_options", {})
            
            # Фильтруем удаленные параметры перед сохранением
            filtered_param_values = {
                k: v for k, v in param_values.items() 
                if k not in deleted_params
            } if deleted_params else param_values
            
            filtered_param_options = {
                k: v for k, v in param_options.items() 
                if k not in deleted_params
            } if deleted_params else param_options
            
            # Сохраняем текущую таблицу параметров
            table_cache_data = {
                "param_values": filtered_param_values,
                "param_options": filtered_param_options,
                "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S")
            }
            
            # Сохраняем в файл
            try:
                import json
                with open("table_cache.json", "w", encoding="utf-8") as f:
                    json.dump(table_cache_data, f, ensure_ascii=False, indent=2)
                st.success("✅ Таблица сохранена в кеш!")
            except Exception as e:
                st.error(f"❌ Ошибка сохранения: {e}")
    
    # Кнопка загрузки
    if st.button("📂 Загрузить таблицу из кеша", use_container_width=True):
            # Загружаем последнюю сохраненную таблицу
            try:
                import json
                import os
                if os.path.exists("table_cache.json"):
                    with open("table_cache.json", "r", encoding="utf-8") as f:
                        table_cache_data = json.load(f)
                    
                    # Загружаем список удаленных параметров
                    deleted_params = load_deleted_params_from_file()
                    
                    # Восстанавливаем данные
                    param_values_raw = table_cache_data.get("param_values", {})
                    param_options_raw = table_cache_data.get("param_options", {})
                    
                    # Фильтруем невалидные и удаленные параметры
                    st.session_state["param_values"] = {
                        k: v for k, v in param_values_raw.items() 
                        if is_valid_param_name(k) and k not in deleted_params
                    }
                    st.session_state["param_options"] = {
                        k: v for k, v in param_options_raw.items() 
                        if is_valid_param_name(k) and k not in deleted_params
                    }
                    st.session_state["param_ratings"] = table_cache_data.get("param_ratings", {})
                    
                    # Сохраняем deleted_params в session_state
                    st.session_state["deleted_params"] = deleted_params
                    
                    timestamp = table_cache_data.get("timestamp", "неизвестно")
                    st.success(f"✅ Таблица загружена! (сохранена: {timestamp})")
                    st.rerun()
                else:
                    st.warning("Кеш таблицы не найден")
            except Exception as e:
                st.error(f"❌ Ошибка загрузки: {e}")
    
    # Кнопка очистки
    if st.button("🗑️ Очистить кеш таблицы", use_container_width=True):
            # Очищаем кеш таблицы параметров
            try:
                import os
                if os.path.exists("table_cache.json"):
                    os.remove("table_cache.json")
                    st.success("✅ Кеш таблицы очищен!")
                else:
                    st.warning("Кеш таблицы не найден")
                st.rerun()
            except Exception as e:
                st.error(f"❌ Ошибка очистки кеша: {e}")
    
    # Информация о кеше таблицы
    try:
        import json
        import os
        if os.path.exists("table_cache.json"):
            with open("table_cache.json", "r", encoding="utf-8") as f:
                table_cache_data = json.load(f)
            timestamp = table_cache_data.get("timestamp", "неизвестно")
            param_count = len(table_cache_data.get("param_options", {}))
            st.info(f"📦 Кеш таблицы: {param_count} параметров, сохранен {timestamp}")
    except:
        pass

if uploaded is None:
    st.info("Загрузите файл с данными.")
else:
    df, raw, meta = read_table(uploaded.read(), uploaded.name)
    if df is None or df.empty:
        st.error("Не удалось прочитать таблицу.")
    else:
        # Сохраняем df в session_state для использования в других вкладках
        st.session_state["df"] = df
        st.title("📊 Дашборд WB")
        
        # Получаем анализируемый период (для внутреннего использования)
        analysis_period = get_analysis_period(df, raw, meta.get("header_row"))
        
        # Отображаем информацию о периоде анализа
        if analysis_period:
            source_text = "из заголовка таблицы" if analysis_period.get("source") == "header" else "из колонки 'Дата создания'"
            st.success(f"📅 **Анализируемый период:** {analysis_period['period_str']} ({source_text})")
        
        # Импортируем модуль анализа сезонности
        # Создаем вкладки
        if PROPHET_AVAILABLE:
            tab1, tab2, tab3, tab4, tab5, tab6, tab7, tab8 = st.tabs([
                "📊 Анализ данных",
                "⚙️ Установка параметров",
                "📈 Аналитика по параметрам",
                "🔮 Прогнозирование",
                "🗺️ План продаж",
                "📝 Анализ отзывов",
                "📣 Маркетинг",
                "📦 Расчет заказа"
            ])
        else:
            tab1, tab2, tab3, tab4, tab5, tab6, tab7 = st.tabs([
                "📊 Анализ данных",
                "⚙️ Установка параметров",
                "📈 Аналитика по параметрам",
                "🗺️ План продаж",
                "📝 Анализ отзывов",
                "📣 Маркетинг",
                "📦 Расчет заказа"
            ])
        
        with tab1:
            # Основные фильтры
            col1, col2, col3, col4 = st.columns(4)
        
            search = col1.text_input("🔍 Поиск", value=st.session_state.get("search", ""), key="search_input")
            spp = col2.number_input("💰 СПП, %", 0, 100, st.session_state.get("spp", 25), 1, key="spp_input")
            buyout_pct = col3.number_input("📈 Процент выкупа, %", 1, 100, st.session_state.get("buyout_pct", 25), 1, key="buyout_input")
            
            # Сохраняем значения в session_state
            st.session_state["search"] = search
            st.session_state["spp"] = spp
            st.session_state["buyout_pct"] = buyout_pct
            
            # Автоматически сохраняем настройки при изменении
            save_main_page_data_to_file()
            
            # Кнопка обновления данных
            col4.markdown("🔄 Обновить данные")
            if col4.button("Обновить", type="primary"):
                st.rerun()
            
            # Фильтр по предмету на отдельной строчке
            if "Предмет" in df.columns:
                subjects = sorted(df["Предмет"].dropna().unique())
                selected_subjects = st.multiselect("📦 Предмет", subjects, default=subjects)
            else:
                selected_subjects = []
            
            # Фильтры по параметрам товаров
            param_values = get_param_values()
            selected_param_filters = {}
            
            # Исключаем скрытые параметры из фильтров
            excluded_params = set(st.session_state.get("excluded_params", []))
            visible_param_values = {k: v for k, v in param_values.items() if k not in excluded_params} if param_values else {}
            
            if visible_param_values:
                # Переключатель для включения/выключения фильтров по параметрам
                enable_param_filters = st.checkbox(
                    "🎨 Включить фильтры по параметрам", 
                    value=False,
                    help="Включить фильтрацию товаров по их параметрам (цвет, материал и т.д.)"
                )
                
                if enable_param_filters:
                    st.subheader("🎨 Фильтры по параметрам")
                    
                    # Создаем колонки для фильтров параметров
                    param_cols = st.columns(min(len(visible_param_values), 4))  # Максимум 4 колонки
                    
                    for i, (param_name, param_data) in enumerate(visible_param_values.items()):
                        col_idx = i % 4
                        
                        with param_cols[col_idx]:
                            # Получаем уникальные значения для этого параметра (убираем дубликаты)
                            unique_values = sorted(list(set([v for v in param_data.values() if v and v.strip()])))
                            
                            if unique_values:
                                # Создаем multiselect для каждого параметра
                                selected_values = st.multiselect(
                                    f"🎨 {param_name}",
                                    unique_values,
                                    default=[],  # По умолчанию ничего не выбрано
                                    help=f"Выберите значения для параметра '{param_name}'"
                                )
                                selected_param_filters[param_name] = selected_values
                            else:
                                selected_param_filters[param_name] = []
            
            # Настройки отображения
            # Инициализируем img_size по умолчанию (гарантируем, что это число)
            if "img_size" not in st.session_state:
                st.session_state["img_size"] = 200
            img_size = int(st.session_state.get("img_size", 200))
            col_img1, col_img2, col_img3 = st.columns(3)
            show_images = col_img1.checkbox("🖼️ Показывать изображения", value=False)
            if show_images:
                img_size = int(col_img2.number_input("📏 Размер миниатюр (px)", min_value=50, max_value=300, value=int(img_size), step=10))
                st.session_state["img_size"] = img_size
                if col_img3.button("🔄 Обновить кеш изображений", type="secondary"):
                    # Очищаем кеш URL
                    st.session_state["img_url_cache"] = {}
                    save_url_cache({})
                    st.rerun()
                
                # Показываем информацию о кеше изображений
                cache_status = get_cache_status()
                col_cache_info, col_cache_clear = st.columns([2, 1])
                
                with col_cache_info:
                    if cache_status["count"] > 0:
                        size_mb = cache_status["size"] / (1024 * 1024)
                        st.info(f"📦 Кеш изображений: {cache_status['count']} файлов ({size_mb:.1f} МБ)")
                    else:
                        st.info("📦 Кеш изображений пуст")
                
                with col_cache_clear:
                    if cache_status["count"] > 0:
                        if st.button("🗑️ Очистить кеш", key="clear_image_cache"):
                            try:
                                cache_dir = os.path.join(_cache_dir(), "imgs")
                                if os.path.exists(cache_dir):
                                    for file in cache_status["files"]:
                                        if os.path.exists(file["path"]):
                                            os.remove(file["path"])
                                st.success(f"✅ Удалено {cache_status['count']} изображений из кеша")
                                st.rerun()
                            except Exception as e:
                                st.error(f"❌ Ошибка очистки кеша: {e}")
                if not sc_key:
                    st.info("💡 Для отображения изображений товаров введите API ключ s-shot.ru в боковой панели")
            
            # Фильтр сортировки
            col_sort1, col_sort2 = st.columns(2)
            
            # Определяем доступные колонки для сортировки
            sortable_columns = []
            if "Выручка" in df.columns:
                sortable_columns.append("Выручка")
            if "Средняя цена" in df.columns:
                sortable_columns.append("Средняя цена")
            if "Заказы" in df.columns:
                sortable_columns.append("Заказы")
            if "Дата создания" in df.columns:
                sortable_columns.append("Дата создания")
            if "Прибыль" in df.columns:
                sortable_columns.append("Прибыль")
            if "Упущенная выручка" in df.columns:
                sortable_columns.append("Упущенная выручка")
            if "Позиция в выдаче" in df.columns:
                sortable_columns.append("Позиция в выдаче")
            
            # Добавляем опцию "Без сортировки"
            sortable_columns.insert(0, "Без сортировки")
            
            # Находим индекс "Выручка" для установки по умолчанию
            default_index = 0  # По умолчанию "Без сортировки"
            if "Выручка" in sortable_columns:
                default_index = sortable_columns.index("Выручка")
            
            sort_column = col_sort1.selectbox("📊 Сортировка по", sortable_columns, index=default_index)
            sort_ascending = col_sort2.selectbox("🔽 Направление", ["По убыванию", "По возрастанию"], index=0) == "По возрастанию"
            
            st.divider()
            
            # Выручка
            col7, col8 = st.columns(2)
            
            if "Выручка" in df.columns:
                default_revenue_max = int(df["Выручка"].max()) if not df["Выручка"].isna().all() else 1000000
                revenue_min = col7.number_input("Выручка от", min_value=0, value=st.session_state.get("revenue_min", 0), step=1000, key="revenue_min_input")
                revenue_max = col8.number_input("Выручка до", min_value=0, value=st.session_state.get("revenue_max", default_revenue_max), step=1000, key="revenue_max_input")
                
                # Сохраняем значения в session_state
                st.session_state["revenue_min"] = revenue_min
                st.session_state["revenue_max"] = revenue_max
                
                # Автоматически сохраняем настройки при изменении
                save_main_page_data_to_file()
            else:
                revenue_min = st.session_state.get("revenue_min", 0)
                revenue_max = st.session_state.get("revenue_max", 1000000)
            
            # Цена
            col9, col10 = st.columns(2)
            
            if "Средняя цена" in df.columns:
                default_price_max = int(df["Средняя цена"].max()) if not df["Средняя цена"].isna().all() else 10000
                price_min = col9.number_input("Цена (до СПП) от", min_value=0, value=st.session_state.get("price_min", 0), step=100, key="price_min_input")
                price_max = col10.number_input("Цена (до СПП) до", min_value=0, value=st.session_state.get("price_max", default_price_max), step=100, key="price_max_input")
                
                # Сохраняем значения в session_state
                st.session_state["price_min"] = price_min
                st.session_state["price_max"] = price_max
                
                # Автоматически сохраняем настройки при изменении
                save_main_page_data_to_file()
            else:
                price_min = st.session_state.get("price_min", 0)
                price_max = st.session_state.get("price_max", 10000)
            
            # Дата создания
            
            # Определяем диапазон дат для фильтрации
            # Всегда используем полный диапазон дат создания для фильтра
            if "Дата создания" in df.columns:
                # Используем даты из колонки "Дата создания"
                date_range = df["Дата создания"].dropna()
                if not date_range.empty:
                    min_date = date_range.min().date()
                    max_date = date_range.max().date()
                    date_source = "колонка 'Дата создания'"
                else:
                    min_date = pd.Timestamp.now().date()
                    max_date = pd.Timestamp.now().date()
                    date_source = "не найдены"
                    st.warning("⚠️ В данных нет информации о датах")
            else:
                min_date = pd.Timestamp.now().date()
                max_date = pd.Timestamp.now().date()
                date_source = "не найдены"
                st.warning("⚠️ Колонка 'Дата создания' не найдена в данных")
            

            
            # Создаем ползунок для выбора диапазона дат
            date_range_days = (max_date - min_date).days
            if date_range_days > 0:
                date_slider = st.slider(
                    "📅 Выберите диапазон дат для фильтрации",
                    min_value=min_date,
                    max_value=max_date,
                    value=(min_date, max_date),
                    help="Выберите период для анализа. По умолчанию показан полный диапазон дат создания."
                )
                date_min, date_max = date_slider
            else:
                date_min = min_date
                date_max = max_date
                st.info(f"📅 Данные за один день: {min_date.strftime('%d.%m.%Y')}")
            fdf = df.copy()
            
            # Применяем фильтры
            if search:
                mask = fdf.apply(lambda x: x.astype(str).str.contains(search, case=False, na=False)).any(axis=1)
                fdf = fdf[mask]
            
            if selected_subjects and "Предмет" in fdf.columns:
                fdf = fdf[fdf["Предмет"].isin(selected_subjects)]
            
            # Фильтр по выручке
            if "Выручка" in fdf.columns:
                fdf = fdf[(fdf["Выручка"] >= revenue_min) & (fdf["Выручка"] <= revenue_max)]
            
            # Фильтр по цене
            if "Средняя цена" in fdf.columns:
                fdf = fdf[(fdf["Средняя цена"] >= price_min) & (fdf["Средняя цена"] <= price_max)]
            
            # Фильтр по дате создания
            if "Дата создания" in fdf.columns:
                fdf = fdf[(fdf["Дата создания"].dt.date >= date_min) & (fdf["Дата создания"].dt.date <= date_max)]
            
            # Фильтры по параметрам товаров
            if param_values and selected_param_filters and enable_param_filters:
                for param_name, selected_values in selected_param_filters.items():
                    if selected_values:  # Если выбраны значения для фильтрации
                        # Находим артикулы, которые соответствуют выбранным значениям параметра
                        matching_skus = []
                        if param_name in param_values:
                            for sku, value in param_values[param_name].items():
                                if value in selected_values:
                                    matching_skus.append(sku)
                        
                        if matching_skus:
                            # Фильтруем данные по найденным артикулам
                            mask = fdf["Артикул"].astype(str).str.replace(".0", "").isin(matching_skus)
                            fdf = fdf[mask]
            
            if "Средняя цена" in fdf.columns:
                fdf["Цена (с СПП)"] = fdf["Средняя цена"] * (1 - float(spp)/100.0)
            buyout_k = float(buyout_pct)/100.0 if buyout_pct else 0.0
            if "Заказы" in fdf.columns:
                fdf["Выкупы"] = pd.to_numeric(fdf["Заказы"], errors="coerce") * buyout_k
            else:
                fdf["Выкупы"] = np.nan
            # === FIX: Прибыль = Выручка * (процент выкупа) ===
            if "Выручка" in fdf.columns and buyout_k > 0:
                fdf["Прибыль"] = pd.to_numeric(fdf["Выручка"], errors="coerce") * buyout_k
            else:
                fdf["Прибыль"] = np.nan
            
            # Применяем сортировку
            if sort_column and sort_column != "Без сортировки" and sort_column in fdf.columns:
                fdf = sort_df(fdf, sort_column, sort_ascending)
            
            kpi_row(fdf)
            st.divider()

            # Миниатюры кэш
            url_cache = get_url_cache_with_state(st.session_state)
            
            # Создаем копию для отображения
            display_df = fdf.copy()
            # Сохраняем display_df в session_state для использования в других вкладках
            st.session_state["display_df"] = display_df
            
            # Добавляем изображения
            if show_images and "Артикул" in display_df.columns:
                imgs = []
                loaded_count = 0
                cached_count = 0
                total_items = len(display_df)
                
                # Создаем прогресс-бар если много товаров
                if total_items > 10:
                    progress_bar = st.progress(0)
                    status_text = st.empty()
                
                for i, a in enumerate(display_df["Артикул"].astype(str)):
                    k = a.replace(".0","")
                    url = url_cache.get(k, "")
                    if not url and sc_key:
                        url = screenshot_for_article(k, {"key": sc_key,"w": sc_w,"h": sc_h,"fmt": sc_fmt,"profile": sc_profile,"base": sc_base,"wb_host": sc_host})
                        if url:
                            url_cache[k] = url
                            save_url_cache(url_cache)
                    
                    # Проверяем кеш изображений - сначала ищем уже скачанные
                    cached_path = get_cached_image_path(k)
                    if cached_path and os.path.exists(cached_path):
                        # Изображение уже в кеше, используем его
                        path = cached_path
                        cached_count += 1
                    elif url:
                        # Изображения нет в кеше, но есть URL - скачиваем
                        path = ensure_image_cached(k, url, sc_fmt)
                    else:
                        # Нет ни кеша, ни URL
                        path = ""
                    
                    if path and os.path.exists(path):
                        # Создаем data URI для Streamlit
                        img_bytes = load_image_bytes(path, img_size)
                        if img_bytes:
                            b64_data = base64.b64encode(img_bytes).decode()
                            data_uri = f"data:image/jpeg;base64,{b64_data}"
                            imgs.append(data_uri)
                            loaded_count += 1
                        else:
                            imgs.append("")
                    else:
                        imgs.append("")
                    
                    # Обновляем прогресс
                    if total_items > 10:
                        # Ограничиваем значение progress до максимум 1.0
                        progress = min((i + 1) / total_items, 1.0)
                        progress_bar.progress(progress)
                        status_text.text(f"Загружаем изображения: {i + 1}/{total_items}")
                
                # Очищаем прогресс-бар
                if total_items > 10:
                    progress_bar.empty()
                    status_text.empty()
                
                display_df.insert(1, "Изображение", imgs)
                
                # Показываем статистику загрузки
                if cached_count > 0:
                    st.success(f"📊 Загружено изображений: {loaded_count} из {len(display_df)} товаров (из кеша: {cached_count})")
                else:
                    st.success(f"📊 Загружено изображений: {loaded_count} из {len(display_df)} товаров")
            
            # Добавляем отдельный столбец со ссылками на артикулы
            if "Артикул" in display_df.columns:
                # Создаем специальный формат для отображения "Открыть" в Streamlit
                display_df["Ссылка"] = "Открыть"
                # Но фактические ссылки будут настроены через column_config
            
            # Форматирование даты для Streamlit таблицы
            if "Дата создания" in display_df.columns:
                display_df["Дата создания"] = display_df["Дата создания"].apply(fmt_date)
            
            # Оставляем числовые данные как есть для корректной сортировки в Streamlit таблице
            
            # Изменение порядка столбцов
            desired_order = [
                "Артикул", "Ссылка", "Дата создания", "Выручка", "Заказы", "Выкупы", 
                "Средняя цена", "Цена (с СПП)", "Упущенная выручка", "Прибыль",
                "Предмет", "Позиция в выдаче", "Стоимость за 1000 показов", 
                "Тип рекламы", "Буст на позицию", "Буст с позиции", "Дельта",
                "Название", "Поставщик", "Бренд"
            ]
            
            # Добавляем изображения в начало если нужно
            if show_images and "Изображение" in display_df.columns:
                desired_order.insert(1, "Изображение")
            
            # Информация о загруженных параметрах (только видимые)
            excluded_params = set(st.session_state.get("excluded_params", []))
            visible_params = {k: v for k, v in param_values.items() if k not in excluded_params} if param_values else {}
            if visible_params:
                total_params = sum(len(param_data) for param_data in visible_params.values())
                hidden_count = len(excluded_params)
                if hidden_count > 0:
                    st.info(f"📊 Параметров: {list(visible_params.keys())} ({total_params} значений) | 👁️ Скрыто: {hidden_count}")
                else:
                    st.info(f"📊 Загружено параметров: {list(visible_params.keys())} ({total_params} значений)")
            
            # Получаем список всех параметров (исключаем "крой" и скрытые параметры)
            all_params = list(param_values.keys())
            if "param_options" in st.session_state:
                all_params.extend([p for p in st.session_state["param_options"].keys() if p not in all_params])
            
            # Исключаем столбец "крой" из отображения
            all_params = [param for param in all_params if param.lower() != "крой"]
            
            # Исключаем скрытые параметры (excluded_params) из отображения в таблице
            excluded_params = set(st.session_state.get("excluded_params", []))
            all_params = [param for param in all_params if param not in excluded_params]
            
            # Добавляем столбцы параметров в DataFrame
            for param in all_params:
                param_column_data = []
                for sku in display_df["Артикул"].astype(str):
                    sku_clean = sku.replace(".0", "")
                    param_value = param_values.get(param, {}).get(sku_clean, "")
                    param_column_data.append(param_value)
                display_df[param] = param_column_data
            
            # Переупорядочиваем столбцы - параметры после "Дата создания"
            existing_cols = [col for col in desired_order if col in display_df.columns]
            
            # Находим позицию "Дата создания" в desired_order
            date_creation_index = -1
            if "Дата создания" in desired_order:
                date_creation_index = desired_order.index("Дата создания")
            
            # Разделяем столбцы на основные и параметры
            main_cols = [col for col in existing_cols if col not in all_params]
            param_cols = [col for col in all_params if col in display_df.columns]
            other_cols = [col for col in display_df.columns if col not in existing_cols and col not in all_params]
            
            # Если "Дата создания" найдена, вставляем параметры после неё
            if date_creation_index >= 0 and "Дата создания" in main_cols:
                date_index = main_cols.index("Дата создания")
                # Вставляем параметры после "Дата создания"
                final_order = main_cols[:date_index+1] + param_cols + main_cols[date_index+1:] + other_cols
            else:
                # Если "Дата создания" не найдена, добавляем параметры в конец основных столбцов
                final_order = main_cols + param_cols + other_cols
            
            display_df = display_df[final_order]

            from streamlit import column_config as cc
            
            # Настройка конфигурации столбцов для лучшего отображения
            col_cfg = {}
            
            # Конфигурация для изображений
            if "Изображение" in display_df.columns:
                # Убеждаемся, что img_size - это число (гарантируем целое число)
                try:
                    img_width = int(float(img_size)) + 20
                except (ValueError, TypeError):
                    img_width = 220
                col_cfg["Изображение"] = cc.ImageColumn("Изображение", width=int(img_width))
            
            # Конфигурация для артикула (числовой тип)
            if "Артикул" in display_df.columns:
                col_cfg["Артикул"] = cc.NumberColumn("Артикул", format="%.0f", width=int(120))
            
            # Конфигурация для ссылки на товар с динамическими URL
            if "Ссылка" in display_df.columns and "Артикул" in display_df.columns:
                # Создаем ссылки на основе артикулов
                links_data = []
                for sku in display_df["Артикул"].astype(str):
                    sku_clean = sku.replace(".0", "")
                    links_data.append(f"https://global.wildberries.ru/catalog/{sku_clean}/detail.aspx")
                display_df["Ссылка"] = links_data
                # Явно указываем тип данных как строковый
                display_df["Ссылка"] = display_df["Ссылка"].astype(str)
                col_cfg["Ссылка"] = cc.LinkColumn("Ссылка", display_text="🔗", width=int(60))
            
            # Конфигурация для числовых столбцов (NumberColumn для корректной сортировки)
            money_columns = ["Выручка", "Средняя цена", "Цена (с СПП)", "Упущенная выручка", "Прибыль"]
            for col in money_columns:
                if col in display_df.columns:
                    col_cfg[col] = cc.NumberColumn(col, format="%.0f ₽", width=int(120))
            
            # Конфигурация для числовых столбцов с единицами
            if "Заказы" in display_df.columns:
                col_cfg["Заказы"] = cc.NumberColumn("Заказы", format="%.0f шт.", width=int(120))
            if "Выкупы" in display_df.columns:
                col_cfg["Выкупы"] = cc.NumberColumn("Выкупы", format="%.0f шт.", width=int(120))
            
            # Конфигурация для даты - отключаем редактирование чтобы избежать проблем с типами
            if "Дата создания" in display_df.columns:
                col_cfg["Дата создания"] = cc.TextColumn("Дата создания", width=int(150), disabled=True)
            
    # Конфигурация для параметров товаров
    for param in all_params:
        if param in display_df.columns:
            if param in st.session_state.get("param_options", {}):
                # Selectbox для параметров с вариантами
                options = [""] + st.session_state["param_options"][param]
                col_cfg[param] = cc.SelectboxColumn(
                    param, 
                    options=options, 
                    width=int(150)
                )
            else:
                # Проверяем тип данных в колонке для правильной настройки
                column_data = display_df[param]
                if column_data.dtype in ['int64', 'float64'] or pd.api.types.is_numeric_dtype(column_data):
                    # Для числовых данных используем NumberColumn
                    col_cfg[param] = cc.NumberColumn(param, width=int(150), format="%.0f")
                else:
                    # Для текстовых данных используем TextColumn
                    col_cfg[param] = cc.TextColumn(param, width=int(150))
            
    # Отображаем редактируемую таблицу с возможностью сортировки
    # Вычисляем оптимальную высоту на основе количества строк
    num_rows = len(display_df)
    # Минимум 400px, максимум 5000px для очень больших таблиц
    optimal_height = max(400, min(5000, num_rows * 30 + 100))
    
    # Показываем информацию о таблице
    col_info1, col_info2 = st.columns(2)
    with col_info1:
        st.metric("📊 Строк в таблице", f"{num_rows:,}")
    with col_info2:
        st.metric("📏 Высота таблицы", f"{optimal_height}px")
    
    # Дополнительная проверка col_cfg - убеждаемся, что все width - это числа
    if col_cfg:
        for col_name, col_config in col_cfg.items():
            if hasattr(col_config, 'width') and col_config.width is not None:
                try:
                    col_config.width = int(col_config.width)
                except (ValueError, TypeError):
                    # Если width не может быть преобразован в int, убираем его
                    col_config.width = None
    
    # Поле поиска по артикулу
    if "Артикул" in display_df.columns:
        search_col1, search_col2 = st.columns([3, 1])
        with search_col1:
            sku_search = st.text_input(
                "🔍 Поиск по артикулу:",
                value=st.session_state.get("sku_search", ""),
                placeholder="Введите артикул для поиска...",
                key="sku_search_input"
            )
            st.session_state["sku_search"] = sku_search
        with search_col2:
            if st.button("🔄 Сбросить", key="reset_sku_search"):
                st.session_state["sku_search"] = ""
                sku_search = ""
                st.rerun()
        
        # Фильтруем таблицу по поисковому запросу
        if sku_search and sku_search.strip():
            search_term = sku_search.strip()
            # Ищем артикулы, содержащие поисковый запрос
            mask = display_df["Артикул"].astype(str).str.contains(search_term, case=False, na=False)
            filtered_display_df = display_df[mask].copy()
            
            if len(filtered_display_df) > 0:
                st.info(f"🔍 Найдено товаров: {len(filtered_display_df)} из {len(display_df)}")
            else:
                st.warning(f"⚠️ Товары с артикулом, содержащим '{search_term}', не найдены")
        else:
            filtered_display_df = display_df.copy()
    else:
        filtered_display_df = display_df.copy()
    
    # Сохраняем текущую выборку артикулов для использования в планах
    if "Артикул" in filtered_display_df.columns:
        st.session_state["analysis_filtered_skus"] = (
            filtered_display_df["Артикул"]
            .dropna()
            .astype(str)
            .str.replace(".0", "")
            .unique()
            .tolist()
        )
    
    edited_df = st.data_editor(
        filtered_display_df, 
        hide_index=True, 
        column_config=col_cfg if col_cfg else None,
        column_order=None,  # Позволяет пользователю переупорядочивать столбцы
        num_rows="fixed",
        use_container_width=True,
        key="main_table_editor"
    )
            
    # Сохраняем изменения параметров обратно в param_values
    if all_params:
        changes_made = False
        for index, row in edited_df.iterrows():
            # Обрабатываем артикул как число, но конвертируем в строку для ключей
            sku_raw = row["Артикул"]
            if pd.isna(sku_raw):
                continue
            sku = str(int(sku_raw)) if isinstance(sku_raw, (int, float)) else str(sku_raw)
            
            for param in all_params:
                if param in row and row[param]:
                    if param not in param_values:
                        param_values[param] = {}
                    if sku not in param_values[param] or param_values[param][sku] != str(row[param]):
                        param_values[param][sku] = str(row[param])
                        changes_made = True
                elif param in param_values and sku in param_values[param]:
                    # Удаляем пустые значения
                    if not row.get(param):
                        del param_values[param][sku]
                        changes_made = True
        
        # Показываем уведомление об изменениях (без автоматического сохранения)
        if changes_made:
            st.success("✅ Изменения параметров сохранены в памяти!")
                    
    # Кнопка для сохранения в файл
    col_save1, col_save2 = st.columns([1, 4])
    with col_save1:
        if st.button("💾 Сохранить в файл", type="primary"):
            if save_param_values_to_file():
                st.success("✅ Параметры сохранены в файл!")
            else:
                st.error("❌ Ошибка сохранения в файл")
    
    # ==================== ЭКСПОРТ ДАННЫХ ====================
    st.divider()
    st.subheader("💾 Экспорт данных")
    
    col_export1, col_export2, col_export3 = st.columns(3)
    
    with col_export1:
        # Экспорт текущих данных в Excel
        if st.button("📥 Скачать данные (Excel)", type="primary", use_container_width=True):
            try:
                # Создаем Excel файл с данными
                output = BytesIO()
                with pd.ExcelWriter(output, engine='openpyxl') as writer:
                    # Основная таблица с отфильтрованными данными
                    export_df = fdf.copy()
                    
                    # Убираем столбец с изображениями (если есть) - он не нужен в Excel
                    if "Изображение" in export_df.columns:
                        export_df = export_df.drop(columns=["Изображение"])
                    
                    # Убираем data URI из ссылок, оставляем только URL
                    if "Ссылка" in export_df.columns:
                        # Ссылки уже в правильном формате
                        pass
                    
                    export_df.to_excel(writer, sheet_name='Данные', index=False)
                    
                    # Добавляем лист со статистикой
                    stats_data = {
                        'Показатель': [
                            'Всего товаров',
                            'Общая выручка',
                            'Общие заказы',
                            'Средняя цена',
                            'Средняя выручка на товар',
                            'Период анализа',
                            'Дата экспорта'
                        ],
                        'Значение': [
                            len(export_df),
                            f"{export_df['Выручка'].sum():,.0f} ₽" if "Выручка" in export_df.columns else "N/A",
                            f"{export_df['Заказы'].sum():,.0f} шт" if "Заказы" in export_df.columns else "N/A",
                            f"{export_df['Средняя цена'].mean():,.0f} ₽" if "Средняя цена" in export_df.columns else "N/A",
                            f"{export_df['Выручка'].mean():,.0f} ₽" if "Выручка" in export_df.columns else "N/A",
                            analysis_period.get('period_str', 'N/A') if analysis_period else 'N/A',
                            datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                        ]
                    }
                    stats_df = pd.DataFrame(stats_data)
                    stats_df.to_excel(writer, sheet_name='Статистика', index=False)
                
                output.seek(0)
                
                # Получаем имя файла
                file_name = st.session_state.get("cached_file_name", "report")
                if file_name:
                    base_name = os.path.splitext(file_name)[0]
                else:
                    base_name = "report"
                
                export_filename = f"{base_name}_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
                
                st.download_button(
                    label="📥 Скачать Excel файл",
                    data=output.getvalue(),
                    file_name=export_filename,
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    key="download_excel_btn"
                )
                st.success("✅ Файл готов к скачиванию!")
            except Exception as e:
                st.error(f"❌ Ошибка создания Excel файла: {str(e)}")
    
    with col_export2:
        # Экспорт полного отчета с графиками (HTML)
        if st.button("📊 Создать отчет с графиками", type="primary", use_container_width=True):
            try:
                report_html = create_html_report_with_charts(fdf, df, analysis_period)
                
                # Получаем имя файла
                file_name = st.session_state.get("cached_file_name", "report")
                if file_name:
                    base_name = os.path.splitext(file_name)[0]
                else:
                    base_name = "report"
                
                report_filename = f"{base_name}_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
                
                st.download_button(
                    label="📊 Скачать HTML отчет",
                    data=report_html,
                    file_name=report_filename,
                    mime="text/html",
                    key="download_html_report_btn"
                )
                st.success("✅ HTML отчет готов к скачиванию!")
            except Exception as e:
                st.error(f"❌ Ошибка создания отчета: {str(e)}")
                import traceback
                st.code(traceback.format_exc())
    
    with col_export3:
        # Экспорт в CSV
        if st.button("📄 Скачать CSV", type="secondary", use_container_width=True):
            try:
                export_df = fdf.copy()
                
                # Убираем столбец с изображениями
                if "Изображение" in export_df.columns:
                    export_df = export_df.drop(columns=["Изображение"])
                
                csv_data = export_df.to_csv(index=False, encoding='utf-8-sig')
                
                file_name = st.session_state.get("cached_file_name", "report")
                if file_name:
                    base_name = os.path.splitext(file_name)[0]
                else:
                    base_name = "report"
                
                csv_filename = f"{base_name}_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
                
                st.download_button(
                    label="📄 Скачать CSV",
                    data=csv_data,
                    file_name=csv_filename,
                    mime="text/csv",
                    key="download_csv_btn"
                )
                st.success("✅ CSV файл готов к скачиванию!")
            except Exception as e:
                st.error(f"❌ Ошибка создания CSV файла: {str(e)}")
        
        with tab2:
            st.subheader("⚙️ Установка параметров товаров")
            
            # ========== РЕДАКТОР ПАРАМЕТРОВ ==========
            with st.expander("📝 Редактор параметров", expanded=False):
                st.markdown("### 📝 Редактор параметров")
                st.markdown("Управление параметрами товаров: добавление, редактирование, удаление параметров и их вариантов")
                
                # Инициализация param_options если нет
                if "param_options" not in st.session_state:
                    st.session_state["param_options"] = {}
                
                # Инициализация списка удаленных параметров
                if "deleted_params" not in st.session_state:
                    st.session_state["deleted_params"] = load_deleted_params_from_file()
                
                param_options = st.session_state.get("param_options", {})
                param_values = get_param_values()
                deleted_params = st.session_state.get("deleted_params", set())
                
                # Синхронизируем param_options с param_values - добавляем параметры из param_values, которых нет в param_options
                # НО исключаем параметры, которые были явно удалены пользователем
                # Также удаляем удаленные параметры из param_values и param_options, если они там есть
                if param_values:
                    # Сначала удаляем удаленные параметры напрямую из session_state
                    if deleted_params:
                        # Удаляем из param_options
                        if "param_options" in st.session_state:
                            params_to_remove_from_options = [p for p in st.session_state["param_options"].keys() if p in deleted_params]
                            for param_name in params_to_remove_from_options:
                                del st.session_state["param_options"][param_name]
                                if param_name in param_options:
                                    del param_options[param_name]
                        
                        # Удаляем из param_values
                        if "param_values" in st.session_state:
                            params_to_remove_from_values = [p for p in st.session_state["param_values"].keys() if p in deleted_params]
                            for param_name in params_to_remove_from_values:
                                del st.session_state["param_values"][param_name]
                    
                    # Перезагружаем param_values через функцию (она фильтрует удаленные)
                    param_values = get_param_values()
                    
                    # Теперь работаем только с отфильтрованными данными
                    params_to_remove = []
                    for param_name in list(param_values.keys()):
                        if param_name in deleted_params:
                            params_to_remove.append(param_name)
                    
                    for param_name in params_to_remove:
                        if param_name in param_values:
                            del param_values[param_name]
                        if param_name in param_options:
                            del param_options[param_name]
                    
                    if params_to_remove:
                        st.session_state["param_values"] = param_values
                        st.session_state["param_options"] = param_options
                    
                    # Теперь синхронизируем - добавляем параметры из param_values, которых нет в param_options
                    # param_values уже отфильтрован от удаленных параметров
                    for param_name in param_values.keys():
                        # Просто проверяем, что параметра нет в param_options
                        if param_name not in param_options:
                            # Добавляем параметр в param_options с пустым списком вариантов
                            param_options[param_name] = []
                            st.session_state["param_options"] = param_options
                
                # Обновляем локальную переменную после синхронизации
                param_options = st.session_state.get("param_options", {})
                # Фильтруем удаленные параметры из param_options для отображения
                param_options = {k: v for k, v in param_options.items() if k not in deleted_params}
                
                # Статистика
                col_stat1, col_stat2, col_stat3, col_stat4 = st.columns(4)
                with col_stat1:
                    st.metric("Всего параметров", len(param_options))
                with col_stat2:
                    total_options = sum(len(opts) if isinstance(opts, list) else 1 for opts in param_options.values())
                    st.metric("Всего вариантов", total_options)
                with col_stat3:
                    params_with_values = sum(1 for param_name in param_options.keys() if param_name in param_values and param_values[param_name])
                    st.metric("Параметров с данными", params_with_values)
                with col_stat4:
                    # Кнопка сохранения параметров
                    if st.button("💾 Сохранить все", type="primary", use_container_width=True):
                        # Сначала сохраняем deleted_params (это очистит все файлы)
                        if save_deleted_params_to_file():
                            # Затем сохраняем param_options и param_values
                            if save_param_values_to_file():
                                # Очищаем результаты массового анализа от удаленных параметров
                                if "mass_analysis_results" in st.session_state:
                                    st.session_state["mass_analysis_results"] = remove_deleted_params_from_mass_results(
                                        st.session_state["mass_analysis_results"]
                                    )
                                    save_mass_analysis_results(st.session_state["mass_analysis_results"])
                                st.success("✅ Все параметры и настройки сохранены!")
                                st.rerun()
                            else:
                                st.error("❌ Ошибка сохранения параметров")
                        else:
                            st.error("❌ Ошибка сохранения списка удаленных параметров")
                
                st.divider()
                
                # Улучшенный редактор параметров с фокусом на иерархию, удаление и скрытие
                st.markdown("---")
                st.markdown("### 🎯 Основные действия")
                
                # Главные действия вынесены вперед
                col_main1, col_main2, col_main3 = st.columns(3)
                with col_main1:
                    st.markdown("#### 🔗 Иерархия параметров")
                    if st.button("⚙️ Настроить иерархию", type="primary", use_container_width=True, key="goto_hierarchy_main"):
                        st.session_state["editor_mode"] = "🔗 Управление иерархией"
                        st.rerun()
                    st.caption("Назначьте параметры иерархии для анализа")
                
                with col_main2:
                    st.markdown("#### 👁️ Скрытие параметров")
                    excluded_count = len(st.session_state.get("excluded_params", []))
                    if st.button(f"👁️ Управлять видимостью ({excluded_count} скрыто)", use_container_width=True, key="goto_hide_main"):
                        st.session_state["editor_mode"] = "👁️ Скрыть параметры"
                        st.rerun()
                    st.caption("Скрыть параметры из таблицы и комбинаций")
                
                with col_main3:
                    st.markdown("#### 🗑️ Удаление параметров")
                    deleted_count = len(st.session_state.get("deleted_params", set()))
                    if st.button(f"🗑️ Управлять удалением ({deleted_count} удалено)", use_container_width=True, key="goto_delete_main"):
                        st.session_state["editor_mode"] = "🗑️ Удаление параметров"
                        st.rerun()
                    st.caption("Удалить параметры навсегда")
                
                st.markdown("---")
                
                # Режимы работы редактора (расширенные)
                editor_modes = ["🔗 Управление иерархией", "👁️ Скрыть параметры", "🗑️ Удаление параметров", "📋 Просмотр всех параметров", "➕ Добавить параметр"]
                current_editor_mode = st.session_state.get("editor_mode", "🔗 Управление иерархией")
                
                # Определяем индекс текущего режима
                if current_editor_mode in editor_modes:
                    default_index = editor_modes.index(current_editor_mode)
                else:
                    default_index = 0
                
                editor_mode = st.radio(
                    "📋 Дополнительные режимы:",
                    editor_modes,
                    horizontal=False,
                    key="editor_mode_radio",
                    index=default_index
                )
                
                # Обновляем editor_mode в session_state
                st.session_state["editor_mode"] = editor_mode
                
                if editor_mode == "📋 Просмотр всех параметров":
                    if param_options:
                        # Поиск параметров
                        search_param = st.text_input("🔍 Поиск параметра:", placeholder="Введите название параметра...", key="search_param_editor")
                        
                        # Фильтрация параметров
                        filtered_params = param_options.copy()
                        if search_param:
                            filtered_params = {k: v for k, v in param_options.items() if search_param.lower() in k.lower()}
                        
                        if filtered_params:
                            # Сортировка параметров
                            sort_order = st.selectbox("Сортировка:", ["По алфавиту", "По количеству вариантов", "По дате добавления"], key="sort_params")
                            
                            if sort_order == "По количеству вариантов":
                                filtered_params = dict(sorted(filtered_params.items(), key=lambda x: len(x[1]) if isinstance(x[1], list) else 0, reverse=True))
                            elif sort_order == "По алфавиту":
                                filtered_params = dict(sorted(filtered_params.items()))
                            
                            # Определяем иерархические параметры для выделения
                            # Иерархия параметров: Подтип - это логическая группировка для Рукав и Ворот
                            hierarchy_params = get_hierarchy_params()
                            subtype_params = get_subtype_params()  # Параметры, которые находятся внутри "Подтип"
                            visual_params = get_visual_params()
                            
                            # Разделяем параметры на категории для отображения
                            hierarchical_params_dict = {k: v for k, v in filtered_params.items() if k in hierarchy_params}
                            visual_params_dict = {k: v for k, v in filtered_params.items() if k in visual_params or any(vp in k for vp in visual_params)}
                            other_params_dict = {k: v for k, v in filtered_params.items() if k not in hierarchy_params and k not in visual_params_dict}
                            
                            # Сначала показываем иерархические параметры с выделением
                            if hierarchical_params_dict:
                                st.markdown("### 📊 Иерархические параметры (сегментация)")
                                st.info("💡 Эти параметры определяют иерархию сегментов: Тип → Подтип (Рукав, Ворот)")
                                
                                for param_name, options in hierarchical_params_dict.items():
                                    with st.container():
                                        # Выделяем иерархические параметры цветом
                                        st.markdown(f'<div style="background-color: #e3f2fd; padding: 10px; border-radius: 5px; border-left: 4px solid #2196F3; margin-bottom: 10px;">', unsafe_allow_html=True)
                                        col_header1, col_header2, col_header3 = st.columns([3, 1, 1])
                                        
                                        with col_header1:
                                            # Редактирование названия параметра
                                            if st.session_state.get(f"editing_param_name_{param_name}", False):
                                                new_name_col1, new_name_col2, new_name_col3 = st.columns([3, 1, 1])
                                                with new_name_col1:
                                                    new_param_name = st.text_input(
                                                        "Новое название:",
                                                        value=param_name,
                                                        key=f"new_name_input_{param_name}"
                                                    )
                                                with new_name_col2:
                                                    if st.button("💾", key=f"save_name_{param_name}"):
                                                        if new_param_name and new_param_name.strip() and new_param_name != param_name:
                                                            # Переименовываем параметр
                                                            if new_param_name not in param_options:
                                                                param_options[new_param_name] = param_options.pop(param_name)
                                                                # Обновляем в param_values
                                                                if param_name in param_values:
                                                                    param_values[new_param_name] = param_values.pop(param_name)
                                                                st.session_state["param_options"] = param_options
                                                                st.session_state["param_values"] = param_values
                                                                st.success(f"✅ Параметр переименован: '{param_name}' → '{new_param_name}'")
                                                                st.rerun()
                                                            else:
                                                                st.error(f"❌ Параметр '{new_param_name}' уже существует!")
                                                        else:
                                                            st.session_state[f"editing_param_name_{param_name}"] = False
                                                            st.rerun()
                                                with new_name_col3:
                                                    if st.button("❌", key=f"cancel_name_{param_name}"):
                                                        st.session_state[f"editing_param_name_{param_name}"] = False
                                                        st.rerun()
                                            else:
                                                options_count = len(options) if isinstance(options, list) else 0
                                                # Определяем категорию параметра
                                                if param_name in subtype_params:
                                                    category = "📊 Иерархический (Подтип)"
                                                elif param_name in hierarchy_params:
                                                    category = "📊 Иерархический"
                                                elif param_name in visual_params or any(vp in param_name for vp in visual_params):
                                                    category = "🎨 Визуальный"
                                                else:
                                                    category = "📋 Другой"
                                                st.markdown(f"### {category} - {param_name} ({options_count} вариантов)")
                                        
                                        with col_header2:
                                            if st.button("✏️ Редактировать", key=f"edit_param_{param_name}"):
                                                st.session_state[f"editing_param_name_{param_name}"] = True
                                                st.rerun()
                                        
                                        with col_header3:
                                            if st.button("🗑️ Удалить", key=f"delete_param_{param_name}", type="secondary"):
                                                # Удаляем параметр напрямую из session_state
                                                if param_name in st.session_state.get("param_options", {}):
                                                    del st.session_state["param_options"][param_name]
                                                if param_name in st.session_state.get("param_values", {}):
                                                    del st.session_state["param_values"][param_name]
                                                
                                                # Также удаляем из локальных переменных
                                                if param_name in param_options:
                                                    del param_options[param_name]
                                                if param_name in param_values:
                                                    del param_values[param_name]
                                                
                                                # ВАЖНО: Добавляем в список удаленных параметров ТОЛЬКО для текущего проекта
                                                # Инициализируем deleted_params если нужно
                                                if "deleted_params" not in st.session_state:
                                                    st.session_state["deleted_params"] = set()
                                                
                                                # Убеждаемся, что это set
                                                if not isinstance(st.session_state["deleted_params"], set):
                                                    st.session_state["deleted_params"] = set(st.session_state["deleted_params"])
                                                
                                                # Добавляем параметр в список удаленных ТОЛЬКО для текущего проекта
                                                st.session_state["deleted_params"].add(param_name)
                                                
                                                # Сохраняем удаленные параметры ТОЛЬКО для текущего проекта
                                                # Это очистит параметры только из файла текущего проекта
                                                if save_deleted_params_to_file():
                                                    # Удаляем параметр из результатов массового анализа
                                                    if "mass_analysis_results" in st.session_state:
                                                        st.session_state["mass_analysis_results"] = remove_deleted_params_from_mass_results(
                                                            st.session_state["mass_analysis_results"]
                                                        )
                                                        # Сохраняем очищенные результаты
                                                        save_mass_analysis_results(st.session_state["mass_analysis_results"])
                                                    
                                                    # Сохраняем очищенные параметры в файлы текущего проекта
                                                    if save_param_values_to_file():
                                                        st.success(f"✅ Параметр '{param_name}' удален из текущего проекта!")
                                                    else:
                                                        st.warning(f"⚠️ Параметр '{param_name}' удален из памяти, но возникла ошибка при сохранении в файл")
                                                else:
                                                    st.error(f"❌ Ошибка сохранения удаленных параметров для проекта!")
                                                
                                                # Принудительно удаляем параметр из session_state еще раз (на всякий случай)
                                                if param_name in st.session_state.get("param_options", {}):
                                                    del st.session_state["param_options"][param_name]
                                                if param_name in st.session_state.get("param_values", {}):
                                                    del st.session_state["param_values"][param_name]
                                                
                                                st.rerun()
                                    
                                    # Отображение вариантов
                                    if isinstance(options, list) and options:
                                        st.markdown("**Варианты значений:**")
                                        
                                        # Редактируемая таблица вариантов
                                        for idx, option in enumerate(options):
                                            col_opt1, col_opt2, col_opt3, col_opt4 = st.columns([4, 1, 1, 1])
                                            
                                            with col_opt1:
                                                if st.session_state.get(f"editing_option_{param_name}_{idx}", False):
                                                    edited_opt = st.text_input(
                                                        "Редактировать:",
                                                        value=option,
                                                        key=f"edit_opt_input_{param_name}_{idx}"
                                                    )
                                                else:
                                                    st.write(f"• {option}")
                                            
                                            with col_opt2:
                                                if st.session_state.get(f"editing_option_{param_name}_{idx}", False):
                                                    if st.button("💾", key=f"save_opt_{param_name}_{idx}"):
                                                        if edited_opt and edited_opt.strip():
                                                            options[idx] = edited_opt.strip()
                                                            st.session_state["param_options"] = param_options
                                                            st.session_state[f"editing_option_{param_name}_{idx}"] = False
                                                            if save_param_values_to_file():
                                                                st.success("✅ Вариант обновлен!")
                                                            st.rerun()
                                                else:
                                                    if st.button("✏️", key=f"edit_opt_{param_name}_{idx}"):
                                                        st.session_state[f"editing_option_{param_name}_{idx}"] = True
                                                        st.rerun()
                                            
                                            with col_opt3:
                                                if st.session_state.get(f"editing_option_{param_name}_{idx}", False):
                                                    if st.button("❌", key=f"cancel_opt_{param_name}_{idx}"):
                                                        st.session_state[f"editing_option_{param_name}_{idx}"] = False
                                                        st.rerun()
                                            
                                            with col_opt4:
                                                if st.button("🗑️", key=f"del_opt_{param_name}_{idx}"):
                                                    options.pop(idx)
                                                    if not options:
                                                        # Если вариантов не осталось, удаляем параметр
                                                        if param_name in param_options:
                                                            del param_options[param_name]
                                                        if param_name in param_values:
                                                            del param_values[param_name]
                                                        
                                                        # Добавляем в список удаленных параметров
                                                        if "deleted_params" not in st.session_state:
                                                            st.session_state["deleted_params"] = load_deleted_params_from_file()
                                                        
                                                        # Убеждаемся, что это set
                                                        if not isinstance(st.session_state["deleted_params"], set):
                                                            st.session_state["deleted_params"] = set(st.session_state["deleted_params"])
                                                        
                                                        # Добавляем параметр в список удаленных
                                                        st.session_state["deleted_params"].add(param_name)
                                                        
                                                        # Сохраняем список удаленных параметров ТОЛЬКО для текущего проекта
                                                        if save_deleted_params_to_file():
                                                            # Удаляем параметр из результатов массового анализа
                                                            if "mass_analysis_results" in st.session_state:
                                                                st.session_state["mass_analysis_results"] = remove_deleted_params_from_mass_results(
                                                                    st.session_state["mass_analysis_results"]
                                                                )
                                                                # Сохраняем очищенные результаты
                                                                save_mass_analysis_results(st.session_state["mass_analysis_results"])
                                                        
                                                            # Сохраняем очищенные параметры в файлы
                                                            if save_param_values_to_file():
                                                                st.success("✅ Параметр удален (варианты закончились)!")
                                                            else:
                                                                st.warning("⚠️ Параметр удален, но не сохранен в файл")
                                                        else:
                                                            st.error("❌ Ошибка сохранения списка удаленных параметров!")
                                                    else:
                                                        # Вариантов еще есть, просто обновляем список
                                                        st.session_state["param_options"] = param_options
                                                        st.session_state["param_values"] = param_values
                                                        if save_param_values_to_file():
                                                            st.success("✅ Вариант удален!")
                                                        st.rerun()
                                        
                                        # Добавление нового варианта
                                        col_add1, col_add2 = st.columns([4, 1])
                                        with col_add1:
                                            new_opt = st.text_input(
                                                f"Добавить вариант в '{param_name}':",
                                                placeholder="Введите новый вариант",
                                                key=f"new_opt_{param_name}"
                                            )
                                        with col_add2:
                                            if st.button("➕", key=f"add_opt_{param_name}"):
                                                if new_opt and new_opt.strip():
                                                    if new_opt.strip() not in options:
                                                        options.append(new_opt.strip())
                                                        st.session_state["param_options"] = param_options
                                                        if save_param_values_to_file():
                                                            st.success(f"✅ Вариант '{new_opt.strip()}' добавлен!")
                                                        st.rerun()
                                                    else:
                                                        st.warning("Этот вариант уже существует")
                                    else:
                                        st.info("ℹ️ Варианты не указаны - нейросеть определит значение самостоятельно")
                                    
                                    st.divider()
                                    st.markdown('</div>', unsafe_allow_html=True)
                            
                            # Затем показываем визуальные параметры
                            if visual_params_dict:
                                st.markdown("### 🎨 Визуальные параметры (анализируются в контексте иерархии)")
                                st.info("💡 Эти параметры анализируются только после определения иерархии сегментов")
                                
                                for param_name, options in visual_params_dict.items():
                                    with st.container():
                                        st.markdown(f'<div style="background-color: #fff3e0; padding: 10px; border-radius: 5px; border-left: 4px solid #FF9800; margin-bottom: 10px;">', unsafe_allow_html=True)
                                        col_header1, col_header2, col_header3 = st.columns([3, 1, 1])
                                        
                                        with col_header1:
                                            options_count = len(options) if isinstance(options, list) else 0
                                            category = "🎨 Визуальный"
                                            st.markdown(f"### {category} - {param_name} ({options_count} вариантов)")
                                        
                                        with col_header2:
                                            if st.button("✏️ Редактировать", key=f"edit_param_{param_name}"):
                                                st.session_state[f"editing_param_name_{param_name}"] = True
                                                st.rerun()
                                        
                                        with col_header3:
                                            if st.button("🗑️ Удалить", key=f"delete_param_{param_name}", type="secondary"):
                                                if param_name in param_options:
                                                    del param_options[param_name]
                                                if param_name in param_values:
                                                    del param_values[param_name]
                                                st.session_state["param_options"] = param_options
                                                st.session_state["param_values"] = param_values
                                                if save_param_values_to_file():
                                                    st.success(f"✅ Параметр '{param_name}' удален!")
                                                st.rerun()
                                        
                                        # Отображение вариантов (копируем логику из иерархических параметров)
                                        if isinstance(options, list) and options:
                                            st.markdown("**Варианты значений:**")
                                            for idx, option in enumerate(options):
                                                col_opt1, col_opt2, col_opt3, col_opt4 = st.columns([4, 1, 1, 1])
                                                
                                                with col_opt1:
                                                    if st.session_state.get(f"editing_option_{param_name}_{idx}", False):
                                                        edited_opt = st.text_input(
                                                            "Редактировать:",
                                                            value=option,
                                                            key=f"edit_opt_input_{param_name}_{idx}"
                                                        )
                                                    else:
                                                        st.write(f"• {option}")
                                                
                                                with col_opt2:
                                                    if st.session_state.get(f"editing_option_{param_name}_{idx}", False):
                                                        if st.button("💾", key=f"save_opt_{param_name}_{idx}"):
                                                            if edited_opt and edited_opt.strip():
                                                                options[idx] = edited_opt.strip()
                                                                st.session_state["param_options"] = param_options
                                                                st.session_state[f"editing_option_{param_name}_{idx}"] = False
                                                                if save_param_values_to_file():
                                                                    st.success("✅ Вариант обновлен!")
                                                                st.rerun()
                                                    else:
                                                        if st.button("✏️", key=f"edit_opt_{param_name}_{idx}"):
                                                            st.session_state[f"editing_option_{param_name}_{idx}"] = True
                                                            st.rerun()
                                                
                                                with col_opt3:
                                                    if st.session_state.get(f"editing_option_{param_name}_{idx}", False):
                                                        if st.button("❌", key=f"cancel_opt_{param_name}_{idx}"):
                                                            st.session_state[f"editing_option_{param_name}_{idx}"] = False
                                                            st.rerun()
                                                
                                                with col_opt4:
                                                    if st.button("🗑️", key=f"del_opt_{param_name}_{idx}"):
                                                        options.pop(idx)
                                                        if not options:
                                                            if param_name in param_options:
                                                                del param_options[param_name]
                                                            if param_name in param_values:
                                                                del param_values[param_name]
                                                        st.session_state["param_options"] = param_options
                                                        st.session_state["param_values"] = param_values
                                                        if save_param_values_to_file():
                                                            st.success("✅ Вариант удален!")
                                                        st.rerun()
                                            
                                            # Добавление нового варианта
                                            col_add1, col_add2 = st.columns([4, 1])
                                            with col_add1:
                                                new_opt = st.text_input(
                                                    f"Добавить вариант в '{param_name}':",
                                                    placeholder="Введите новый вариант",
                                                    key=f"new_opt_{param_name}"
                                                )
                                            with col_add2:
                                                if st.button("➕", key=f"add_opt_{param_name}"):
                                                    if new_opt and new_opt.strip():
                                                        if new_opt.strip() not in options:
                                                            options.append(new_opt.strip())
                                                            st.session_state["param_options"] = param_options
                                                            if save_param_values_to_file():
                                                                st.success(f"✅ Вариант '{new_opt.strip()}' добавлен!")
                                                            st.rerun()
                                                        else:
                                                            st.warning("Этот вариант уже существует")
                                        else:
                                            st.info("ℹ️ Варианты не указаны - нейросеть определит значение самостоятельно")
                                        
                                        st.divider()
                                        st.markdown('</div>', unsafe_allow_html=True)
                            
                            # Затем показываем остальные параметры
                            if other_params_dict:
                                st.markdown("### 📋 Дополнительные параметры")
                                
                                for param_name, options in other_params_dict.items():
                                    with st.container():
                                        col_header1, col_header2, col_header3 = st.columns([3, 1, 1])
                                        
                                        with col_header1:
                                            options_count = len(options) if isinstance(options, list) else 0
                                            category = "📋 Другой"
                                            st.markdown(f"### {category} - {param_name} ({options_count} вариантов)")
                                        
                                        with col_header2:
                                            if st.button("✏️ Редактировать", key=f"edit_param_{param_name}"):
                                                st.session_state[f"editing_param_name_{param_name}"] = True
                                                st.rerun()
                                        
                                        with col_header3:
                                            if st.button("🗑️ Удалить", key=f"delete_param_{param_name}", type="secondary"):
                                                if param_name in param_options:
                                                    del param_options[param_name]
                                                if param_name in param_values:
                                                    del param_values[param_name]
                                                st.session_state["param_options"] = param_options
                                                st.session_state["param_values"] = param_values
                                                if save_param_values_to_file():
                                                    st.success(f"✅ Параметр '{param_name}' удален!")
                                                st.rerun()
                                        
                                        # Отображение вариантов (аналогично выше)
                                        if isinstance(options, list) and options:
                                            st.markdown("**Варианты значений:**")
                                            for idx, option in enumerate(options):
                                                col_opt1, col_opt2, col_opt3, col_opt4 = st.columns([4, 1, 1, 1])
                                                
                                                with col_opt1:
                                                    if st.session_state.get(f"editing_option_{param_name}_{idx}", False):
                                                        edited_opt = st.text_input(
                                                            "Редактировать:",
                                                            value=option,
                                                            key=f"edit_opt_input_{param_name}_{idx}"
                                                        )
                                                    else:
                                                        st.write(f"• {option}")
                                                
                                                with col_opt2:
                                                    if st.session_state.get(f"editing_option_{param_name}_{idx}", False):
                                                        if st.button("💾", key=f"save_opt_{param_name}_{idx}"):
                                                            if edited_opt and edited_opt.strip():
                                                                options[idx] = edited_opt.strip()
                                                                st.session_state["param_options"] = param_options
                                                                st.session_state[f"editing_option_{param_name}_{idx}"] = False
                                                                if save_param_values_to_file():
                                                                    st.success("✅ Вариант обновлен!")
                                                                st.rerun()
                                                    else:
                                                        if st.button("✏️", key=f"edit_opt_{param_name}_{idx}"):
                                                            st.session_state[f"editing_option_{param_name}_{idx}"] = True
                                                            st.rerun()
                                                
                                                with col_opt3:
                                                    if st.session_state.get(f"editing_option_{param_name}_{idx}", False):
                                                        if st.button("❌", key=f"cancel_opt_{param_name}_{idx}"):
                                                            st.session_state[f"editing_option_{param_name}_{idx}"] = False
                                                            st.rerun()
                                                
                                                with col_opt4:
                                                    if st.button("🗑️", key=f"del_opt_{param_name}_{idx}"):
                                                        options.pop(idx)
                                                        if not options:
                                                            if param_name in param_options:
                                                                del param_options[param_name]
                                                            if param_name in param_values:
                                                                del param_values[param_name]
                                                        st.session_state["param_options"] = param_options
                                                        st.session_state["param_values"] = param_values
                                                        if save_param_values_to_file():
                                                            st.success("✅ Вариант удален!")
                                                        st.rerun()
                                            
                                            # Добавление нового варианта
                                            col_add1, col_add2 = st.columns([4, 1])
                                            with col_add1:
                                                new_opt = st.text_input(
                                                    f"Добавить вариант в '{param_name}':",
                                                    placeholder="Введите новый вариант",
                                                    key=f"new_opt_{param_name}"
                                                )
                                            with col_add2:
                                                if st.button("➕", key=f"add_opt_{param_name}"):
                                                    if new_opt and new_opt.strip():
                                                        if new_opt.strip() not in options:
                                                            options.append(new_opt.strip())
                                                            st.session_state["param_options"] = param_options
                                                            if save_param_values_to_file():
                                                                st.success(f"✅ Вариант '{new_opt.strip()}' добавлен!")
                                                            st.rerun()
                                                        else:
                                                            st.warning("Этот вариант уже существует")
                                        else:
                                            st.info("ℹ️ Варианты не указаны - нейросеть определит значение самостоятельно")
                                        
                                        st.divider()
                        else:
                            st.info("🔍 Параметры не найдены по запросу")
                    else:
                        st.info("📝 Параметры еще не добавлены. Используйте режим '➕ Добавить новый параметр'")
                
                elif editor_mode == "➕ Добавить параметр":
                    st.markdown("### ➕ Добавить новый параметр")
                    
                    # Готовые шаблоны параметров (опционально)
                    with st.expander("📋 Использовать шаблон", expanded=False):
                        param_templates = {
                        "Комплект": ["Комплект", "Один"],
                        "Цвет": [
                            "Белый", "Черный", "Серый", "Синий", "Красный", "Зеленый", "Розовый", "Бежевый",
                            "Черно-белый", "Бело-черный", "Сине-белый", "Бело-синий",
                            "Красно-белый", "Бело-красный", "Черно-серый", "Серо-черный"
                        ],
                        "Длина": ["Короткая", "Средняя", "Длинная", "Мини", "Макси", "Миди", "Анкл"],
                        "Пуговицы": ["С пуговицами", "Без пуговиц", "На молнии", "На липучке", "На кнопках", "На шнурке"],
                        "Материал": ["Хлопок", "Полиэстер", "Шерсть", "Лен", "Джинс", "Кожа", "Замша", "Трикотаж"],
                        "Размер": ["XS", "S", "M", "L", "XL", "XXL", "XXXL"],
                        "Сезон": ["Лето", "Зима", "Весна", "Осень", "Демисезон"],
                        "Стиль": ["Классический", "Спортивный", "Повседневный", "Деловой", "Вечерний", "Романтический"],
                        "Тип": []  # Без вариантов
                    }
                    
                        col_template1, col_template2 = st.columns([2, 1])
                        with col_template1:
                            template_choice = st.selectbox(
                                "Выберите шаблон или создать новый:",
                                ["Создать новый параметр"] + list(param_templates.keys()),
                                key="template_choice_editor"
                            )
                        
                        with col_template2:
                            if template_choice != "Создать новый параметр":
                                if st.button("📋 Применить шаблон", key="apply_template_btn"):
                                    st.session_state["temp_param_name_editor"] = template_choice
                                    st.session_state["temp_param_options_editor"] = " / ".join(param_templates[template_choice]) if param_templates[template_choice] else ""
                                    st.rerun()
                    
                    col_name, col_options = st.columns([1, 2])
                    with col_name:
                        param_name_new = st.text_input(
                            "Название параметра:",
                            value=st.session_state.get("temp_param_name_editor", ""),
                            placeholder="Например: Тип, Цвет, Материал",
                            key="param_name_new_add"
                        )
                    
                    with col_options:
                        param_options_new = st.text_area(
                            "Варианты (через слэш /, можно оставить пустым):",
                            value=st.session_state.get("temp_param_options_editor", ""),
                            placeholder="Красный / Синий / Зеленый\n(или оставьте пустым для свободного ввода)",
                            height=100,
                            key="param_options_new_add"
                        )
                    
                    col_add_btn, col_clear_btn = st.columns([1, 1])
                    with col_add_btn:
                        if st.button("➕ Добавить параметр", type="primary", use_container_width=True, key="add_param_btn_main"):
                            if param_name_new and param_name_new.strip():
                                # Очищаем и разбираем варианты
                                if param_options_new:
                                    options = [opt.strip() for opt in param_options_new.split("/") if opt.strip()]
                                else:
                                    options = []
                                
                                # Проверяем, не существует ли уже такой параметр
                                if param_name_new.strip() in param_options:
                                    st.error(f"❌ Параметр '{param_name_new.strip()}' уже существует!")
                                else:
                                    # Добавляем параметр
                                    param_options[param_name_new.strip()] = options
                                    if param_name_new.strip() not in param_values:
                                        param_values[param_name_new.strip()] = {}
                                    
                                    st.session_state["param_options"] = param_options
                                    st.session_state["param_values"] = param_values
                                    
                                    if save_param_values_to_file():
                                        st.success(f"✅ Параметр '{param_name_new.strip()}' добавлен! ({len(options)} вариантов)")
                                        # Очищаем поля
                                        if "temp_param_name_editor" in st.session_state:
                                            del st.session_state["temp_param_name_editor"]
                                        if "temp_param_options_editor" in st.session_state:
                                            del st.session_state["temp_param_options_editor"]
                                        st.rerun()
                            else:
                                st.warning("⚠️ Введите название параметра")
                    
                    with col_clear_btn:
                        if st.button("🗑️ Очистить", use_container_width=True, key="clear_param_btn_main"):
                            if "temp_param_name_editor" in st.session_state:
                                del st.session_state["temp_param_name_editor"]
                            if "temp_param_options_editor" in st.session_state:
                                del st.session_state["temp_param_options_editor"]
                            st.rerun()
                
                elif editor_mode == "🔗 Управление иерархией":
                    st.markdown("### 🔗 Управление иерархией параметров")
                    st.info("💡 Назначьте параметрам уровни иерархии: 1-й уровень, 2-й уровень, 3-й уровень и т.д. Порядок важен для анализа.")
                    
                    # ВАЖНО: Убеждаемся, что параметры загружены из файла, если их нет в session_state
                    if not st.session_state.get("param_values") and not st.session_state.get("param_options"):
                        load_param_values_from_file()
                    
                    # Получаем все доступные параметры из всех возможных источников
                    # 1. Из session_state напрямую (до фильтрации)
                    param_values_raw = st.session_state.get("param_values", {})
                    param_options_dict = st.session_state.get("param_options", {})
                    
                    # 2. Также получаем через get_param_values() (может содержать параметры, загруженные из файла)
                    param_values_dict = get_param_values()
                    
                    # Получаем список удаленных параметров
                    deleted_params = st.session_state.get("deleted_params", set())
                    if not isinstance(deleted_params, set):
                        deleted_params = set(deleted_params) if deleted_params else set()
                    
                    # Получаем список исключенных (скрытых) параметров - они ДОЛЖНЫ быть в списке для назначения иерархии
                    excluded_params = set(st.session_state.get("excluded_params", []))
                    
                    # Список служебных параметров, которые НЕ являются параметрами товаров и должны быть исключены
                    service_params = {
                        "Дней отсутствовал", "Дней в наличии", "Доля дней в наличии", 
                        "Остатки на конец периода", "Остаток на конец периода", "Остатки", "Остаток",
                        "Дней в продаже", "Дни в наличии", "Дни в продаже",
                        "Дней отсутствовал", "Дни отсутствовал", "Дни отсутствовали",
                        "Упущенные заказы", "Упущенная выручка", "Выручка", "Заказы"
                    }
                    
                    # Загружаем текущую иерархию (нужно для включения параметров из иерархии)
                    if "hierarchy_params" not in st.session_state:
                        load_hierarchy_config()
                    current_hierarchy = get_hierarchy_params()
                    
                    # Формируем словарь всех параметров, исключая удаленные и служебные
                    all_params_dict = {}
                    
                    # Собираем все уникальные имена параметров из всех источников
                    all_param_names = set()
                    
                    # Добавляем параметры из param_options (включая excluded_params)
                    for param_name in param_options_dict.keys():
                        if param_name and param_name not in deleted_params and param_name not in service_params:
                            all_param_names.add(param_name)
                    
                    # Добавляем параметры из param_values_raw (session_state напрямую, включая excluded_params)
                    for param_name in param_values_raw.keys():
                        if param_name and param_name not in deleted_params and param_name not in service_params:
                            all_param_names.add(param_name)
                    
                    # Добавляем параметры из param_values_dict (через get_param_values - может быть больше параметров, включая excluded_params)
                    for param_name in param_values_dict.keys():
                        if param_name and param_name not in deleted_params and param_name not in service_params:
                            all_param_names.add(param_name)
                    
                    # ВАЖНО: Добавляем excluded_params (скрытые параметры) - они должны быть видны для назначения иерархии
                    for param_name in excluded_params:
                        if param_name and param_name not in deleted_params and param_name not in service_params:
                            all_param_names.add(param_name)
                    
                    # ВАЖНО: Добавляем параметры из текущей иерархии, даже если их нет в param_values/param_options
                    # Это нужно для того, чтобы параметры, которые были назначены в иерархии, но еще не имеют значений,
                    # все равно отображались в списке для назначения уровней
                    for param_name in current_hierarchy:
                        if param_name and param_name not in deleted_params and param_name not in service_params:
                            all_param_names.add(param_name)
                    
                    # НЕ добавляем параметры из иерархии по умолчанию - для каждого проекта своя иерархия
                    # Параметры должны быть назначены пользователем для конкретного проекта
                    
                    # Также добавляем визуальные параметры по умолчанию
                    default_visual = get_visual_params()
                    for param_name in default_visual:
                        if param_name and param_name not in deleted_params and param_name not in service_params:
                            all_param_names.add(param_name)
                    
                    # Формируем all_params_dict со всеми параметрами, исключая удаленные
                    for param_name in all_param_names:
                        # Дополнительная проверка: исключаем удаленные параметры
                        if param_name in deleted_params:
                            continue
                        if param_name in param_options_dict:
                            all_params_dict[param_name] = param_options_dict[param_name]
                        elif param_name in param_values_raw or param_name in param_values_dict:
                            # Если параметр есть в param_values, но нет в param_options, создаем пустой список
                            all_params_dict[param_name] = []
                        else:
                            # Параметр есть только в иерархии или еще не имеет значений - создаем пустой список
                            all_params_dict[param_name] = []
                    
                    # ДОПОЛНИТЕЛЬНАЯ ПРОВЕРКА: Убеждаемся, что все параметры из all_param_names добавлены в all_params_dict
                    for param_name in all_param_names:
                        if param_name not in deleted_params and param_name not in service_params:
                            if param_name not in all_params_dict:
                                # Если параметр не был добавлен, добавляем его с пустым списком
                                all_params_dict[param_name] = []
                    
                    # Инициализируем hierarchy_assignments для всех параметров
                    hierarchy_assignments = {}
                    
                    # Инициализируем на основе текущей иерархии, исключая удаленные параметры
                    for i, param_name in enumerate(current_hierarchy):
                        if param_name not in deleted_params:
                            level = i + 1
                            hierarchy_assignments[param_name] = level
                    
                    # Максимальное количество уровней (можно расширить)
                    max_levels = 5
                    
                    # Отладочная информация (можно убрать позже)
                    if not all_params_dict:
                        st.warning("⚠️ Нет доступных параметров. Добавьте параметры в разделе '➕ Добавить параметр'.")
                        st.info("💡 Параметры можно добавить вручную или они будут автоматически извлечены при заполнении значений.")
                        
                        # Показываем отладочную информацию
                        with st.expander("🔍 Отладочная информация", expanded=False):
                            st.write(f"**param_values_raw:** {len(param_values_raw)} параметров")
                            st.write(f"**param_options_dict:** {len(param_options_dict)} параметров")
                            st.write(f"**param_values_dict (get_param_values):** {len(param_values_dict)} параметров")
                            st.write(f"**current_hierarchy:** {current_hierarchy}")
                            st.write(f"**deleted_params:** {list(deleted_params)}")
                            st.write(f"**all_param_names:** {list(all_param_names)}")
                        
                        # Создаем пустой список для дальнейшей работы
                        params_list = []
                    else:
                        st.markdown("#### 📊 Назначение уровней иерархии")
                        st.write("Выберите уровень для каждого параметра (1-й уровень, 2-й уровень, 3-й уровень и т.д.):")
                        
                        # Разделяем параметры на колонки для удобства
                        # Фильтруем удаленные и служебные параметры для гарантии, что они не отображаются
                        params_list = sorted([p for p in all_params_dict.keys() if p not in deleted_params and p not in service_params])
                        num_cols = 3
                        params_per_col = (len(params_list) + num_cols - 1) // num_cols
                        
                        cols = st.columns(num_cols)
                        
                        for idx, param_name in enumerate(params_list):
                            # Дополнительная проверка: пропускаем удаленные и служебные параметры
                            if param_name in deleted_params or param_name in service_params:
                                continue
                            
                            col_idx = idx // params_per_col
                            if col_idx >= num_cols:
                                col_idx = num_cols - 1
                            
                            with cols[col_idx]:
                                current_level = hierarchy_assignments.get(param_name, 0)
                                
                                # Создаем селектбокс для выбора уровня
                                level_options = ["Не назначен"] + [f"{i}-й уровень" for i in range(1, max_levels + 1)]
                                
                                # Вычисляем индекс с проверкой границ
                                if current_level > 0 and current_level <= max_levels:
                                    default_index = current_level  # current_level соответствует индексу в level_options
                                else:
                                    default_index = 0  # "Не назначен"
                                
                                # Дополнительная проверка границ для безопасности
                                if default_index >= len(level_options):
                                    default_index = 0
                                
                                selectbox_key = f"hierarchy_level_{param_name}"
                                selected = st.selectbox(
                                    f"**{param_name}**",
                                    level_options,
                                    index=default_index,
                                    key=selectbox_key,
                                    help=f"Назначьте уровень иерархии для параметра '{param_name}'"
                                )
                                
                                # Сохраняем выбранное значение в hierarchy_assignments
                                # Значение автоматически сохраняется в st.session_state[selectbox_key]
                                # Но мы также обновляем локальную переменную для отображения
                                if selected == "Не назначен":
                                    hierarchy_assignments[param_name] = 0
                                else:
                                    level_num = int(selected.split("-")[0])
                                    hierarchy_assignments[param_name] = level_num
                    
                    # Показываем разделитель только если есть параметры
                    if all_params_dict:
                        st.divider()
                    
                    # Обновляем hierarchy_assignments из selectbox'ов для отображения текущей иерархии
                    # Это нужно для правильного отображения текущей иерархии
                    if all_params_dict:
                        for param_name in all_params_dict.keys():
                            selectbox_key = f"hierarchy_level_{param_name}"
                            if selectbox_key in st.session_state:
                                selected_value = st.session_state[selectbox_key]
                                if selected_value == "Не назначен" or not selected_value:
                                    hierarchy_assignments[param_name] = 0
                                else:
                                    try:
                                        level_num = int(selected_value.split("-")[0])
                                        hierarchy_assignments[param_name] = level_num
                                    except (ValueError, IndexError):
                                        hierarchy_assignments[param_name] = 0
                    
                    # Показываем текущую иерархию (вне зависимости от наличия параметров)
                    st.markdown("#### 📋 Текущая иерархия")
                    
                    # Группируем параметры по уровням, исключая удаленные
                    levels_dict = {}
                    for param_name, level in hierarchy_assignments.items():
                        # Пропускаем удаленные параметры
                        if param_name not in deleted_params and level > 0:
                            if level not in levels_dict:
                                levels_dict[level] = []
                            levels_dict[level].append(param_name)
                    
                    if levels_dict:
                        # Показываем уровни по порядку
                        for level in sorted(levels_dict.keys()):
                            params_at_level = sorted(levels_dict[level])
                            st.write(f"**{level}-й уровень:** {', '.join(params_at_level)}")
                        
                        # Показываем полную иерархию
                        all_hierarchy_params = []
                        for level in sorted(levels_dict.keys()):
                            all_hierarchy_params.extend(sorted(levels_dict[level]))
                        
                        if all_hierarchy_params:
                            hierarchy_str = " → ".join(all_hierarchy_params)
                            st.success(f"✅ Иерархия: {hierarchy_str}")
                    else:
                        if all_params_dict:
                            st.warning("⚠️ Не назначено ни одного уровня. Выберите уровень для параметров выше.")
                        else:
                            st.info("ℹ️ Добавьте параметры, чтобы назначить им уровни иерархии.")
                    
                    st.divider()
                    
                    # Кнопки сохранения
                    col_save1, col_save2 = st.columns([1, 1])
                    
                    with col_save1:
                        if st.button("💾 Сохранить иерархию", type="primary", use_container_width=True, key="save_hierarchy_new"):
                            # Пересобираем hierarchy_assignments из текущих значений selectbox'ов
                            hierarchy_assignments_save = {}
                            
                            if all_params_dict:
                                for param_name in all_params_dict.keys():
                                    selectbox_key = f"hierarchy_level_{param_name}"
                                    # Получаем выбранное значение из session_state
                                    # В Streamlit selectbox сохраняет выбранный элемент (строку), а не индекс
                                    if selectbox_key in st.session_state:
                                        selected_value = st.session_state[selectbox_key]
                                        # selected_value - это строка (выбранный элемент из списка)
                                        if selected_value == "Не назначен" or not selected_value:
                                            hierarchy_assignments_save[param_name] = 0
                                        else:
                                            try:
                                                level_num = int(selected_value.split("-")[0])
                                                hierarchy_assignments_save[param_name] = level_num
                                            except (ValueError, IndexError):
                                                hierarchy_assignments_save[param_name] = 0
                                    else:
                                        # Если значения нет в session_state, используем текущее из hierarchy_assignments
                                        hierarchy_assignments_save[param_name] = hierarchy_assignments.get(param_name, 0)
                            else:
                                # Если нет параметров, используем текущие значения
                                hierarchy_assignments_save = hierarchy_assignments.copy()
                            
                            # Группируем параметры по уровням, исключая удаленные
                            levels_dict_save = {}
                            for param_name, level in hierarchy_assignments_save.items():
                                # Пропускаем удаленные параметры
                                if param_name not in deleted_params and level > 0:
                                    if level not in levels_dict_save:
                                        levels_dict_save[level] = []
                                    levels_dict_save[level].append(param_name)
                            
                            # Собираем параметры по уровням (только назначенные и не удаленные)
                            new_hierarchy = []
                            for level in sorted(levels_dict_save.keys()):
                                new_hierarchy.extend(sorted(levels_dict_save[level]))
                            
                            # Сохраняем иерархию
                            st.session_state["hierarchy_params"] = new_hierarchy
                            
                            # Для обратной совместимости сохраняем subtype и visual
                            # (можно будет использовать в будущем)
                            if "subtype_params" not in st.session_state:
                                st.session_state["subtype_params"] = []
                            if "visual_params" not in st.session_state:
                                st.session_state["visual_params"] = []
                            
                            if save_hierarchy_config():
                                if new_hierarchy:
                                    st.success(f"✅ Иерархия сохранена! ({len(new_hierarchy)} параметров на {len(levels_dict_save)} уровнях)")
                                else:
                                    st.success("✅ Иерархия очищена (все параметры сняты с уровней)")
                                # Перезагружаем страницу, чтобы изменения применились ко всем разделам,
                                # включая "📊 Анализ комбинаций иерархических параметров"
                                st.rerun()
                            else:
                                st.warning("⚠️ Иерархия сохранена в памяти, но не в файл")
                                # Даже если файл не сохранен, перезагружаем страницу для применения изменений в памяти
                                st.rerun()
                    
                    with col_save2:
                        if st.button("🔄 Очистить все уровни", use_container_width=True, key="clear_hierarchy_new"):
                            st.session_state["hierarchy_params"] = []
                            if save_hierarchy_config():
                                st.success("✅ Все уровни очищены!")
                            else:
                                st.warning("⚠️ Уровни очищены в памяти, но не в файл")
                            # Перезагружаем страницу, чтобы изменения применились ко всем разделам
                            st.rerun()
                    
                elif editor_mode == "👁️ Скрыть параметры":
                    st.markdown("### 👁️ Управление видимостью параметров")
                    st.info("💡 Скрытые параметры не будут отображаться в таблице и не будут учитываться при формировании топ комбинаций. Товары останутся в таблице.")
                    
                    # Получаем все параметры
                    param_values_dict = get_param_values()
                    param_options_dict = st.session_state.get("param_options", {})
                    all_params_dict = param_options_dict.copy()
                    for param_name, param_data in param_values_dict.items():
                        if param_name not in all_params_dict:
                            all_params_dict[param_name] = []
                    
                    if not all_params_dict:
                        st.warning("⚠️ Нет доступных параметров для скрытия.")
                    else:
                        # Получаем текущие скрытые параметры
                        current_excluded_params = st.session_state.get("excluded_params", [])
                        
                        # Загружаем настройки исключения, если еще не загружены
                        if "excluded_params_loaded" not in st.session_state:
                            load_excluded_params_settings()
                            st.session_state["excluded_params_loaded"] = True
                            current_excluded_params = st.session_state.get("excluded_params", [])
                        
                        st.markdown("#### Выберите параметры для скрытия:")
                        # Фильтруем значения по умолчанию, чтобы они были только из доступных опций
                        available_param_names_editor = sorted(all_params_dict.keys())
                        filtered_default_editor = [p for p in current_excluded_params if p in available_param_names_editor]
                        
                        excluded_params_selected = st.multiselect(
                            "Скрыть параметры:",
                            options=available_param_names_editor,
                            default=filtered_default_editor,
                            help="Выберите параметры, которые нужно скрыть. Они не будут показываться в таблице и не будут учитываться в топ комбинациях.",
                            key="excluded_params_select_editor"
                        )
                        
                        # Показываем статистику
                        col_stat1, col_stat2 = st.columns(2)
                        with col_stat1:
                            st.metric("Видимых параметров", len(all_params_dict) - len(excluded_params_selected))
                        with col_stat2:
                            st.metric("Скрытых параметров", len(excluded_params_selected))
                        
                        # Показываем список скрытых параметров
                        if excluded_params_selected:
                            st.markdown("#### 👁️ Скрытые параметры:")
                            for param_name in excluded_params_selected:
                                st.write(f"• {param_name}")
                        
                        # Кнопки управления
                        col_hide1, col_hide2 = st.columns(2)
                        with col_hide1:
                            if st.button("💾 Сохранить настройки видимости", type="primary", use_container_width=True, key="save_excluded_params"):
                                st.session_state["excluded_params"] = excluded_params_selected
                                if save_excluded_params_settings():
                                    st.success("✅ Настройки видимости сохранены!")
                                    st.rerun()
                                else:
                                    st.warning("⚠️ Настройки сохранены в памяти, но не в файл")
                        
                        with col_hide2:
                            if st.button("🔄 Показать все параметры", use_container_width=True, key="show_all_params"):
                                st.session_state["excluded_params"] = []
                                if save_excluded_params_settings():
                                    st.success("✅ Все параметры теперь видимы!")
                                    st.rerun()
                                else:
                                    st.warning("⚠️ Настройки сохранены в памяти, но не в файл")
                
                elif editor_mode == "🗑️ Удаление параметров":
                    st.markdown("### 🗑️ Управление удалением параметров")
                    st.warning("⚠️ **Внимание:** Удаление параметров необратимо. Параметры будут полностью удалены из всех данных.")
                    
                    # Функция для определения служебных параметров
                    def is_service_param(param_name):
                        """Проверяет, является ли параметр служебным (данные, а не параметр товара)"""
                        service_keywords = [
                            "остат", "остатки", "остаток",
                            "дней", "дни", "день",
                            "период", "периода", "периоды",
                            "конец", "начало", "дата",
                            "цена", "цена,", "стоимость", "прибыль", "выручка", "расход",
                            "расчет", "рекоменд", "оптимальн",
                            "реализац", "возврат", "выкуп",
                            "оборачиваемость", "конверсия",
                            "рейтинг", "отзыв", "вопрос",
                            "показ", "клик", "ctr", "cpc", "cpa", "roas",
                            "продано", "заказано", "заказ,", "продаж",
                            "stock", "days", "period", "price", "revenue", "profit"
                        ]
                        param_lower = str(param_name).lower()
                        for keyword in service_keywords:
                            if keyword in param_lower:
                                return True
                        return False
                    
                    # Получаем все параметры (исключая уже удаленные)
                    param_values_dict = get_param_values()
                    param_options_dict = st.session_state.get("param_options", {})
                    all_params_dict = param_options_dict.copy()
                    for param_name, param_data in param_values_dict.items():
                        if param_name not in all_params_dict:
                            all_params_dict[param_name] = []
                    
                    # Получаем список удаленных параметров
                    deleted_params = st.session_state.get("deleted_params", set())
                    if not isinstance(deleted_params, set):
                        deleted_params = set(deleted_params)
                    
                    # Автоматически находим служебные параметры
                    service_params = [p for p in all_params_dict.keys() if is_service_param(p)]
                    
                    # Показываем информацию о найденных служебных параметрах
                    if service_params:
                        st.markdown("#### ⚠️ Обнаружены служебные параметры (данные, а не параметры товара):")
                        st.info(f"Найдено {len(service_params)} служебных параметров, которые рекомендуется удалить:")
                        for param_name in sorted(service_params):
                            st.write(f"• **{param_name}**")
                        
                        if st.button("🗑️ Удалить все служебные параметры", type="secondary", use_container_width=True, key="delete_service_params_btn"):
                            deleted_count = 0
                            for param_name in service_params:
                                # Удаляем из param_values
                                if param_name in st.session_state.get("param_values", {}):
                                    del st.session_state["param_values"][param_name]
                                # Удаляем из param_options
                                if param_name in st.session_state.get("param_options", {}):
                                    del st.session_state["param_options"][param_name]
                                # Добавляем в список удаленных
                                if "deleted_params" not in st.session_state:
                                    st.session_state["deleted_params"] = set()
                                if not isinstance(st.session_state["deleted_params"], set):
                                    st.session_state["deleted_params"] = set(st.session_state["deleted_params"])
                                st.session_state["deleted_params"].add(param_name)
                                deleted_count += 1
                            
                            # Сохраняем список удаленных параметров ТОЛЬКО для текущего проекта
                            # Не сохраняем в глобальный файл, чтобы не затрагивать другие проекты
                            if save_deleted_params_to_file():
                                # Сохраняем изменения в файлы параметров текущего проекта
                                if save_param_values_to_file():
                                    pass  # Успешно сохранено
                            else:
                                st.warning("⚠️ Возникла ошибка при сохранении удаленных параметров")
                            
                            st.success(f"✅ Удалено {deleted_count} служебных параметров!")
                            st.rerun()
                        
                        st.divider()
                    
                    if not all_params_dict:
                        st.warning("⚠️ Нет доступных параметров для удаления.")
                    else:
                        st.markdown("#### Доступные параметры для удаления:")
                        
                        # Таблица с параметрами и кнопками удаления
                        for param_name in sorted(all_params_dict.keys()):
                            col_del1, col_del2, col_del3 = st.columns([3, 1, 1])
                            
                            with col_del1:
                                options_count = len(all_params_dict[param_name]) if isinstance(all_params_dict[param_name], list) else 0
                                values_count = len(param_values_dict.get(param_name, {})) if param_name in param_values_dict else 0
                                st.write(f"**{param_name}** - {options_count} вариантов, {values_count} значений")
                            
                            with col_del2:
                                # Проверяем, является ли параметр иерархическим
                                hierarchy_params = get_hierarchy_params()
                                if param_name in hierarchy_params:
                                    st.caption("🔗 Иерархический")
                            
                            with col_del3:
                                if st.button("🗑️ Удалить", key=f"delete_param_editor_{param_name}", type="secondary"):
                                    # Удаляем параметр
                                    if param_name in st.session_state.get("param_options", {}):
                                        del st.session_state["param_options"][param_name]
                                    if param_name in st.session_state.get("param_values", {}):
                                        del st.session_state["param_values"][param_name]
                                    
                                    # Добавляем в список удаленных
                                    if "deleted_params" not in st.session_state:
                                        st.session_state["deleted_params"] = set()
                                    if not isinstance(st.session_state["deleted_params"], set):
                                        st.session_state["deleted_params"] = set(st.session_state["deleted_params"])
                                    
                                    st.session_state["deleted_params"].add(param_name)
                                    
                                    # Сохраняем список удаленных параметров ТОЛЬКО для текущего проекта
                                    if save_deleted_params_to_file():
                                        if save_param_values_to_file():
                                            st.success(f"✅ Параметр '{param_name}' удален из текущего проекта!")
                                            st.rerun()
                                        else:
                                            st.warning(f"⚠️ Параметр '{param_name}' удален из памяти, но не сохранен в файл")
                                    else:
                                        st.error(f"❌ Ошибка сохранения удаленного параметра")
                            
                            st.divider()
                        
                        # Показываем удаленные параметры с возможностью восстановления
                        if deleted_params:
                            st.markdown("---")
                            st.markdown("#### 🗑️ Удаленные параметры:")
                            st.info("💡 Удаленные параметры можно восстановить. Восстановление вернет параметр в список доступных, но значения будут потеряны, если не были сохранены в истории.")
                            
                            # Показываем каждый удаленный параметр с кнопкой восстановления
                            for param_name in sorted(deleted_params):
                                col_restore1, col_restore2 = st.columns([3, 1])
                                
                                with col_restore1:
                                    st.write(f"• **{param_name}**")
                                
                                with col_restore2:
                                    if st.button("🔄 Восстановить", key=f"restore_param_{param_name}", type="primary", use_container_width=True):
                                        # Удаляем параметр из списка удаленных
                                        if "deleted_params" in st.session_state:
                                            st.session_state["deleted_params"].discard(param_name)
                                        
                                        # Инициализируем параметр пустыми значениями, если его нет
                                        if param_name not in st.session_state.get("param_values", {}):
                                            if "param_values" not in st.session_state:
                                                st.session_state["param_values"] = {}
                                            st.session_state["param_values"][param_name] = {}
                                        
                                        if param_name not in st.session_state.get("param_options", {}):
                                            if "param_options" not in st.session_state:
                                                st.session_state["param_options"] = {}
                                            st.session_state["param_options"][param_name] = []
                                        
                                        # Сохраняем изменения
                                        if save_deleted_params_to_file():
                                            if save_param_values_to_file():
                                                st.success(f"✅ Параметр '{param_name}' восстановлен!")
                                                st.rerun()
                                            else:
                                                st.warning(f"⚠️ Параметр '{param_name}' восстановлен в памяти, но не сохранен в файл")
                                        else:
                                            st.error(f"❌ Ошибка при восстановлении параметра '{param_name}'")
                            
                            st.divider()
                            
                            # Кнопка для восстановления всех удаленных параметров
                            if st.button("🔄 Восстановить все удаленные параметры", type="secondary", use_container_width=True, key="restore_all_deleted_params"):
                                # Инициализируем все удаленные параметры пустыми значениями
                                for param_name in list(deleted_params):
                                    if param_name not in st.session_state.get("param_values", {}):
                                        if "param_values" not in st.session_state:
                                            st.session_state["param_values"] = {}
                                        st.session_state["param_values"][param_name] = {}
                                    
                                    if param_name not in st.session_state.get("param_options", {}):
                                        if "param_options" not in st.session_state:
                                            st.session_state["param_options"] = {}
                                        st.session_state["param_options"][param_name] = []
                                
                                # Очищаем список удаленных
                                st.session_state["deleted_params"] = set()
                                
                                # Сохраняем изменения
                                if save_deleted_params_to_file():
                                    if save_param_values_to_file():
                                        st.success("✅ Все удаленные параметры восстановлены!")
                                        st.rerun()
                                    else:
                                        st.warning("⚠️ Параметры восстановлены в памяти, но не сохранены в файл")
                                else:
                                    st.error("❌ Ошибка при восстановлении параметров")
                        else:
                            st.info("ℹ️ Нет удаленных параметров")
                
                elif editor_mode == "📋 Просмотр всех параметров":
                    if param_options:
                        # Это будет старый раздел "Просмотр и редактирование"
                        st.markdown("### 📋 Просмотр и редактирование параметров")
                        # Поиск параметров
                        search_param = st.text_input("🔍 Поиск параметра:", placeholder="Введите название параметра...", key="search_param_editor")
                        
                        # Фильтрация параметров
                        filtered_params = param_options.copy()
                        if search_param:
                            filtered_params = {k: v for k, v in param_options.items() if search_param.lower() in k.lower()}
                        
                        if filtered_params:
                            # Сортировка параметров
                            sort_order = st.selectbox("Сортировка:", ["По алфавиту", "По количеству вариантов"], key="sort_params")
                            
                            if sort_order == "По количеству вариантов":
                                filtered_params = dict(sorted(filtered_params.items(), key=lambda x: len(x[1]) if isinstance(x[1], list) else 0, reverse=True))
                            elif sort_order == "По алфавиту":
                                filtered_params = dict(sorted(filtered_params.items()))
                            
                            # Отображаем параметры в упрощенном виде
                            for param_name, options in filtered_params.items():
                                with st.expander(f"📋 {param_name} ({len(options) if isinstance(options, list) else 0} вариантов)"):
                                    if isinstance(options, list) and options:
                                        st.write("**Варианты значений:**")
                                        for option in options:
                                            st.write(f"• {option}")
                                    else:
                                        st.info("Нет вариантов значений")
                        else:
                            st.info("Параметры не найдены")
                    else:
                        st.warning("⚠️ Нет параметров для отображения")
                
                elif editor_mode == "📥 Импорт / 📤 Экспорт":
                    st.markdown("### 📥 Импорт / 📤 Экспорт")
                    
                    # Разделы: Сохранение проекта и Экспорт/Импорт параметров
                    tab_project, tab_params = st.tabs(["💾 Проект", "📋 Параметры"])
                    
                    with tab_project:
                        st.markdown("#### 💾 Сохранение и загрузка полного проекта")
                        st.info("💡 Полный проект включает: параметры, иерархию, настройки, исключенные параметры и все данные проекта.")
                        
                        col_project_save, col_project_load = st.columns(2)
                        
                        with col_project_save:
                            st.markdown("##### 📤 Сохранить проект")
                            
                            # Показываем информацию о текущем проекте
                            current_file_name = st.session_state.get("cached_file_name", "Не загружен")
                            current_project_name = st.session_state.get("current_project_name", None)
                            
                            if current_file_name != "Не загружен":
                                st.info(f"📄 Текущий файл: **{current_file_name}**")
                            else:
                                st.warning("⚠️ Файл данных не загружен. Проект будет сохранен без файла данных.")
                            
                            if current_project_name:
                                st.caption(f"📁 Проект: **{current_project_name}**")
                            
                            project_name = st.text_input(
                                "Название проекта:",
                                value=current_project_name or f"Проект_{pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')}",
                                key="project_name_input",
                                help="Введите название проекта для сохранения. Для каждого проекта будут сохранены свои параметры и файл данных."
                            )
                            
                            if st.button("💾 Сохранить полный проект", type="primary", use_container_width=True, key="save_full_project_btn"):
                                with st.spinner("Сохраняю проект..."):
                                    project_json, saved_name, project_id = save_full_project(project_name)
                                    if project_json:
                                        file_size_mb = len(project_json.encode('utf-8')) / (1024 * 1024)
                                        st.download_button(
                                            label=f"⬇️ Скачать проект ({file_size_mb:.2f} MB)",
                                            data=project_json,
                                            file_name=f"{saved_name}.json",
                                            mime="application/json",
                                            use_container_width=True,
                                            key="download_project_btn"
                                        )
                                        st.success(f"✅ Проект '{saved_name}' готов к скачиванию!")
                                        st.info(f"💡 ID проекта: `{project_id}`\n\nПроект включает:\n• Все параметры и их значения\n• Иерархию параметров\n• Файл данных (если загружен)\n• Настройки и фильтры")
                                    else:
                                        st.error("❌ Ошибка сохранения проекта")
                            
                            # Показываем информацию о проекте
                            st.markdown("**📊 Текущий проект содержит:**")
                            param_count = len(param_options) if param_options else 0
                            values_count = sum(len(v) for v in param_values.values()) if param_values else 0
                            st.caption(f"• Параметров: {param_count}")
                            st.caption(f"• Значений параметров: {values_count}")
                            st.caption(f"• Иерархических параметров: {len(st.session_state.get('hierarchy_params', []))}")
                            st.caption(f"• Исключенных параметров: {len(st.session_state.get('excluded_params', []))}")
                        
                        with col_project_load:
                            st.markdown("##### 📥 Загрузить проект")
                            uploaded_project = st.file_uploader(
                                "Загрузить файл проекта (.json):",
                                type=["json"],
                                key="import_project_file",
                                help="Выберите файл проекта для загрузки"
                            )
                            
                            if uploaded_project:
                                try:
                                    project_json = uploaded_project.read().decode('utf-8')
                                    project_data = json.loads(project_json)
                                    
                                    # Показываем информацию о проекте
                                    project_name_loaded = project_data.get("project_name", "Неизвестный проект")
                                    export_date = project_data.get("export_date", "Неизвестно")
                                    project_id = project_data.get("project_id", "N/A")
                                    project_version = project_data.get("project_version", "1.0")
                                    cached_file_name = project_data.get("cached_file_name", None)
                                    file_size = project_data.get("file_size", 0)
                                    
                                    st.success(f"✅ Файл загружен: **{project_name_loaded}**")
                                    st.caption(f"📅 Дата создания: {export_date} | Версия: {project_version} | ID: `{project_id}`")
                                    
                                    # Показываем содержимое проекта
                                    with st.expander("📋 Содержимое проекта", expanded=True):
                                        col_info1, col_info2 = st.columns(2)
                                        
                                        with col_info1:
                                            if "param_options" in project_data:
                                                st.metric("Параметров", len(project_data['param_options']))
                                            if "hierarchy_params" in project_data:
                                                st.metric("Иерархических", len(project_data['hierarchy_params']))
                                            if "excluded_params" in project_data:
                                                st.metric("Исключенных", len(project_data['excluded_params']))
                                        
                                        with col_info2:
                                            if cached_file_name:
                                                st.metric("Файл данных", cached_file_name)
                                                if file_size > 0:
                                                    st.caption(f"Размер: {file_size / 1024 / 1024:.2f} MB")
                                            else:
                                                st.info("Файл данных отсутствует")
                                        
                                        # Показываем список параметров
                                        if "param_options" in project_data and project_data["param_options"]:
                                            st.markdown("**Параметры проекта:**")
                                            param_list = ", ".join(list(project_data["param_options"].keys())[:10])
                                            if len(project_data["param_options"]) > 10:
                                                param_list += f" ... и еще {len(project_data['param_options']) - 10}"
                                            st.caption(param_list)
                                    
                                    st.warning("⚠️ **Внимание:** При загрузке проекта все текущие параметры будут заменены параметрами проекта!")
                                    
                                    if st.button("📥 Загрузить проект", type="primary", use_container_width=True, key="load_full_project_btn"):
                                        with st.spinner("Загружаю проект..."):
                                            success, loaded_name = load_full_project(project_json)
                                            if success:
                                                st.success(f"✅ Проект '{loaded_name}' успешно загружен!")
                                                st.info("🔄 Применяю изменения... Перезагрузите страницу для полного применения.")
                                                # Небольшая задержка перед rerun, чтобы пользователь увидел сообщение
                                                import time
                                                time.sleep(1)
                                                st.rerun()
                                            else:
                                                st.error("❌ Ошибка загрузки проекта")
                                            
                                except Exception as e:
                                    st.error(f"❌ Ошибка при загрузке проекта: {e}")
                                    st.caption(f"Детали: {str(e)}")
                    
                    with tab_params:
                        st.markdown("#### 📋 Экспорт / Импорт только параметров")
                        st.info("💡 Экспорт/импорт только параметров (без настроек и иерархии)")
                    
                    # Кнопка сохранения параметров
                    st.divider()
                    col_save_editor1, col_save_editor2 = st.columns([1, 3])
                    with col_save_editor1:
                        if st.button("💾 Сохранить все параметры", type="primary", use_container_width=True, key="save_all_params_btn"):
                            # Сначала сохраняем deleted_params (это очистит все файлы)
                            if save_deleted_params_to_file():
                                # Затем сохраняем param_options и param_values
                                if save_param_values_to_file():
                                    # Очищаем результаты массового анализа от удаленных параметров
                                    if "mass_analysis_results" in st.session_state:
                                        st.session_state["mass_analysis_results"] = remove_deleted_params_from_mass_results(
                                            st.session_state["mass_analysis_results"]
                                        )
                                        save_mass_analysis_results(st.session_state["mass_analysis_results"])
                                    st.success("✅ Все параметры и настройки сохранены!")
                                    st.rerun()
                                else:
                                    st.error("❌ Ошибка сохранения параметров")
                            else:
                                st.error("❌ Ошибка сохранения списка удаленных параметров")
                    
                    with col_save_editor2:
                        st.info("💡 Сохраняет все параметры, варианты и список удаленных параметров в файлы")
                        
                        # Показываем текущие удаленные параметры для отладки
                        deleted_params = st.session_state.get("deleted_params", set())
                        if deleted_params:
                            st.caption(f"🗑️ Удаленные параметры: {', '.join(sorted(deleted_params))}")
                        else:
                            st.caption("ℹ️ Нет удаленных параметров")
                    
                    st.divider()
                    
                    col_export, col_import = st.columns(2)
                    
                    with col_export:
                        st.markdown("##### 📤 Экспорт параметров")
                        if st.button("💾 Экспортировать в JSON", use_container_width=True, key="export_params_btn"):
                            export_data = {
                                "param_options": param_options,
                                "param_values": param_values,
                                "export_date": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S")
                            }
                            st.download_button(
                                label="⬇️ Скачать файл",
                                data=json.dumps(export_data, ensure_ascii=False, indent=2),
                                file_name=f"parameters_export_{pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')}.json",
                                mime="application/json",
                                use_container_width=True,
                                key="download_params_btn"
                            )
                    
                    with col_import:
                        st.markdown("##### 📥 Импорт параметров")
                        uploaded_file = st.file_uploader(
                            "Загрузить JSON файл:",
                            type=["json"],
                            key="import_params_file"
                        )
                        if uploaded_file:
                            try:
                                import_data = json.load(uploaded_file)
                                if "param_options" in import_data:
                                    st.success(f"✅ Файл загружен: {len(import_data.get('param_options', {}))} параметров")
                                    
                                    if st.button("📥 Импортировать параметры", type="primary", use_container_width=True, key="import_params_btn"):
                                        # Объединяем с существующими параметрами
                                        imported_options = import_data.get("param_options", {})
                                        imported_values = import_data.get("param_values", {})
                                        
                                        # Обновляем param_options
                                        for param_name, options in imported_options.items():
                                            param_options[param_name] = options
                                        
                                        # Обновляем param_values
                                        for param_name, values in imported_values.items():
                                            if param_name not in param_values:
                                                param_values[param_name] = {}
                                            param_values[param_name].update(values)
                                        
                                        st.session_state["param_options"] = param_options
                                        st.session_state["param_values"] = param_values
                                        
                                        if save_param_values_to_file():
                                            st.success(f"✅ Импортировано {len(imported_options)} параметров!")
                                            st.rerun()
                            except Exception as e:
                                st.error(f"❌ Ошибка при импорте: {e}")
            
            st.divider()
            # ========== КОНЕЦ РЕДАКТОРА ПАРАМЕТРОВ ==========
            
            # ========== СЕКЦИЯ: Экспорт/Импорт параметров товаров в CSV ==========
            with st.expander("📥📤 Экспорт / Импорт параметров товаров", expanded=False):
                st.markdown("### 📥📤 Экспорт / Импорт параметров товаров")
                st.info("💡 Скачайте CSV файл с параметрами товаров, отредактируйте его в Excel или другом редакторе, затем загрузите обратно для применения изменений.")
                
                col_export_params, col_import_params = st.columns(2)
                
                with col_export_params:
                    st.markdown("#### 📥 Экспорт параметров в CSV")
                    if st.button("📥 Скачать CSV с параметрами", type="primary", use_container_width=True, key="export_product_params_btn"):
                        csv_data = export_product_params_to_csv()
                        if csv_data:
                            file_name = st.session_state.get("cached_file_name", "product_params")
                            if file_name:
                                base_name = os.path.splitext(file_name)[0]
                            else:
                                base_name = "product_params"
                            timestamp = pd.Timestamp.now().strftime("%Y%m%d_%H%M%S")
                            csv_filename = f"{base_name}_params_{timestamp}.csv"
                            
                            st.download_button(
                                label="💾 Скачать CSV файл",
                                data=csv_data,
                                file_name=csv_filename,
                                mime="text/csv",
                                key="download_product_params_csv"
                            )
                            
                            # Показываем статистику
                            param_values = get_param_values()
                            df = st.session_state.get("df") or st.session_state.get("display_df")
                            if df is not None and "Артикул" in df.columns:
                                total_skus = len(df["Артикул"].dropna().unique())
                                params_count = len(param_values)
                                st.success(f"✅ CSV файл готов! Товаров: {total_skus}, Параметров: {params_count}")
                        else:
                            st.error("❌ Ошибка при экспорте параметров. Убедитесь, что загружен файл с данными и есть параметры.")
                
                with col_import_params:
                    st.markdown("#### 📤 Импорт параметров из CSV")
                    uploaded_params_file = st.file_uploader(
                        "Загрузите отредактированный CSV файл",
                        type=['csv'],
                        key="import_product_params_csv"
                    )
                    if uploaded_params_file is not None:
                        try:
                            csv_data = uploaded_params_file.read().decode('utf-8-sig')
                            imported_count, updated_count = import_product_params_from_csv(csv_data)
                            if imported_count > 0:
                                # Сохраняем параметры в файл
                                if save_param_values_to_file():
                                    st.success(f"✅ Импортировано товаров: {imported_count}, обновлено параметров: {updated_count}")
                                    st.info("💡 Параметры применены и сохранены. Обновите страницу, чтобы увидеть изменения.")
                                    st.rerun()
                                else:
                                    st.warning("⚠️ Параметры импортированы, но не удалось сохранить в файл")
                            else:
                                st.warning("⚠️ Не удалось импортировать данные из CSV файла")
                        except Exception as e:
                            st.error(f"❌ Ошибка при импорте CSV: {e}")
                
                st.markdown("---")
                st.markdown("**Инструкция:**")
                st.markdown("""
                1. Нажмите "Скачать CSV с параметрами" для получения файла со всеми товарами и их параметрами
                2. Откройте файл в Excel, Google Sheets или другом редакторе
                3. Отредактируйте значения параметров для нужных товаров
                4. Сохраните файл в формате CSV
                5. Загрузите отредактированный файл обратно через форму выше
                6. Параметры будут автоматически применены и сохранены
                """)
            
            st.divider()
            # ========== КОНЕЦ СЕКЦИИ ЭКСПОРТ/ИМПОРТ ПАРАМЕТРОВ ==========
            
            # Получаем данные
            param_values = get_param_values()
            
            # Инициализация session_state для автосохранения (отключено)
            if "last_autosave" not in st.session_state:
                st.session_state["last_autosave"] = 0
            
            # Автосохранение включено
            import time
            current_time = time.time()
            if current_time - st.session_state["last_autosave"] > 30:  # 30 секунд
                if save_param_values_to_file():
                    st.session_state["last_autosave"] = current_time
                    st.info("🔄 Автосохранение выполнено")
            
            # ========== СЕКЦИЯ: Определение параметров по ссылке (через анализ изображений) ==========
            st.divider()
            st.subheader("🔗 Определение параметров по ссылке (анализ через нейросеть)")
            st.write("Вставьте ссылку на товар Wildberries. Система получит до 5 фотографий товара через screenshotapi.net и отправит их в нейросеть для анализа:")
            
            # Поле для API ключа OpenAI
            # Загружаем ключ из secrets.toml при первом запуске
            if 'openai_api_key' not in st.session_state:
                try:
                    # Пытаемся загрузить из secrets.toml
                    default_key = st.secrets.get('openai_api_key', '')
                    if default_key:
                        st.session_state['openai_api_key'] = default_key
                except:
                    pass
            
            with st.expander("⚙️ Настройки API", expanded=False):
                # Проверяем наличие библиотеки openai
                if not OPENAI_AVAILABLE:
                    st.warning("⚠️ Для анализа изображений через нейросеть необходимо установить библиотеку: `pip install openai`")
                    st.code("pip install openai", language="bash")
                else:
                    # Режим отладки
                    debug_mode = st.checkbox(
                        "🔍 Режим отладки",
                        value=st.session_state.get('debug_ai_analysis', False),
                        help="Показывать детальную информацию об анализе изображений",
                        key="debug_ai_checkbox"
                    )
                    if debug_mode:
                        st.session_state['debug_ai_analysis'] = True
                    else:
                        st.session_state['debug_ai_analysis'] = False
                default_key_value = st.session_state.get('openai_api_key', '')
                openai_api_key = st.text_input(
                    "🔑 OpenAI API ключ",
                    value=default_key_value,
                    type="password",
                    help="Введите ваш OpenAI API ключ для анализа изображений. Ключ сохраняется только в текущей сессии.",
                    key="openai_api_key_input"
                )
                if openai_api_key:
                    st.session_state['openai_api_key'] = openai_api_key
                    if openai_api_key == default_key_value and default_key_value:
                        st.success("✅ Используется стандартный API ключ")
                    else:
                        st.success("✅ API ключ сохранен")
                else:
                    if default_key_value:
                        st.info("ℹ️ Используется стандартный API ключ из настроек")
                    else:
                        st.info("ℹ️ Для работы с нейросетью необходим OpenAI API ключ. Получить можно на https://platform.openai.com/api-keys")
                
                # Поле для токена screenshotapi.net
                st.divider()
                st.markdown("**📸 ScreenshotAPI.net (для получения изображений товаров)**")
                
                # Загружаем токен из secrets.toml при первом запуске
                if 'screenshotapi_token' not in st.session_state:
                    try:
                        default_token = st.secrets.get('screenshotapi_token', '')
                        if default_token:
                            st.session_state['screenshotapi_token'] = default_token
                        else:
                            # Устанавливаем токен по умолчанию
                            st.session_state['screenshotapi_token'] = 'MDA94V3-4C14RXS-KSE2KMK-T08BD9M'
                    except:
                        # Устанавливаем токен по умолчанию
                        st.session_state['screenshotapi_token'] = 'MDA94V3-4C14RXS-KSE2KMK-T08BD9M'
                
                default_token_value = st.session_state.get('screenshotapi_token', 'MDA94V3-4C14RXS-KSE2KMK-T08BD9M')
                screenshotapi_token = st.text_input(
                    "🔑 ScreenshotAPI.net токен",
                    value=default_token_value,
                    type="password",
                    help="Введите ваш токен screenshotapi.net для получения изображений товаров. Токен сохраняется только в текущей сессии.",
                    key="screenshotapi_token_input"
                )
                if screenshotapi_token:
                    st.session_state['screenshotapi_token'] = screenshotapi_token
                    if screenshotapi_token == default_token_value and default_token_value:
                        st.success("✅ Используется стандартный токен")
                    else:
                        st.success("✅ Токен сохранен")
                else:
                    if default_token_value:
                        st.info("ℹ️ Используется стандартный токен из настроек")
                    else:
                        st.info("ℹ️ Для получения изображений через screenshotapi.net необходим токен. Получить можно на https://screenshotapi.net")
            
            # Переключатель между одиночным и массовым анализом
            analysis_mode = st.radio(
                "Режим анализа:",
                ["Массовый анализ", "Одиночный анализ"],
                horizontal=True,
                index=0,
                key="analysis_mode_radio"
            )
            
            if analysis_mode == "Одиночный анализ":
                col_url1, col_url2 = st.columns([3, 1])
                with col_url1:
                    product_url = st.text_input(
                        "Ссылка на товар Wildberries",
                        placeholder="https://www.wildberries.ru/catalog/12345678/detail.aspx",
                        key="product_url_input"
                    )
                
                with col_url2:
                    st.write("")  # Отступ
                    st.write("")  # Отступ
                    analyze_btn = st.button("🤖 Анализировать через нейросеть", type="primary", key="extract_params_btn")
                
                if analyze_btn:
                    if product_url:
                        with st.spinner("⏳ Анализ фотографий товара..."):
                            # Извлекаем артикул
                            sku = extract_sku_from_url(product_url)
                            
                            if sku:
                                st.success(f"✅ Артикул найден: **{sku}**")
                                
                                # Получаем и анализируем изображения
                                progress_bar = st.progress(0)
                                status_text = st.empty()
                                
                                # ПЕРВЫЙ ЭТАП: Определение комплектности по характеристикам
                                status_text.text("🔍 Анализ характеристик товара для определения комплектности...")
                                progress_bar.progress(10)
                                
                                completeness = determine_completeness(sku)
                                initial_params = {}
                                if completeness:
                                    initial_params["Комплект"] = completeness
                                    st.info(f"📦 **Комплектность:** {completeness}")
                                
                                # ВТОРОЙ ЭТАП: Получение изображений через screenshotapi.net
                                status_text.text("📸 Получение изображений через screenshotapi.net...")
                                progress_bar.progress(20)
                                
                                # Получаем информацию о статусе изображений
                                images_info = get_screenshotapi_images_with_status(sku, max_images=5)
                                
                                if not images_info:
                                    st.error("❌ Не удалось получить URL-ы изображений. Проверьте токен screenshotapi.net.")
                                else:
                                    # Разделяем изображения на те, что в кеше, и те, что нужно скачать
                                    cached_images = [img for img in images_info if img["status"] == "cached"]
                                    downloading_images = [img for img in images_info if img["status"] == "downloading"]
                                    
                                    # Показываем информацию о статусе изображений
                                    st.markdown("### 📸 Статус изображений (5 шт.)")
                                    
                                    # Создаем контейнеры для отображения статуса
                                    status_cols = st.columns(2)
                                    
                                    with status_cols[0]:
                                        st.markdown(f"**✅ В кеше:** {len(cached_images)} из 5")
                                        if cached_images:
                                            for img_info in cached_images:
                                                st.success(f"📷 Фото {img_info['index']}: В кеше")
                                    
                                    with status_cols[1]:
                                        st.markdown(f"**⬇️ Скачивается:** {len(downloading_images)} из 5")
                                        if downloading_images:
                                            for img_info in downloading_images:
                                                st.info(f"📷 Фото {img_info['index']}: Скачивается...")
                                    
                                    # Скачиваем изображения, которых нет в кеше
                                    if downloading_images:
                                        status_text.text(f"⬇️ Скачивание {len(downloading_images)} изображений...")
                                        progress_bar.progress(30)
                                        
                                        downloaded_count = 0
                                        download_status_placeholder = st.empty()
                                        
                                        for img_idx, img_info in enumerate(downloading_images):
                                            status_text.text(f"⬇️ Скачивание фото {img_info['index']}/5...")
                                            progress_bar.progress(30 + int((img_idx + 1) / len(downloading_images) * 20))
                                            
                                            # Увеличиваем timeout для первого изображения (оно может загружаться дольше)
                                            timeout_value = 45 if img_info["index"] == 1 else 30
                                            cached_path = ensure_image_cached(
                                                img_info["cache_key"], 
                                                img_info["url"], 
                                                "PNG", 
                                                timeout=timeout_value
                                            )
                                            if cached_path and os.path.exists(cached_path):
                                                img_info["path"] = cached_path
                                                img_info["status"] = "downloaded"
                                                downloaded_count += 1
                                                # Обновляем статус в реальном времени
                                                with download_status_placeholder.container():
                                                    st.success(f"✅ Фото {img_info['index']}: Скачано")
                                            else:
                                                img_info["status"] = "error"
                                                with download_status_placeholder.container():
                                                    st.error(f"❌ Фото {img_info['index']}: Ошибка скачивания")
                                            
                                            # Задержка между запросами
                                            import time
                                            time.sleep(0.5)
                                        
                                        if downloaded_count > 0:
                                            st.success(f"✅ Скачано изображений: {downloaded_count} из {len(downloading_images)}")
                                        elif len(downloading_images) > 0:
                                            st.warning(f"⚠️ Не удалось скачать изображения. Проверьте токен screenshotapi.net и интернет-соединение.")
                                    
                                    # Собираем все успешно загруженные изображения
                                    all_loaded_images = []
                                    for img_info in images_info:
                                        if img_info["status"] in ["cached", "downloaded"] and img_info.get("path"):
                                            all_loaded_images.append(img_info["path"])
                                    
                                    if not all_loaded_images:
                                        st.error("❌ Не удалось загрузить ни одного изображения")
                                    else:
                                        st.success(f"✅ Готово к анализу: {len(all_loaded_images)} из 5 изображений")
                                        
                                        # Показываем все загруженные изображения
                                        st.markdown("### 📸 Загруженные изображения")
                                        # Создаем колонки для отображения изображений (по 3 в ряд)
                                        num_cols = min(3, len(all_loaded_images))
                                        img_cols = st.columns(num_cols)
                                        
                                        for idx, img_path in enumerate(all_loaded_images):
                                            col_idx = idx % num_cols
                                            with img_cols[col_idx]:
                                                try:
                                                    # Находим номер изображения из images_info
                                                    img_index = None
                                                    for img_info in images_info:
                                                        if img_info.get("path") == img_path:
                                                            img_index = img_info.get("index", idx + 1)
                                                            break
                                                    
                                                    if img_index is None:
                                                        img_index = idx + 1
                                                    
                                                    # Определяем статус изображения
                                                    status_icon = "✅" if any(img_info.get("path") == img_path and img_info.get("status") == "cached" for img_info in images_info) else "⬇️"
                                                    status_text_img = "В кеше" if any(img_info.get("path") == img_path and img_info.get("status") == "cached" for img_info in images_info) else "Скачано"
                                                    
                                                    st.image(img_path, use_container_width=True, caption=f"{status_icon} Фото {img_index} ({status_text_img})")
                                                except Exception as e:
                                                    st.write(f"📷 Фото {idx+1}: {os.path.basename(img_path)}")
                                        
                                        st.divider()
                                        
                                        # Проверяем наличие библиотеки и API ключа
                                        if not OPENAI_AVAILABLE:
                                            st.error("⚠️ Для анализа изображений через нейросеть необходимо установить библиотеку: `pip install openai`")
                                        else:
                                            api_key = st.session_state.get('openai_api_key', '')
                                            if not api_key:
                                                st.error("❌ Необходимо указать OpenAI API ключ в настройках выше")
                                            else:
                                                # Показываем информацию о существующих параметрах
                                                param_options = st.session_state.get("param_options", {})
                                                if param_options:
                                                    with st.expander("📋 Используемые параметры для анализа", expanded=False):
                                                        for param_name, options in param_options.items():
                                                            if options:
                                                                st.write(f"**{param_name}:** {', '.join(options[:10])}{'...' if len(options) > 10 else ''}")
                                                
                                                status_text.text("🤖 Отправка изображений в нейросеть для анализа...")
                                                progress_bar.progress(50)
                                                
                                                # Анализируем изображения через нейросеть
                                                all_params = {}
                                                
                                                errors_count = 0
                                                successful_analyses = 0
                                                total_images = len(all_loaded_images)
                                                for idx, img_path in enumerate(all_loaded_images):
                                                    status_text.text(f"🤖 Анализ изображения {idx+1}/{total_images}...")
                                                    progress_bar.progress(50 + int((idx + 1) / total_images * 40))
                                                    try:
                                                        # Проверяем, что файл существует и доступен
                                                        if not os.path.exists(img_path):
                                                            st.error(f"❌ Файл изображения не найден: {img_path}")
                                                            errors_count += 1
                                                            continue
                                                        
                                                        # Получаем название товара для анализа
                                                        product_name = get_product_name_from_wb(sku)
                                                        img_params = analyze_image_with_ai(img_path, api_key, selected_params=None, product_name=product_name, sku=sku)
                                                        if img_params and len(img_params) > 0:
                                                            successful_analyses += 1
                                                            # Объединяем параметры
                                                            for key, value in img_params.items():
                                                                if key not in all_params:
                                                                    all_params[key] = []
                                                                all_params[key].append(value)
                                                            
                                                            # Показываем результат анализа для каждого изображения в режиме отладки
                                                            if st.session_state.get('debug_ai_analysis', False):
                                                                with st.expander(f"✅ Результат анализа изображения {idx+1}", expanded=False):
                                                                    for k, v in img_params.items():
                                                                        st.write(f"**{k}:** {v}")
                                                        else:
                                                            # Если параметры не определены, это не обязательно ошибка
                                                            # (нейросеть могла просто не найти параметры на изображении)
                                                            if st.session_state.get('debug_ai_analysis', False):
                                                                st.info(f"ℹ️ Изображение {idx+1}: параметры не определены нейросетью")
                                                    except Exception as e:
                                                        errors_count += 1
                                                        error_msg = str(e)
                                                        st.warning(f"⚠️ Ошибка при анализе изображения {idx+1}: {error_msg[:150]}")
                                                        if st.session_state.get('debug_ai_analysis', False):
                                                            import traceback
                                                            st.code(traceback.format_exc())
                                                
                                                # Определяем финальные параметры (берем наиболее частые значения)
                                                final_params = {}
                                                for key, values in all_params.items():
                                                    if values:
                                                        # Берем наиболее частое значение
                                                        value_counts = Counter(values)
                                                        most_common = value_counts.most_common(1)[0][0]
                                                        final_params[key] = most_common
                                                
                                                # Добавляем параметр комплектности, определенный на первом этапе
                                                if initial_params:
                                                    final_params.update(initial_params)
                                                
                                                progress_bar.progress(100)
                                                status_text.empty()
                                                
                                                if final_params:
                                                    st.success(f"✅ Найдено параметров: {len(final_params)}")
                                                    
                                                    # Показываем найденные параметры
                                                    with st.expander("📊 Определенные параметры", expanded=True):
                                                        for param_name, param_value in final_params.items():
                                                            st.write(f"**{param_name}:** {param_value}")
                                                    
                                                    # Предлагаем сохранить параметры
                                                    if st.button("💾 Сохранить параметры для этого товара", key="save_extracted_params"):
                                                        # Проверяем, есть ли этот артикул в текущей таблице
                                                        display_df = st.session_state.get("display_df", pd.DataFrame())
                                                        
                                                        if "Артикул" in display_df.columns:
                                                            sku_in_table = str(sku) in [str(s).replace(".0", "") for s in display_df["Артикул"].dropna().unique()]
                                                            
                                                            if sku_in_table:
                                                                # Сохраняем параметры с историей
                                                                for param_name, param_value in final_params.items():
                                                                    if param_name not in param_values:
                                                                        param_values[param_name] = {}
                                                                    # Используем функцию с сохранением истории
                                                                    save_param_value(str(sku), param_name, str(param_value), save_history=True)
                                                                
                                                                # Обновляем param_options
                                                                if "param_options" not in st.session_state:
                                                                    st.session_state["param_options"] = {}
                                                                
                                                                for param_name, param_value in final_params.items():
                                                                    if param_name not in st.session_state["param_options"]:
                                                                        st.session_state["param_options"][param_name] = []
                                                                    if param_value not in st.session_state["param_options"][param_name]:
                                                                        st.session_state["param_options"][param_name].append(param_value)
                                                                
                                                                # Сохраняем в файл
                                                                if save_param_values_to_file():
                                                                    st.success(f"✅ Параметры сохранены для артикула {sku}!")
                                                                    st.rerun()
                                                                else:
                                                                    st.warning("⚠️ Параметры сохранены в памяти, но не в файл")
                                                            else:
                                                                st.warning(f"⚠️ Артикул {sku} не найден в текущей таблице. Загрузите файл с этим артикулом.")
                                                        else:
                                                            st.warning("⚠️ Таблица не загружена. Загрузите файл с данными.")
                                                else:
                                                    if errors_count > 0:
                                                        st.error(f"❌ Ошибки при анализе {errors_count} изображений. Проверьте:")
                                                        st.write("1. Правильность API ключа OpenAI")
                                                        st.write("2. Доступность изображений в кеше")
                                                        st.write("3. Формат изображений (должны быть JPG, PNG или WebP)")
                                                        st.write("4. Размер изображений (не должны быть слишком большими)")
                                                        st.write("5. Баланс на счету OpenAI API")
                                                    elif successful_analyses == 0:
                                                        st.info("ℹ️ Нейросеть не смогла определить параметры из изображений.")
                                                        st.write("**Возможные причины:**")
                                                        st.write("- Изображения не содержат достаточной информации о товаре")
                                                        st.write("- Товар на изображении не виден четко")
                                                        st.write("- Параметры не соответствуют существующим вариантам")
                                                        st.write("- Попробуйте включить режим отладки для детальной информации")
                                                    else:
                                                        st.warning(f"⚠️ Проанализировано {successful_analyses} изображений, но параметры не были определены.")
                                                        st.write("Возможно, найденные параметры не соответствуют существующим вариантам.")
                                                    
                                                    if st.session_state.get('debug_ai_analysis', False):
                                                        st.write(f"**Найденные параметры:** {all_params}")
                            else:
                                st.warning("⚠️ Изображения товара не найдены. Не удалось загрузить изображения через screenshotapi.net.")
                                st.info("💡 **Совет:** Проверьте токен screenshotapi.net и интернет-соединение.")
                    else:
                        st.warning("⚠️ Введите ссылку на товар")
            else:
                # Массовый анализ
                st.markdown("### 📋 Массовый анализ товаров")
                
                is_analysis_running = st.session_state.get("mass_analysis_btn_clicked", False)
                
                # Показываем таблицу результатов массового анализа со статусами (ВСЕГДА)
                st.markdown("#### 📊 Результаты массового анализа")
                
                # Загружаем результаты из файлов (всегда проверяем, чтобы не потерять данные)
                mass_analysis_results = st.session_state.get("mass_analysis_results", [])
                
                # Если результатов нет в session_state, пытаемся загрузить из файлов
                if not mass_analysis_results:
                    # Сначала пытаемся загрузить из постоянного файла результатов
                    saved_results = load_mass_analysis_results()
                    if saved_results:
                        mass_analysis_results = saved_results
                        st.session_state["mass_analysis_results"] = saved_results
                        # НЕ применяем автоматически - пользователь должен применить вручную
                        # apply_mass_analysis_results_to_params(saved_results)
                        # save_param_values_to_file()
                    else:
                        # Если нет постоянного файла, пытаемся загрузить из прогресса
                        saved_progress = load_mass_analysis_progress()
                        if saved_progress and saved_progress.get("results"):
                            mass_analysis_results = saved_progress["results"]
                            st.session_state["mass_analysis_results"] = saved_progress["results"]
                            # Сохраняем в постоянный файл для будущих запусков
                            save_mass_analysis_results(saved_progress["results"])
                            # НЕ применяем автоматически - пользователь должен применить вручную
                            # apply_mass_analysis_results_to_params(saved_progress["results"])
                            # save_param_values_to_file()
                
                # Получаем все артикулы из основной таблицы для отображения всех товаров
                df = st.session_state.get("df", None)
                display_df = st.session_state.get("display_df", pd.DataFrame())
                
                # Используем основной df, если он есть, иначе display_df
                source_df = None
                if df is not None and not df.empty and "Артикул" in df.columns:
                    source_df = df
                elif not display_df.empty and "Артикул" in display_df.columns:
                    source_df = display_df
                
                # Создаем полный список результатов: обработанные + необработанные товары
                all_results = []
                
                # Создаем словарь обработанных товаров для быстрого поиска
                processed_skus = {str(r.get("Артикул", "")).replace(".0", "") for r in mass_analysis_results}
                
                # Добавляем обработанные товары
                all_results.extend(mass_analysis_results)
                
                # Добавляем необработанные товары из основной таблицы
                if source_df is not None and not source_df.empty:
                    for _, row in source_df.iterrows():
                        sku = str(row.get("Артикул", "")).replace(".0", "")
                        if sku and sku not in processed_skus:
                            # Создаем запись для необработанного товара
                            wb_url = build_wb_product_url(sku)
                            
                            # Получаем параметры из param_values, если они есть
                            param_values = get_param_values()
                            unprocessed_row = {
                                "Артикул": sku,
                                "URL": wb_url,
                                "Статус": "⏳ Необработан"
                            }
                            
                            # Добавляем параметры, если они есть (исключаем удаленные)
                            deleted_params = st.session_state.get("deleted_params", load_deleted_params_from_file())
                            for param_name, sku_values in param_values.items():
                                if param_name not in deleted_params and sku in sku_values:
                                    unprocessed_row[param_name] = sku_values[sku]
                            
                            all_results.append(unprocessed_row)
                
                # Обновляем mass_analysis_results для использования в остальном коде
                mass_analysis_results = all_results
                
                # Очищаем удаленные параметры из результатов перед отображением
                mass_analysis_results = remove_deleted_params_from_mass_results(mass_analysis_results)
                st.session_state["mass_analysis_results"] = mass_analysis_results
                
                if mass_analysis_results:
                    results_df = pd.DataFrame(mass_analysis_results)
                    
                    # Фильтруем удаленные параметры из столбцов DataFrame
                    deleted_params = st.session_state.get("deleted_params", set())
                    if not isinstance(deleted_params, set):
                        deleted_params = set(deleted_params) if deleted_params else set()
                    
                    # Удаляем столбцы, которые являются удаленными параметрами
                    cols_to_keep = [col for col in results_df.columns if col not in deleted_params]
                    if cols_to_keep:
                        results_df = results_df[cols_to_keep]
                    
                    # Категоризируем результаты
                    success_results = [r for r in mass_analysis_results if r.get("Статус", "").startswith("✅")]
                    error_results = [r for r in mass_analysis_results if "❌" in r.get("Статус", "") or "Ошибка" in r.get("Статус", "")]
                    undefined_results = [r for r in mass_analysis_results if "⚠️ Параметры не определены" in r.get("Статус", "")]
                    skipped_results = [r for r in mass_analysis_results if "⏭️" in r.get("Статус", "")]
                    unprocessed_results = [r for r in mass_analysis_results if "⏳ Необработан" in r.get("Статус", "")]
                    
                    # Определяем товары с неполными параметрами
                    param_values = get_param_values()
                    all_param_names = list(st.session_state.get("param_options", {}).keys())
                    incomplete_params_results = []
                    
                    if all_param_names and param_values:
                        for result in success_results:
                            sku_raw = result.get("Артикул", "")
                            if not sku_raw:
                                continue
                            sku_str = str(sku_raw).replace(".0", "")
                            
                            # Подсчитываем заполненные параметры
                            filled_params_count = 0
                            for param_name in all_param_names:
                                # Проверяем в param_values
                                if param_name in param_values and sku_str in param_values[param_name]:
                                    value = param_values[param_name][sku_str]
                                    if value and str(value).strip():
                                        filled_params_count += 1
                                # Также проверяем в самом результате
                                elif param_name in result and result[param_name] and str(result[param_name]).strip():
                                    filled_params_count += 1
                            
                            # Если заполнены не все параметры, но хотя бы один - это неполные параметры
                            if 0 < filled_params_count < len(all_param_names):
                                incomplete_params_results.append(result)
                    
                    # Статистика по результатам
                    success_count = len(success_results)
                    error_count = len(error_results)
                    undefined_count = len(undefined_results)
                    skipped_count = len(skipped_results)
                    unprocessed_count = len(unprocessed_results)
                    incomplete_count = len(incomplete_params_results)
                    total_count = len(mass_analysis_results)
                    
                    col_stats1, col_stats2, col_stats3, col_stats4, col_stats5, col_stats6, col_stats7 = st.columns(7)
                    with col_stats1:
                        st.metric("✅ Успешно", success_count, delta=f"{success_count/total_count*100:.1f}%" if total_count > 0 else "0%")
                    with col_stats2:
                        st.metric("⚠️ Неопределено", undefined_count, delta=f"{undefined_count/total_count*100:.1f}%" if total_count > 0 else "0%")
                    with col_stats3:
                        st.metric("❌ Ошибки", error_count, delta=f"{error_count/total_count*100:.1f}%" if total_count > 0 else "0%")
                    with col_stats4:
                        st.metric("⏭️ Пропущено", skipped_count, delta=f"{skipped_count/total_count*100:.1f}%" if total_count > 0 else "0%")
                    with col_stats5:
                        st.metric("⏳ Необработан", unprocessed_count, delta=f"{unprocessed_count/total_count*100:.1f}%" if total_count > 0 else "0%")
                    with col_stats6:
                        st.metric("📝 Неполные", incomplete_count, delta=f"{incomplete_count/total_count*100:.1f}%" if total_count > 0 else "0%")
                    with col_stats7:
                        st.metric("📦 Всего", total_count)
                    
                    # Фильтр для таблицы результатов
                    st.markdown("**🔍 Фильтр результатов:**")
                    filter_options = ["Все результаты", "✅ Успешно", "⚠️ Неопределено", "❌ Ошибки", "⏭️ Пропущено", "⏳ Необработан", "📝 Неполные параметры"]
                    selected_filter = st.radio(
                        "Показать:",
                        options=filter_options,
                        horizontal=True,
                        key="results_filter_radio"
                    )
                    
                    # Применяем фильтр
                    if selected_filter == "✅ Успешно":
                        filtered_results = success_results
                    elif selected_filter == "⚠️ Неопределено":
                        filtered_results = undefined_results
                    elif selected_filter == "❌ Ошибки":
                        filtered_results = error_results
                    elif selected_filter == "⏭️ Пропущено":
                        filtered_results = skipped_results
                    elif selected_filter == "⏳ Необработан":
                        filtered_results = unprocessed_results
                    elif selected_filter == "📝 Неполные параметры":
                        filtered_results = incomplete_params_results
                    else:
                        filtered_results = mass_analysis_results
                    
                    # Отображаем отфильтрованную таблицу (ВСЕГДА)
                    if filtered_results:
                        filtered_df = pd.DataFrame(filtered_results)
                        
                        # Фильтруем удаленные параметры из столбцов DataFrame
                        deleted_params = st.session_state.get("deleted_params", set())
                        if not isinstance(deleted_params, set):
                            deleted_params = set(deleted_params) if deleted_params else set()
                        
                        # Удаляем столбцы, которые являются удаленными параметрами
                        cols_to_keep = [col for col in filtered_df.columns if col not in deleted_params]
                        filtered_df = filtered_df[cols_to_keep] if cols_to_keep else filtered_df
                        
                        # Убеждаемся, что все колонки отображаются
                        # Переупорядочиваем колонки: сначала основные, потом параметры
                        main_cols = ["Артикул", "URL", "Статус", "Параметры"]
                        param_cols = [col for col in filtered_df.columns if col not in main_cols]
                        column_order = [col for col in main_cols if col in filtered_df.columns] + param_cols
                        
                        # Переупорядочиваем DataFrame
                        if column_order:
                            filtered_df = filtered_df[column_order]
                        
                        st.dataframe(
                            filtered_df, 
                            use_container_width=True,
                            height=400,
                            key="mass_analysis_results_table"
                        )
                    else:
                        # Показываем пустую таблицу с заголовками
                        empty_cols = ["Артикул", "URL", "Статус"]
                        # Добавляем колонки параметров, если они есть
                        if mass_analysis_results:
                            # Берем все уникальные ключи из результатов
                            sample_result = mass_analysis_results[0] if mass_analysis_results else {}
                            for key in sample_result.keys():
                                if key not in empty_cols and key not in ["Артикул", "URL", "Статус", "Параметры"]:
                                    empty_cols.append(key)
                        empty_df = pd.DataFrame(columns=empty_cols)
                        st.dataframe(
                            empty_df,
                            use_container_width=True,
                            key="mass_analysis_results_table_empty"
                        )
                        st.info(f"ℹ️ Нет результатов для категории '{selected_filter}'")
                    
                    # Кнопка для применения параметров в общую таблицу
                    st.divider()
                    col_apply1, col_apply2 = st.columns([1, 2])
                    with col_apply1:
                        if st.button("💾 Применить параметры в общую таблицу", type="primary", use_container_width=True, key="apply_mass_results_to_table"):
                            # Параметры уже сохранены в session_state через save_param_value во время массового анализа
                            # Но нужно обновить основную таблицу, чтобы отобразить новые параметры
                            if save_param_values_to_file():
                                st.success(f"✅ Параметры применены в общую таблицу! Обновлено {success_count} товаров.")
                                # Обновляем таблицу для отображения новых параметров
                                if "df" in st.session_state:
                                    # Перезагружаем данные, чтобы показать новые параметры
                                    st.session_state["data_loaded"] = False
                                st.rerun()
                            else:
                                st.error("❌ Ошибка при сохранении параметров")
                    with col_apply2:
                        st.info("💡 Параметры из успешных результатов массового анализа будут применены в основную таблицу. Существующие параметры будут обновлены.")
                    
                    # Экспорт/Импорт результатов в CSV
                    st.divider()
                    st.markdown("#### 💾 Экспорт / Импорт результатов")
                    col_export1, col_export2 = st.columns(2)
                    
                    with col_export1:
                        # Экспорт в CSV
                        if st.button("📥 Экспорт результатов в CSV", type="secondary", use_container_width=True, key="export_mass_results_csv"):
                            csv_data = export_mass_analysis_results_to_csv(mass_analysis_results)
                            if csv_data:
                                timestamp = pd.Timestamp.now().strftime("%Y%m%d_%H%M%S")
                                st.download_button(
                                    label="💾 Скачать CSV файл",
                                    data=csv_data,
                                    file_name=f"mass_analysis_results_{timestamp}.csv",
                                    mime="text/csv",
                                    key="download_mass_results_csv"
                                )
                                st.success(f"✅ Результаты подготовлены к экспорту! Всего записей: {len(mass_analysis_results)}")
                            else:
                                st.error("❌ Ошибка при экспорте результатов")
                    
                    with col_export2:
                        # Импорт из CSV
                        st.markdown("**Импорт из CSV:**")
                        uploaded_file = st.file_uploader(
                            "Загрузите CSV файл с результатами",
                            type=['csv'],
                            key="import_mass_results_csv"
                        )
                        if uploaded_file is not None:
                            try:
                                csv_data = uploaded_file.read().decode('utf-8-sig')
                                imported_count, applied_count = import_mass_analysis_results_from_csv(csv_data)
                                if imported_count > 0:
                                    st.success(f"✅ Импортировано записей: {imported_count}, применено параметров: {applied_count}")
                                    st.info("💡 Параметры автоматически применены. Обновите страницу, чтобы увидеть изменения.")
                                    st.rerun()
                                else:
                                    st.warning("⚠️ Не удалось импортировать данные из CSV файла")
                            except Exception as e:
                                st.error(f"❌ Ошибка при импорте CSV: {e}")
                    
                    st.divider()
                    
                    # Анализируем результаты для определения товаров, требующих повторной обработки
                    error_results = [r for r in mass_analysis_results if not r.get("Статус", "").startswith("✅")]
                    undefined_results = [r for r in mass_analysis_results if "⚠️ Параметры не определены" in r.get("Статус", "")]
                    
                    # Проверяем товары с незаполненными параметрами
                    param_values = get_param_values()
                    all_param_names = list(st.session_state.get("param_options", {}).keys())
                    skus_with_empty_params = []
                    
                    if all_param_names and param_values:
                        # Получаем все артикулы из таблицы
                        source_df = st.session_state.get("df")
                        if source_df is None:
                            source_df = st.session_state.get("display_df")
                        if source_df is not None and "Артикул" in source_df.columns:
                            for sku in source_df["Артикул"].dropna().unique():
                                sku_str = str(sku).replace(".0", "")
                                # Проверяем, заполнены ли все параметры для этого товара
                                filled_params_count = 0
                                for param_name in all_param_names:
                                    if param_name in param_values and sku_str in param_values[param_name]:
                                        value = param_values[param_name][sku_str]
                                        if value and str(value).strip():
                                            filled_params_count += 1
                                
                                # Если ни один параметр не заполнен, добавляем в список
                                if filled_params_count == 0:
                                    skus_with_empty_params.append(sku_str)
                    
                    # Показываем кнопки для повторной обработки
                    if error_results or undefined_results or skus_with_empty_params:
                        st.markdown("#### 🔄 Повторная обработка товаров")
                        
                        col_retry1, col_retry2, col_retry3 = st.columns(3)
                        
                        with col_retry1:
                            if error_results:
                                if st.button(f"🔄 Обработать товары с ошибками ({len(error_results)})", type="primary", use_container_width=True, key="retry_errors_from_results_top"):
                                    retry_skus = [str(r["Артикул"]) for r in error_results]
                                    success_results = [r for r in mass_analysis_results if r.get("Статус", "").startswith("✅")]
                                    
                                    retry_settings = {
                                        "max_images": st.session_state.get("mass_max_images_slider", 5),
                                        "delay": st.session_state.get("mass_delay_slider", 2.0),
                                        "selected_params": st.session_state.get("mass_selected_params_multiselect", [])
                                    }
                                    
                                    retry_progress = {
                                        "skus_to_process": retry_skus,
                                        "processed_skus": [],
                                        "results": success_results,
                                        "settings": retry_settings,
                                        "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
                                        "is_retry": True
                                    }
                                    
                                    save_mass_analysis_progress(
                                        retry_skus,
                                        set(),
                                        success_results,
                                        retry_settings
                                    )
                                    
                                    st.session_state["resume_mass_analysis"] = True
                                    st.session_state["saved_progress"] = retry_progress
                                    st.success(f"✅ Запланирована повторная обработка {len(retry_skus)} товаров с ошибками")
                                    st.rerun()
                            else:
                                st.info("✅ Нет товаров с ошибками")
                        
                        with col_retry2:
                            if undefined_results:
                                if st.button(f"🔄 Обработать товары с неопределенными параметрами ({len(undefined_results)})", type="primary", use_container_width=True, key="retry_undefined_from_results_top"):
                                    retry_skus = [str(r["Артикул"]) for r in undefined_results]
                                    success_results = [r for r in mass_analysis_results if r.get("Статус", "").startswith("✅")]
                                    
                                    retry_settings = {
                                        "max_images": st.session_state.get("mass_max_images_slider", 5),
                                        "delay": st.session_state.get("mass_delay_slider", 2.0),
                                        "selected_params": st.session_state.get("mass_selected_params_multiselect", [])
                                    }
                                    
                                    retry_progress = {
                                        "skus_to_process": retry_skus,
                                        "processed_skus": [],
                                        "results": success_results,
                                        "settings": retry_settings,
                                        "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
                                        "is_retry": True
                                    }
                                    
                                    save_mass_analysis_progress(
                                        retry_skus,
                                        set(),
                                        success_results,
                                        retry_settings
                                    )
                                    
                                    st.session_state["resume_mass_analysis"] = True
                                    st.session_state["saved_progress"] = retry_progress
                                    st.success(f"✅ Запланирована повторная обработка {len(retry_skus)} товаров с неопределенными параметрами")
                                    st.rerun()
                            else:
                                st.info("✅ Нет товаров с неопределенными параметрами")
                        
                        with col_retry3:
                            if skus_with_empty_params:
                                if st.button(f"🔄 Обработать товары с незаполненными параметрами ({len(skus_with_empty_params)})", type="primary", use_container_width=True, key="retry_empty_params_from_results_top"):
                                    success_results = [r for r in mass_analysis_results if r.get("Статус", "").startswith("✅")]
                                    
                                    retry_settings = {
                                        "max_images": st.session_state.get("mass_max_images_slider", 5),
                                        "delay": st.session_state.get("mass_delay_slider", 2.0),
                                        "selected_params": st.session_state.get("mass_selected_params_multiselect", [])
                                    }
                                    
                                    retry_progress = {
                                        "skus_to_process": skus_with_empty_params,
                                        "processed_skus": [],
                                        "results": success_results,
                                        "settings": retry_settings,
                                        "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
                                        "is_retry": True
                                    }
                                    
                                    save_mass_analysis_progress(
                                        skus_with_empty_params,
                                        set(),
                                        success_results,
                                        retry_settings
                                    )
                                    
                                    st.session_state["resume_mass_analysis"] = True
                                    st.session_state["saved_progress"] = retry_progress
                                    st.success(f"✅ Запланирована обработка {len(skus_with_empty_params)} товаров с незаполненными параметрами")
                                    st.rerun()
                            else:
                                st.info("✅ Нет товаров с незаполненными параметрами")
                        
                        # Общая кнопка для обработки всех проблемных товаров
                        if (error_results or undefined_results or skus_with_empty_params):
                            st.divider()
                            all_problem_skus = set()
                            if error_results:
                                all_problem_skus.update([str(r["Артикул"]) for r in error_results])
                            if undefined_results:
                                all_problem_skus.update([str(r["Артикул"]) for r in undefined_results])
                            if skus_with_empty_params:
                                all_problem_skus.update(skus_with_empty_params)
                            
                            if all_problem_skus:
                                if st.button(f"🔄 Обработать ВСЕ проблемные товары ({len(all_problem_skus)})", type="primary", use_container_width=True, key="retry_all_problems_from_results_top"):
                                    success_results = [r for r in mass_analysis_results if r.get("Статус", "").startswith("✅")]
                                    
                                    retry_settings = {
                                        "max_images": st.session_state.get("mass_max_images_slider", 5),
                                        "delay": st.session_state.get("mass_delay_slider", 2.0),
                                        "selected_params": st.session_state.get("mass_selected_params_multiselect", [])
                                    }
                                    
                                    retry_progress = {
                                        "skus_to_process": list(all_problem_skus),
                                        "processed_skus": [],
                                        "results": success_results,
                                        "settings": retry_settings,
                                        "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
                                        "is_retry": True
                                    }
                                    
                                    save_mass_analysis_progress(
                                        list(all_problem_skus),
                                        set(),
                                        success_results,
                                        retry_settings
                                    )
                                    
                                    st.session_state["resume_mass_analysis"] = True
                                    st.session_state["saved_progress"] = retry_progress
                                    st.success(f"✅ Запланирована обработка {len(all_problem_skus)} проблемных товаров")
                                    st.rerun()
                else:
                    # Если результатов нет, показываем пустую таблицу и сообщение
                    # Но сначала еще раз пытаемся загрузить из файлов (на случай, если файл появился)
                    saved_results = load_mass_analysis_results()
                    if saved_results:
                        mass_analysis_results = saved_results
                        st.session_state["mass_analysis_results"] = saved_results
                        st.success(f"✅ Загружено {len(saved_results)} результатов из сохраненного файла")
                        st.rerun()
                    else:
                        saved_progress = load_mass_analysis_progress()
                        if saved_progress and saved_progress.get("results"):
                            mass_analysis_results = saved_progress["results"]
                            st.session_state["mass_analysis_results"] = saved_progress["results"]
                            save_mass_analysis_results(saved_progress["results"])
                            st.success(f"✅ Загружено {len(saved_progress['results'])} результатов из прогресса")
                            st.rerun()
                        else:
                            st.info("ℹ️ Результаты массового анализа будут отображаться здесь после запуска анализа")
                            # Создаем пустую таблицу с основными колонками
                            empty_df = pd.DataFrame(columns=["Артикул", "URL", "Статус"])
                            st.dataframe(
                                empty_df,
                                use_container_width=True,
                                key="mass_analysis_results_table_no_data"
                            )
                    
                    st.divider()
                
                st.info("💡 Система автоматически проанализирует все товары из таблицы ниже. Для каждого товара будут получены изображения через screenshotapi.net и проанализированы через нейросеть.")
                
                # Проверяем наличие таблицы - используем основной df из session_state
                df = st.session_state.get("df", None)
                display_df = st.session_state.get("display_df", pd.DataFrame())
                
                # Используем основной df, если он есть, иначе display_df
                if df is not None and not df.empty and "Артикул" in df.columns:
                    source_df = df
                elif not display_df.empty and "Артикул" in display_df.columns:
                    source_df = display_df
                else:
                    source_df = None
                
                if source_df is None or source_df.empty or "Артикул" not in source_df.columns:
                    # Проверяем, есть ли вообще данные в session_state
                    if st.session_state.get("df") is None:
                        st.warning("⚠️ Файл не загружен. Загрузите файл с данными товаров в первой вкладке.")
                    else:
                        st.warning("⚠️ В таблице нет данных с артикулами. Убедитесь, что файл содержит колонку 'Артикул'.")
                else:
                    # Получаем список артикулов из таблицы в порядке их появления в таблице
                    # Порядок соответствует порядку строк в исходной таблице (сверху вниз)
                    skus = source_df["Артикул"].dropna().unique()
                    skus = [str(sku).replace(".0", "") for sku in skus if str(sku).strip()]
                    
                    if not skus:
                        st.warning("⚠️ В таблице нет артикулов для анализа.")
                    else:
                        st.success(f"✅ Найдено товаров в таблице: **{len(skus)}**")
                        
                        # Выбор параметров для анализа (скрыто в expander)
                        all_param_names = list(st.session_state.get("param_options", {}).keys())
                        mass_selected_params = []
                        
                        if all_param_names:
                            with st.expander("⚙️ Настройки анализа (опционально)", expanded=False):
                                st.markdown("**📋 Выберите параметры для анализа:**")
                                st.info("💡 Выберите конкретные параметры, которые нужно определить через нейросеть. Если не выбрано, будут анализироваться все доступные параметры.")
                                mass_selected_params = st.multiselect(
                                    "Параметры для анализа:",
                                    options=all_param_names,
                                    default=[],  # По умолчанию пусто - будут анализироваться все
                                    help="Оставьте пустым, чтобы анализировать все параметры. Или выберите конкретные параметры.",
                                    key="mass_selected_params_multiselect"
                                )
                        else:
                            st.warning("⚠️ Нет доступных параметров. Добавьте параметры в разделе 'Управление параметрами'.")
                        
                        st.divider()
                        
                        col_mass1, col_mass2, col_mass3 = st.columns(3)
                        with col_mass1:
                            mass_max_images = st.slider(
                                "Изображений на товар:",
                                min_value=1,
                                max_value=5,
                                value=5,
                                help="Количество изображений для анализа каждого товара",
                                key="mass_max_images_slider"
                            )
                        
                        with col_mass2:
                            mass_delay = st.slider(
                                "Задержка между товарами (сек):",
                                min_value=1.0,
                                max_value=10.0,
                                value=2.0,
                                step=0.5,
                                help="Задержка между обработкой товаров для избежания rate limit",
                                key="mass_delay_slider"
                            )
                        
                        with col_mass3:
                            mass_limit = st.number_input(
                                "Ограничение количества товаров:",
                                min_value=0,
                                max_value=len(skus),
                                value=len(skus),
                                help="0 = все товары",
                                key="mass_limit_input"
                            )
                        
                        # Опция фильтрации товаров без фото
                        st.divider()
                        filter_no_images = st.checkbox(
                            "🔍 Обрабатывать только товары БЕЗ скачанных фото",
                            value=False,
                            help="Если включено, будут обработаны только товары, у которых нет скачанных изображений через screenshotapi",
                            key="filter_no_images_checkbox"
                        )
                        
                        if filter_no_images:
                            # Проверяем, сколько товаров без фото
                            skus_without_images = []
                            with st.spinner("Проверка наличия фото..."):
                                for sku in skus:
                                    if not has_downloaded_images(sku, min_images=1):
                                        skus_without_images.append(sku)
                            
                            if skus_without_images:
                                st.success(f"✅ Найдено товаров без фото: **{len(skus_without_images)}** из {len(skus)}")
                                with st.expander("👀 Превью товаров без фото", expanded=False):
                                    for idx, sku in enumerate(skus_without_images[:10], 1):
                                        wb_url = build_wb_product_url(sku)
                                        st.write(f"{idx}. Артикул: {sku} - [Открыть на WB]({wb_url})")
                                    if len(skus_without_images) > 10:
                                        st.write(f"... и еще {len(skus_without_images) - 10} товаров")
                            else:
                                st.info("ℹ️ У всех товаров уже есть скачанные фото")
                        
                        # Проверяем наличие сохраненного прогресса
                        saved_progress = load_mass_analysis_progress()
                        if saved_progress:
                            processed_count = len(saved_progress.get('processed_skus', []))
                            total_count = len(saved_progress.get('skus_to_process', []))
                            remaining_count = total_count - processed_count
                            
                            with st.expander("📥 Найден сохраненный прогресс", expanded=False):
                                st.info(f"**Сохранено:** {saved_progress.get('timestamp', 'неизвестно')}")
                                st.write(f"**Всего товаров:** {total_count}")
                                st.write(f"**Обработано:** {processed_count}")
                                st.write(f"**Осталось:** {remaining_count}")
                                
                                # Показываем статистику по ошибкам
                                saved_results = saved_progress.get('results', [])
                                if saved_results:
                                    error_results = [r for r in saved_results if not r.get("Статус", "").startswith("✅")]
                                    success_results = [r for r in saved_results if r.get("Статус", "").startswith("✅")]
                                    st.write(f"**Успешно:** {len(success_results)}")
                                    st.write(f"**С ошибками:** {len(error_results)}")
                                st.info("💡 Используйте кнопку '▶️ Продолжить' ниже для возобновления анализа")
                                
                                if st.button("🗑️ Удалить сохраненный прогресс", key="clear_progress_btn"):
                                    clear_mass_analysis_progress()
                                    st.success("✅ Прогресс удален")
                                    st.rerun()
                        
                        # Автоматическое возобновление, если есть сохраненный прогресс и не было явного запуска нового анализа
                        auto_resume = saved_progress and not st.session_state.get("mass_analysis_btn_clicked", False)
                        
                        # Показываем кнопки управления анализом
                        col_start, col_resume, col_stop = st.columns([1, 1, 1])
                        with col_start:
                            if st.button("🚀 Запустить массовый анализ", type="primary", key="mass_analysis_btn", disabled=is_analysis_running, use_container_width=True):
                                st.session_state["mass_analysis_btn_clicked"] = True
                                # Сбрасываем флаг продолжения при новом запуске
                                if "resume_mass_analysis" in st.session_state:
                                    del st.session_state["resume_mass_analysis"]
                                st.rerun()
                        with col_resume:
                            if saved_progress and not is_analysis_running:
                                if st.button("▶️ Продолжить", type="primary", key="continue_analysis_btn", use_container_width=True):
                                    st.session_state["resume_mass_analysis"] = True
                                    st.session_state["saved_progress"] = saved_progress
                                    st.session_state["mass_analysis_btn_clicked"] = True
                                    st.rerun()
                            else:
                                st.write("")  # Пустое место для выравнивания
                        with col_stop:
                            if is_analysis_running:
                                if st.button("⏹️ Остановить анализ", type="secondary", key="stop_mass_analysis_btn", use_container_width=True):
                                    st.session_state["mass_analysis_btn_clicked"] = False
                                    st.session_state["mass_analysis_stopped"] = True
                                    st.warning("⚠️ Анализ остановлен пользователем")
                                    st.rerun()
                            else:
                                st.write("")  # Пустое место для выравнивания
                        
                        # Запускаем анализ, если кнопка была нажата
                        if st.session_state.get("mass_analysis_btn_clicked", False) and not st.session_state.get("mass_analysis_stopped", False):
                            
                            # Фильтруем товары без фото, если включена опция
                            if filter_no_images:
                                skus_filtered = []
                                with st.spinner("Фильтрация товаров без фото..."):
                                    for sku in skus:
                                        if not has_downloaded_images(sku, min_images=1):
                                            skus_filtered.append(sku)
                                skus = skus_filtered
                                
                                if not skus:
                                    st.warning("⚠️ Нет товаров без фото для обработки")
                                    st.stop()
                            
                            # Ограничиваем количество товаров, если указано
                            if mass_limit > 0:
                                skus_to_process = skus[:mass_limit]
                            else:
                                skus_to_process = skus
                            
                            if skus_to_process:
                                # Проверяем, нужно ли возобновить с сохраненного прогресса
                                resume_analysis = st.session_state.get("resume_mass_analysis", False) or auto_resume
                                saved_progress_data = st.session_state.get("saved_progress", None) or saved_progress
                                
                                # Начинаем массовый анализ
                                mass_progress_bar = st.progress(0)
                                mass_status_text = st.empty()
                                mass_results_container = st.container()
                                
                                api_key = st.session_state.get('openai_api_key', '')
                                
                                if not api_key:
                                    st.error("❌ Необходимо указать API ключ OpenAI в настройках выше")
                                else:
                                    # Если возобновляем, используем сохраненные данные
                                    if resume_analysis and saved_progress_data:
                                        skus_to_process = saved_progress_data.get("skus_to_process", skus_to_process)
                                        processed_skus = set(saved_progress_data.get("processed_skus", []))
                                        mass_results = saved_progress_data.get("results", [])
                                        settings = saved_progress_data.get("settings", {})
                                        mass_max_images = settings.get("max_images", mass_max_images)
                                        mass_delay = settings.get("delay", mass_delay)
                                        # Восстанавливаем выбранные параметры из сохраненного прогресса
                                        mass_selected_params = settings.get("selected_params", [])
                                        
                                        # Проверяем, это повторная обработка ошибок
                                        is_retry = saved_progress_data.get("is_retry", False)
                                        
                                        # Показываем информацию о возобновлении
                                        remaining_count = len(skus_to_process) - len(processed_skus)
                                        if is_retry:
                                            st.info(f"🔄 Повторная обработка товаров с ошибками: {len(skus_to_process)} товаров. Успешные результаты ({len(mass_results)}) будут сохранены.")
                                        else:
                                            st.info(f"🔄 Возобновление анализа: обработано {len(processed_skus)} из {len(skus_to_process)}, осталось {remaining_count}")
                                        
                                        st.session_state["resume_mass_analysis"] = False
                                        st.session_state["saved_progress"] = None
                                    else:
                                        processed_skus = set()
                                        mass_results = []
                                        # Используем выбранные параметры или все доступные
                                        selected_params_for_analysis = mass_selected_params if mass_selected_params else None
                                        settings = {
                                            "max_images": mass_max_images,
                                            "delay": mass_delay,
                                            "selected_params": selected_params_for_analysis
                                        }
                                    
                                    total_skus = len(skus_to_process)
                                    mass_success_count = len([r for r in mass_results if r.get("Статус", "").startswith("✅")])
                                    mass_error_count = len([r for r in mass_results if not r.get("Статус", "").startswith("✅")])
                                    
                                    with mass_results_container:
                                        st.markdown("### 📊 Результаты массового анализа")
                                        results_table_placeholder = st.empty()
                                        apply_button_placeholder = st.empty()
                                        
                                        # Показываем уже обработанные результаты сразу при возобновлении
                                        if mass_results:
                                            # Пересчитываем счетчики из актуальных результатов
                                            current_success_count = len([r for r in mass_results if r.get("Статус", "").startswith("✅")])
                                            current_error_count = len([r for r in mass_results if not r.get("Статус", "").startswith("✅")])
                                            
                                            results_df = pd.DataFrame(mass_results)
                                            
                                            # Фильтруем удаленные параметры из столбцов DataFrame
                                            deleted_params = st.session_state.get("deleted_params", set())
                                            if not isinstance(deleted_params, set):
                                                deleted_params = set(deleted_params) if deleted_params else set()
                                            
                                            # Удаляем столбцы, которые являются удаленными параметрами
                                            cols_to_keep = [col for col in results_df.columns if col not in deleted_params]
                                            if cols_to_keep:
                                                results_df = results_df[cols_to_keep]
                                            
                                            with results_table_placeholder.container():
                                                st.markdown(f"**📋 Уже обработано: {len(mass_results)} товаров** (✅ Успешно: {current_success_count}, ❌ Ошибок: {current_error_count})")
                                                st.dataframe(results_df, use_container_width=True, height=400)
                                            
                                            # Кнопка для применения параметров - доступна сразу во время обработки
                                            if current_success_count > 0:
                                                with apply_button_placeholder.container():
                                                    st.divider()
                                                    col_apply1, col_apply2 = st.columns([1, 2])
                                                    with col_apply1:
                                                        if st.button("💾 Применить параметры в общую таблицу", type="primary", use_container_width=True, key="apply_mass_results_final"):
                                                            # Сохраняем параметры в файл
                                                            if save_param_values_to_file():
                                                                if save_param_history_to_file():
                                                                    # Перезагружаем параметры из файла, чтобы убедиться, что они применены
                                                                    load_param_values_from_file()
                                                                    current_success_count = len([r for r in mass_results if r.get("Статус", "").startswith("✅")])
                                                                    st.success(f"✅ Параметры применены в общую таблицу! Обновлено {current_success_count} товаров.")
                                                                    # Обновляем таблицу для отображения новых параметров
                                                                    if "df" in st.session_state:
                                                                        # Перезагружаем данные, чтобы показать новые параметры
                                                                        st.session_state["data_loaded"] = False
                                                                        # Очищаем display_df, чтобы он пересоздался с новыми параметрами
                                                                        if "display_df" in st.session_state:
                                                                            del st.session_state["display_df"]
                                                                    st.rerun()
                                                                else:
                                                                    st.error("❌ Ошибка при сохранении истории изменений")
                                                            else:
                                                                st.error("❌ Ошибка при сохранении параметров")
                                                    with col_apply2:
                                                        st.info("💡 Параметры из успешных результатов будут применены в основную таблицу. Можно нажимать во время обработки.")
                                    
                                    # Проверяем, не был ли анализ остановлен
                                    if st.session_state.get("mass_analysis_stopped", False):
                                        st.warning("⚠️ Анализ был остановлен пользователем")
                                        st.session_state["mass_analysis_stopped"] = False
                                        st.session_state["mass_analysis_btn_clicked"] = False
                                        # Сохраняем текущие результаты
                                        if mass_results:
                                            st.session_state["mass_analysis_results"] = mass_results
                                            save_mass_analysis_results(mass_results)
                                        st.stop()
                                    
                                    # Обрабатываем только необработанные товары
                                    remaining_skus = [sku for sku in skus_to_process if str(sku) not in processed_skus]
                                    
                                    # Если все товары уже обработаны, показываем финальные результаты
                                    if not remaining_skus and mass_results:
                                        st.info("ℹ️ Все товары уже обработаны. Результаты показаны выше.")
                                        mass_progress_bar.progress(1.0)
                                        mass_status_text.empty()
                                        
                                        # Показываем финальные результаты
                                        st.markdown("---")
                                        st.markdown("### 📊 Итоговый отчет массового анализа")
                                        
                                        # Пересчитываем счетчики из актуальных результатов
                                        final_success_count = len([r for r in mass_results if r.get("Статус", "").startswith("✅")])
                                        final_error_count = len([r for r in mass_results if not r.get("Статус", "").startswith("✅")])
                                        
                                        col_success, col_error, col_total = st.columns(3)
                                        with col_success:
                                            st.metric("✅ Успешно", final_success_count)
                                        with col_error:
                                            st.metric("❌ Ошибок", final_error_count)
                                        with col_total:
                                            st.metric("📦 Всего", total_skus)
                                        
                                        # Удаляем сохраненный прогресс
                                        clear_mass_analysis_progress()
                                        
                                        # Сохраняем результаты в session_state
                                        st.session_state["mass_analysis_results"] = mass_results
                                        save_mass_analysis_results(mass_results)
                                        
                                        # Автоматически применяем параметры из результатов
                                        applied_params_count = apply_mass_analysis_results_to_params(mass_results)
                                        if applied_params_count > 0:
                                            # Сохраняем параметры в файл
                                            save_param_values_to_file()
                                        
                                        # Сбрасываем флаг запуска анализа, чтобы старые результаты снова показывались
                                        st.session_state["mass_analysis_btn_clicked"] = False
                                        
                                        # Таблица уже показана выше в mass_results_container, не дублируем
                                        # Кнопка для применения параметров уже доступна выше, но показываем здесь тоже для итогового отчета
                                        # Пересчитываем счетчики из актуальных результатов
                                        final_success_count = len([r for r in mass_results if r.get("Статус", "").startswith("✅")])
                                        if final_success_count > 0:
                                            # Кнопка уже есть в mass_results_container, здесь просто подтверждаем
                                            st.success(f"✅ Анализ завершен! Параметры можно применить кнопкой выше.")
                                        else:
                                            # Сохраняем параметры в файл даже если нет успешных результатов (для истории)
                                            if save_param_values_to_file():
                                                st.info("💾 Параметры сохранены в файл!")
                                            if save_param_history_to_file():
                                                st.info("💾 История изменений сохранена!")
                                        
                                        # Определяем проблемные товары (всегда, не только при mass_error_count > 0)
                                        error_results = [r for r in mass_results if not r.get("Статус", "").startswith("✅")]
                                        undefined_results = [r for r in mass_results if "⚠️ Параметры не определены" in r.get("Статус", "")]
                                        
                                        # Проверяем товары с незаполненными параметрами из таблицы
                                        param_values = get_param_values()
                                        all_param_names = list(st.session_state.get("param_options", {}).keys())
                                        skus_with_empty_params = []
                                        
                                        if all_param_names and param_values:
                                            # Получаем все артикулы из таблицы
                                            source_df = st.session_state.get("df")
                                            if source_df is None:
                                                source_df = st.session_state.get("display_df")
                                            if source_df is not None and "Артикул" in source_df.columns:
                                                for sku in source_df["Артикул"].dropna().unique():
                                                    sku_str = str(sku).replace(".0", "")
                                                    # Проверяем, заполнены ли все параметры для этого товара
                                                    filled_params_count = 0
                                                    for param_name in all_param_names:
                                                        if param_name in param_values and sku_str in param_values[param_name]:
                                                            value = param_values[param_name][sku_str]
                                                            if value and str(value).strip():
                                                                filled_params_count += 1
                                                    
                                                    # Если ни один параметр не заполнен, добавляем в список
                                                    if filled_params_count == 0:
                                                        skus_with_empty_params.append(sku_str)
                                        
                                        # Показываем детальный отчет об ошибках, если есть
                                        # Пересчитываем счетчики из актуальных результатов
                                        final_error_count = len([r for r in mass_results if not r.get("Статус", "").startswith("✅")])
                                        if final_error_count > 0:
                                            st.markdown("---")
                                            st.markdown("### ❌ Детальный отчет об ошибках")
                                            
                                            # Кнопки для обработки разных типов проблемных товаров - показываем всегда, если есть проблемы
                                            if error_results or undefined_results or skus_with_empty_params:
                                                st.markdown("#### 🔄 Повторная обработка товаров")
                                                
                                                # Определяем количество колонок в зависимости от наличия типов ошибок
                                                num_cols = sum([bool(error_results), bool(undefined_results), bool(skus_with_empty_params)])
                                                if num_cols == 1:
                                                    col_retry1, = st.columns(1)
                                                    col_retry2 = None
                                                    col_retry3 = None
                                                elif num_cols == 2:
                                                    col_retry1, col_retry2 = st.columns(2)
                                                    col_retry3 = None
                                                else:
                                                    col_retry1, col_retry2, col_retry3 = st.columns(3)
                                                
                                                # Кнопка для обработки ВСЕХ товаров с ошибками (показываем отдельно)
                                                if error_results:
                                                    st.markdown("**🔄 Обработать все товары с ошибками:**")
                                                    if st.button(f"🔄 Обработать все товары с ошибками ({len(error_results)})", type="primary", use_container_width=True, key="retry_all_errors_final_main"):
                                                        retry_skus = [str(r["Артикул"]) for r in error_results]
                                                        success_results = [r for r in mass_results if r.get("Статус", "").startswith("✅")]
                                                        
                                                        retry_settings = {
                                                            "max_images": mass_max_images,
                                                            "delay": mass_delay,
                                                            "selected_params": settings.get("selected_params", None)
                                                        }
                                                        
                                                        retry_progress = {
                                                            "skus_to_process": retry_skus,
                                                            "processed_skus": [],
                                                            "results": success_results,
                                                            "settings": retry_settings,
                                                            "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
                                                            "is_retry": True
                                                        }
                                                        
                                                        save_mass_analysis_progress(
                                                            retry_skus,
                                                            set(),
                                                            success_results,
                                                            retry_settings
                                                        )
                                                        
                                                        st.session_state["resume_mass_analysis"] = True
                                                        st.session_state["saved_progress"] = retry_progress
                                                        st.success(f"✅ Запланирована обработка {len(retry_skus)} товаров с ошибками")
                                                        st.rerun()
                                                    st.divider()
                                            
                                            if error_results:
                                                error_df = pd.DataFrame(error_results)
                                                error_report_cols = ["Артикул", "URL", "Статус"]
                                                if "Параметры" in error_df.columns:
                                                    error_report_cols.append("Параметры")
                                                
                                                error_report_df = error_df[error_report_cols].copy()
                                            
                                            # Товары с ошибками (исключая неопределенные параметры)
                                            real_errors = [r for r in error_results if "⚠️ Параметры не определены" not in r.get("Статус", "")] if error_results else []
                                            
                                            if col_retry1:
                                                with col_retry1:
                                                    if real_errors:
                                                        if st.button(f"🔄 Ошибки ({len(real_errors)})", type="primary", use_container_width=True, key="retry_real_errors_final"):
                                                            retry_skus = [str(r["Артикул"]) for r in real_errors]
                                                            success_results = [r for r in mass_results if r.get("Статус", "").startswith("✅")]
                                                            
                                                            retry_settings = {
                                                                "max_images": mass_max_images,
                                                                "delay": mass_delay,
                                                                "selected_params": settings.get("selected_params", None)
                                                            }
                                                            
                                                            retry_progress = {
                                                                "skus_to_process": retry_skus,
                                                                "processed_skus": [],
                                                                "results": success_results,
                                                                "settings": retry_settings,
                                                                "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
                                                                "is_retry": True
                                                            }
                                                            
                                                            save_mass_analysis_progress(
                                                                retry_skus,
                                                                set(),
                                                                success_results,
                                                                retry_settings
                                                            )
                                                            
                                                            st.session_state["resume_mass_analysis"] = True
                                                            st.session_state["saved_progress"] = retry_progress
                                                            st.success(f"✅ Запланирована обработка {len(retry_skus)} товаров с ошибками")
                                                            st.rerun()
                                                    elif error_results:
                                                        st.info("✅ Нет товаров с ошибками (кроме неопределенных)")
                                            
                                            if col_retry2:
                                                with col_retry2:
                                                    # Товары с неопределенными параметрами
                                                    if undefined_results:
                                                        if st.button(f"🔄 Неопределенные ({len(undefined_results)})", type="primary", use_container_width=True, key="retry_undefined_params_final"):
                                                            retry_skus = [str(r["Артикул"]) for r in undefined_results]
                                                        success_results = [r for r in mass_results if r.get("Статус", "").startswith("✅")]
                                                        
                                                        retry_settings = {
                                                            "max_images": mass_max_images,
                                                            "delay": mass_delay,
                                                            "selected_params": settings.get("selected_params", None)
                                                        }
                                                        
                                                        retry_progress = {
                                                            "skus_to_process": retry_skus,
                                                            "processed_skus": [],
                                                            "results": success_results,
                                                            "settings": retry_settings,
                                                            "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
                                                            "is_retry": True
                                                        }
                                                        
                                                        save_mass_analysis_progress(
                                                            retry_skus,
                                                            set(),
                                                            success_results,
                                                            retry_settings
                                                        )
                                                        
                                                        st.session_state["resume_mass_analysis"] = True
                                                        st.session_state["saved_progress"] = retry_progress
                                                        st.success(f"✅ Запланирована обработка {len(retry_skus)} товаров с неопределенными параметрами")
                                                        st.rerun()
                                                    else:
                                                        st.info("✅ Нет товаров с неопределенными параметрами")
                                            
                                            if col_retry3:
                                                with col_retry3:
                                                    # Товары с незаполненными параметрами
                                                    if skus_with_empty_params:
                                                        if st.button(f"🔄 Незаполненные ({len(skus_with_empty_params)})", type="primary", use_container_width=True, key="retry_empty_params_final"):
                                                            success_results = [r for r in mass_results if r.get("Статус", "").startswith("✅")]
                                                            
                                                            retry_settings = {
                                                                "max_images": mass_max_images,
                                                                "delay": mass_delay,
                                                                "selected_params": settings.get("selected_params", None)
                                                            }
                                                            
                                                            retry_progress = {
                                                                "skus_to_process": skus_with_empty_params,
                                                                "processed_skus": [],
                                                                "results": success_results,
                                                                "settings": retry_settings,
                                                                "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
                                                                "is_retry": True
                                                            }
                                                            
                                                            save_mass_analysis_progress(
                                                                skus_with_empty_params,
                                                                set(),
                                                                success_results,
                                                                retry_settings
                                                            )
                                                            
                                                            st.session_state["resume_mass_analysis"] = True
                                                            st.session_state["saved_progress"] = retry_progress
                                                            st.success(f"✅ Запланирована обработка {len(skus_with_empty_params)} товаров с незаполненными параметрами")
                                                            st.rerun()
                                            
                                            # Общая кнопка для всех проблемных товаров
                                            all_problem_skus = set()
                                            if real_errors:
                                                all_problem_skus.update([str(r["Артикул"]) for r in real_errors])
                                            if undefined_results:
                                                all_problem_skus.update([str(r["Артикул"]) for r in undefined_results])
                                            if skus_with_empty_params:
                                                all_problem_skus.update(skus_with_empty_params)
                                            
                                            if all_problem_skus:
                                                st.divider()
                                                if st.button(f"🔄 Обработать ВСЕ проблемные товары ({len(all_problem_skus)})", type="primary", use_container_width=True, key="retry_all_problems_final"):
                                                    success_results = [r for r in mass_results if r.get("Статус", "").startswith("✅")]
                                                    
                                                    retry_settings = {
                                                        "max_images": mass_max_images,
                                                        "delay": mass_delay,
                                                        "selected_params": settings.get("selected_params", None)
                                                    }
                                                    
                                                    retry_progress = {
                                                        "skus_to_process": list(all_problem_skus),
                                                        "processed_skus": [],
                                                        "results": success_results,
                                                        "settings": retry_settings,
                                                        "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
                                                        "is_retry": True
                                                    }
                                                    
                                                    save_mass_analysis_progress(
                                                        list(all_problem_skus),
                                                        set(),
                                                        success_results,
                                                        retry_settings
                                                    )
                                                    
                                                    st.session_state["resume_mass_analysis"] = True
                                                    st.session_state["saved_progress"] = retry_progress
                                                    st.success(f"✅ Запланирована обработка {len(all_problem_skus)} проблемных товаров")
                                                    st.rerun()
                                                
                                                st.markdown("#### 📋 Все товары с ошибками")
                                                st.dataframe(error_report_df, use_container_width=True, height=400)
                                                
                                                # Экспорт в CSV
                                                csv = error_report_df.to_csv(index=False).encode('utf-8-sig')
                                                st.download_button(
                                                    label="📥 Скачать отчет об ошибках (CSV)",
                                                    data=csv,
                                                    file_name=f"mass_analysis_errors_{pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')}.csv",
                                                    mime="text/csv",
                                                    key="download_errors_csv_final"
                                                )
                                        
                                    
                                    # Обрабатываем только если есть необработанные товары
                                    if remaining_skus:
                                        import time
                                        previous_product_time = None  # Время обработки предыдущего товара
                                        
                                        for idx, sku in enumerate(remaining_skus):
                                            # Проверяем, не был ли анализ остановлен
                                            if st.session_state.get("mass_analysis_stopped", False) or not st.session_state.get("mass_analysis_btn_clicked", False):
                                                st.warning("⚠️ Анализ был остановлен")
                                                # Сохраняем текущие результаты
                                                if mass_results:
                                                    st.session_state["mass_analysis_results"] = mass_results
                                                    save_mass_analysis_results(mass_results)
                                                    # Автоматически применяем параметры из результатов
                                                    apply_mass_analysis_results_to_params(mass_results)
                                                    save_param_values_to_file()
                                                st.session_state["mass_analysis_stopped"] = False
                                                st.session_state["mass_analysis_btn_clicked"] = False
                                                break
                                            
                                            # Находим реальный индекс товара в исходном списке skus_to_process
                                            # Это важно для правильного отображения номера позиции [X/96]
                                            try:
                                                processed_idx = skus_to_process.index(str(sku))
                                            except (ValueError, AttributeError):
                                                # Если не найден (не должно быть), используем текущую логику как fallback
                                                processed_idx = len(processed_skus) + idx
                                            
                                            # Формируем URL товара
                                            wb_url = build_wb_product_url(sku)
                                            
                                            # Засекаем время начала обработки товара
                                            product_start_time = time.time()
                                            
                                            # Формируем строку статуса с информацией о времени
                                            prev_time_str = ""
                                            if previous_product_time is not None:
                                                prev_time_str = f" | ⏱️ Предыдущий: {previous_product_time:.1f}с"
                                            
                                            mass_status_text.text(f"🔄 Обработка товара {processed_idx + 1}/{total_skus}: Артикул {sku}...{prev_time_str}")
                                            # Ограничиваем значение progress до максимум 1.0
                                            progress_value = min((processed_idx) / total_skus, 1.0)
                                            mass_progress_bar.progress(progress_value)
                                            
                                            # Получаем параметры через анализ изображений
                                            try:
                                                # Передаем выбранные параметры для анализа (из настроек или из текущего выбора)
                                                if resume_analysis and saved_progress_data:
                                                    selected_params_for_analysis = settings.get("selected_params", None)
                                                else:
                                                    selected_params_for_analysis = mass_selected_params if mass_selected_params else None
                                                
                                                # Этап 1: Получение изображений
                                                elapsed = time.time() - product_start_time
                                                prev_time_str = f" | ⏱️ Предыдущий: {previous_product_time:.1f}с" if previous_product_time else ""
                                                mass_status_text.text(f"📸 [{processed_idx + 1}/{total_skus}] Артикул {sku}: Получение изображений... | ⏱️ Текущий: {elapsed:.1f}с{prev_time_str}")
                                                
                                                # Этап 2: Анализ изображений через AI
                                                elapsed = time.time() - product_start_time
                                                prev_time_str = f" | ⏱️ Предыдущий: {previous_product_time:.1f}с" if previous_product_time else ""
                                                mass_status_text.text(f"🤖 [{processed_idx + 1}/{total_skus}] Артикул {sku}: Анализ через нейросеть... | ⏱️ Текущий: {elapsed:.1f}с{prev_time_str}")
                                                
                                                params = get_product_params_from_images(wb_url, api_key, max_images=mass_max_images, selected_params=selected_params_for_analysis)
                                                
                                                # Этап 3: Обработка результатов
                                                elapsed = time.time() - product_start_time
                                                prev_time_str = f" | ⏱️ Предыдущий: {previous_product_time:.1f}с" if previous_product_time else ""
                                                mass_status_text.text(f"💾 [{processed_idx + 1}/{total_skus}] Артикул {sku}: Сохранение параметров... | ⏱️ Текущий: {elapsed:.1f}с{prev_time_str}")
                                                
                                                if params:
                                                    # Фильтруем параметры, исключая невалидные (артикулы и т.д.)
                                                    valid_params = {k: v for k, v in params.items() if is_valid_param_name(k)}
                                                    
                                                    result_row = {
                                                        "Артикул": sku,
                                                        "URL": wb_url,
                                                        "Статус": "✅ Успешно",
                                                        "Параметры": ", ".join([f"{k}: {v}" for k, v in valid_params.items()])
                                                    }
                                                    result_row.update(valid_params)
                                                    
                                                    # Проверяем, есть ли уже результат для этого артикула
                                                    sku_str = str(sku).replace(".0", "")
                                                    existing_result_idx = None
                                                    for i, existing_result in enumerate(mass_results):
                                                        existing_sku = str(existing_result.get("Артикул", "")).replace(".0", "")
                                                        if existing_sku == sku_str:
                                                            existing_result_idx = i
                                                            break
                                                    
                                                    # Если результат уже есть - обновляем, иначе добавляем
                                                    if existing_result_idx is not None:
                                                        # Обновляем существующий результат (всегда, чтобы данные были актуальными)
                                                        mass_results[existing_result_idx] = result_row
                                                    else:
                                                        # Добавляем новый результат
                                                        mass_results.append(result_row)
                                                    
                                                    # СРАЗУ синхронизируем с session_state и сохраняем в файл после каждого товара
                                                    # Очищаем удаленные параметры перед сохранением
                                                    cleaned_mass_results = remove_deleted_params_from_mass_results(mass_results.copy())
                                                    st.session_state["mass_analysis_results"] = cleaned_mass_results
                                                    save_mass_analysis_results(cleaned_mass_results)
                                                    # Обновляем локальную переменную для отображения
                                                    mass_results = cleaned_mass_results
                                                    
                                                    # Сохраняем параметры в session_state с историей
                                                    if "param_values" not in st.session_state:
                                                        st.session_state["param_values"] = {}
                                                    
                                                    # Обновляем param_options только для валидных параметров
                                                    if "param_options" not in st.session_state:
                                                        st.session_state["param_options"] = {}
                                                    
                                                    for param_name, param_value in params.items():
                                                        # Пропускаем невалидные параметры (артикулы и т.д.)
                                                        if not is_valid_param_name(param_name):
                                                            continue
                                                        
                                                        # Используем функцию с сохранением истории (без записи в файл)
                                                        save_param_value(str(sku), param_name, str(param_value), save_history=True)
                                                        
                                                        # Обновляем param_options
                                                        if "param_options" not in st.session_state:
                                                            st.session_state["param_options"] = {}
                                                        if param_name not in st.session_state["param_options"]:
                                                            st.session_state["param_options"][param_name] = []
                                                        if param_value and str(param_value) not in st.session_state["param_options"][param_name]:
                                                            st.session_state["param_options"][param_name].append(str(param_value))
                                                    
                                                    # Сохраняем историю параметров пакетом после обработки всех параметров товара
                                                    if params:
                                                        save_param_history_to_file()
                                                    
                                                else:
                                                    result_row = {
                                                        "Артикул": sku,
                                                        "URL": wb_url,
                                                        "Статус": "⚠️ Параметры не определены",
                                                        "Параметры": ""
                                                    }
                                                    
                                                    # Проверяем, есть ли уже результат для этого артикула
                                                    sku_str = str(sku).replace(".0", "")
                                                    existing_result_idx = None
                                                    for i, existing_result in enumerate(mass_results):
                                                        existing_sku = str(existing_result.get("Артикул", "")).replace(".0", "")
                                                        if existing_sku == sku_str:
                                                            existing_result_idx = i
                                                            break
                                                    
                                                    # Если результат уже есть - обновляем, иначе добавляем
                                                    if existing_result_idx is not None:
                                                        # Обновляем существующий результат (всегда, чтобы данные были актуальными)
                                                        # Если предыдущий статус был успешным, а новый ошибка - показываем ошибку
                                                        # Если предыдущий статус был ошибкой, а новый успешный - обновляем на успешный
                                                        mass_results[existing_result_idx] = result_row
                                                    else:
                                                        # Добавляем новый результат
                                                        mass_results.append(result_row)
                                                    
                                                    # СРАЗУ синхронизируем с session_state и сохраняем в файл после каждого товара
                                                    # Очищаем удаленные параметры перед сохранением
                                                    cleaned_mass_results = remove_deleted_params_from_mass_results(mass_results.copy())
                                                    st.session_state["mass_analysis_results"] = cleaned_mass_results
                                                    save_mass_analysis_results(cleaned_mass_results)
                                                    # Обновляем локальную переменную для отображения
                                                    mass_results = cleaned_mass_results
                                            
                                            except Exception as e:
                                                error_message = str(e)
                                                # Сохраняем полное сообщение об ошибке
                                                error_status = f"❌ Ошибка: {error_message[:100]}"
                                                if len(error_message) > 100:
                                                    error_status += "..."
                                                
                                                result_row = {
                                                    "Артикул": sku,
                                                    "URL": wb_url,
                                                    "Статус": error_status,
                                                    "Параметры": "",
                                                    "Ошибка (полная)": error_message  # Сохраняем полное сообщение для отчета
                                                }
                                                
                                                # Проверяем, есть ли уже результат для этого артикула
                                                sku_str = str(sku).replace(".0", "")
                                                existing_result_idx = None
                                                for i, existing_result in enumerate(mass_results):
                                                    existing_sku = str(existing_result.get("Артикул", "")).replace(".0", "")
                                                    if existing_sku == sku_str:
                                                        existing_result_idx = i
                                                        break
                                                
                                                # Если результат уже есть - обновляем, иначе добавляем
                                                if existing_result_idx is not None:
                                                    # Обновляем существующий результат (всегда, чтобы данные были актуальными)
                                                    # Если предыдущий статус был успешным, а новый ошибка - показываем ошибку
                                                    # Если предыдущий статус был ошибкой, а новый успешный - обновляем на успешный
                                                    mass_results[existing_result_idx] = result_row
                                                else:
                                                    # Добавляем новый результат
                                                    mass_results.append(result_row)
                                                
                                                # СРАЗУ синхронизируем с session_state и сохраняем в файл после каждого товара
                                                st.session_state["mass_analysis_results"] = mass_results
                                                save_mass_analysis_results(mass_results)
                                            
                                            # Вычисляем время обработки товара
                                            product_end_time = time.time()
                                            product_processing_time = product_end_time - product_start_time
                                            
                                            # Отмечаем товар как обработанный
                                            processed_skus.add(str(sku))
                                            
                                            # Определяем статус и иконку из последнего добавленного результата
                                            # Проверяем последний результат в mass_results для текущего артикула
                                            last_result_status = None
                                            for result in reversed(mass_results):
                                                if str(result.get("Артикул", "")).replace(".0", "") == str(sku).replace(".0", ""):
                                                    last_result_status = result.get("Статус", "")
                                                    break
                                            
                                            # Определяем иконку статуса
                                            if last_result_status and last_result_status.startswith("✅"):
                                                status_icon = "✅"
                                            elif last_result_status and "❌" in last_result_status:
                                                status_icon = "❌"
                                            elif last_result_status and "⚠️" in last_result_status:
                                                status_icon = "⚠️"
                                            else:
                                                status_icon = "⏳"
                                            
                                            elapsed_str = f"{product_processing_time:.1f}с"
                                            prev_time_str = f" | ⏱️ Предыдущий: {previous_product_time:.1f}с" if previous_product_time is not None else ""
                                            mass_status_text.text(f"{status_icon} [{processed_idx + 1}/{total_skus}] Артикул {sku} обработан за {elapsed_str}{prev_time_str}")
                                            
                                            # Обновляем прогресс-бар
                                            progress_value = min((processed_idx + 1) / total_skus, 1.0)
                                            mass_progress_bar.progress(progress_value)
                                            
                                            # Сохраняем время обработки текущего товара для следующего
                                            previous_product_time = product_processing_time
                                            
                                            # Вычисляем статистику (всегда актуальная)
                                            current_success_count = len([r for r in mass_results if r.get("Статус", "").startswith("✅")])
                                            current_error_count = len([r for r in mass_results if not r.get("Статус", "").startswith("✅")])
                                            
                                            # Обновляем таблицу результатов ПОСЛЕ КАЖДОГО товара
                                            # КРИТИЧЕСКИ ВАЖНО: Показываем количество товаров из mass_results, а не processed_idx
                                            # Используем актуальные данные из session_state (они уже синхронизированы выше)
                                            current_results = st.session_state.get("mass_analysis_results", mass_results)
                                            if current_results:
                                                results_df = pd.DataFrame(current_results)
                                                
                                                # Фильтруем удаленные параметры из столбцов DataFrame
                                                deleted_params = st.session_state.get("deleted_params", set())
                                                if not isinstance(deleted_params, set):
                                                    deleted_params = set(deleted_params) if deleted_params else set()
                                                
                                                # Удаляем столбцы, которые являются удаленными параметрами
                                                cols_to_keep = [col for col in results_df.columns if col not in deleted_params]
                                                if cols_to_keep:
                                                    results_df = results_df[cols_to_keep]
                                                
                                                # Пересчитываем статистику из актуальных результатов
                                                current_success_count = len([r for r in current_results if r.get("Статус", "").startswith("✅")])
                                                current_error_count = len([r for r in current_results if not r.get("Статус", "").startswith("✅")])
                                                
                                                with results_table_placeholder.container():
                                                    st.markdown(f"**📋 Обработано: {len(current_results)} товаров** (✅ Успешно: {current_success_count}, ❌ Ошибок: {current_error_count}) | 🔄 Всего попыток: {processed_idx + 1}/{total_skus}")
                                                    st.dataframe(results_df, use_container_width=True, height=400)
                                            
                                            # Сохраняем прогресс реже - каждые 5 товаров или в конце (для оптимизации)
                                            should_save_progress = (len(processed_skus) % 5 == 0) or (idx == len(remaining_skus) - 1)
                                            if should_save_progress:
                                                save_mass_analysis_progress(
                                                    skus_to_process,
                                                    processed_skus,
                                                    mass_results,
                                                    settings
                                                )
                                            
                                            # Обновляем кнопку применения параметров реже - каждые 3 товара или в конце
                                            should_update_button = (len(mass_results) % 3 == 0) or (idx == len(remaining_skus) - 1)
                                            if should_update_button:
                                                if current_success_count > 0:
                                                    with apply_button_placeholder.container():
                                                        st.divider()
                                                        col_apply1, col_apply2 = st.columns([1, 2])
                                                        with col_apply1:
                                                            # Используем уникальный ключ с индексом обработанных товаров
                                                            button_key = f"apply_mass_results_during_{len(mass_results)}"
                                                            if st.button("💾 Применить параметры в общую таблицу", type="primary", use_container_width=True, key=button_key):
                                                                # Сохраняем параметры в файл
                                                                if save_param_values_to_file():
                                                                    if save_param_history_to_file():
                                                                        # Перезагружаем параметры из файла, чтобы убедиться, что они применены
                                                                        load_param_values_from_file()
                                                                        st.success(f"✅ Параметры применены в общую таблицу! Обновлено {current_success_count} товаров.")
                                                                        # Обновляем таблицу для отображения новых параметров
                                                                        if "df" in st.session_state:
                                                                            # Перезагружаем данные, чтобы показать новые параметры
                                                                            st.session_state["data_loaded"] = False
                                                                            # Очищаем display_df, чтобы он пересоздался с новыми параметрами
                                                                            if "display_df" in st.session_state:
                                                                                del st.session_state["display_df"]
                                                                        st.rerun()
                                                                    else:
                                                                        st.error("❌ Ошибка при сохранении истории изменений")
                                                                else:
                                                                    st.error("❌ Ошибка при сохранении параметров")
                                                        with col_apply2:
                                                            st.info("💡 Параметры из успешных результатов будут применены в основную таблицу. Можно нажимать во время обработки.")
                                                else:
                                                    apply_button_placeholder.empty()
                                            
                                            # Задержка между товарами и переход к следующему
                                            if idx < len(remaining_skus) - 1:
                                                import time
                                                # Показываем, что переходим к следующему товару
                                                next_idx = processed_idx + 1
                                                mass_status_text.text(f"⏳ Переход к следующему товару... [{next_idx}/{total_skus}] | ⏱️ Предыдущий: {product_processing_time:.1f}с")
                                                time.sleep(mass_delay)
                                                # Обновляем статус перед началом обработки следующего товара
                                                mass_status_text.text(f"🔄 Начинаем обработку товара {next_idx}/{total_skus}...")
                                            else:
                                                # Последний товар обработан
                                                mass_status_text.text(f"✅ Все товары обработаны! Последний товар: {product_processing_time:.1f}с")
                                    
                                    mass_progress_bar.progress(1.0)
                                    mass_status_text.empty()
                                    
                                    # Удаляем сохраненный прогресс после успешного завершения
                                    clear_mass_analysis_progress()
                                    
                                    # Сбрасываем флаг запуска анализа, чтобы старые результаты снова показывались
                                    st.session_state["mass_analysis_btn_clicked"] = False
                                    
                                    # Финальные результаты
                                    st.markdown("---")
                                    st.markdown("### 📊 Итоговый отчет массового анализа")
                                    
                                    # Пересчитываем счетчики из актуальных результатов
                                    final_success_count = len([r for r in mass_results if r.get("Статус", "").startswith("✅")])
                                    final_error_count = len([r for r in mass_results if not r.get("Статус", "").startswith("✅")])
                                    
                                    col_success, col_error, col_total = st.columns(3)
                                    with col_success:
                                        st.metric("✅ Успешно", final_success_count)
                                    with col_error:
                                        st.metric("❌ Ошибок", final_error_count)
                                    with col_total:
                                        st.metric("📦 Всего", total_skus)
                                    
                                    # Определяем проблемные товары для кнопок повторной обработки
                                    error_results = [r for r in mass_results if not r.get("Статус", "").startswith("✅")]
                                    undefined_results = [r for r in mass_results if "⚠️ Параметры не определены" in r.get("Статус", "")]
                                    
                                    # Показываем кнопки повторной обработки сразу после итогового отчета
                                    if undefined_results or error_results:
                                        st.markdown("---")
                                        st.markdown("#### 🔄 Повторная обработка товаров")
                                        
                                        # Кнопка для товаров с неопределенными параметрами
                                        if undefined_results:
                                            if st.button(f"🔄 Обработать товары с неопределенными параметрами ({len(undefined_results)})", type="primary", use_container_width=True, key="retry_undefined_final_top"):
                                                retry_skus = [str(r["Артикул"]) for r in undefined_results]
                                                success_results = [r for r in mass_results if r.get("Статус", "").startswith("✅")]
                                                
                                                retry_settings = {
                                                    "max_images": mass_max_images if 'mass_max_images' in locals() else st.session_state.get("mass_max_images_slider", 5),
                                                    "delay": mass_delay if 'mass_delay' in locals() else st.session_state.get("mass_delay_slider", 2.0),
                                                    "selected_params": mass_selected_params if 'mass_selected_params' in locals() else st.session_state.get("mass_selected_params_multiselect", [])
                                                }
                                                
                                                retry_progress = {
                                                    "skus_to_process": retry_skus,
                                                    "processed_skus": [],
                                                    "results": success_results,
                                                    "settings": retry_settings,
                                                    "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
                                                    "is_retry": True
                                                }
                                                
                                                save_mass_analysis_progress(
                                                    retry_skus,
                                                    set(),
                                                    success_results,
                                                    retry_settings
                                                )
                                                
                                                st.session_state["resume_mass_analysis"] = True
                                                st.session_state["saved_progress"] = retry_progress
                                                st.success(f"✅ Запланирована обработка {len(retry_skus)} товаров с неопределенными параметрами")
                                                st.rerun()
                                        
                                        # Кнопка для всех товаров с ошибками
                                        if error_results:
                                            if st.button(f"🔄 Обработать все товары с ошибками ({len(error_results)})", type="primary", use_container_width=True, key="retry_all_errors_final_top"):
                                                retry_skus = [str(r["Артикул"]) for r in error_results]
                                                success_results = [r for r in mass_results if r.get("Статус", "").startswith("✅")]
                                                
                                                retry_settings = {
                                                    "max_images": mass_max_images if 'mass_max_images' in locals() else st.session_state.get("mass_max_images_slider", 5),
                                                    "delay": mass_delay if 'mass_delay' in locals() else st.session_state.get("mass_delay_slider", 2.0),
                                                    "selected_params": mass_selected_params if 'mass_selected_params' in locals() else st.session_state.get("mass_selected_params_multiselect", [])
                                                }
                                                
                                                retry_progress = {
                                                    "skus_to_process": retry_skus,
                                                    "processed_skus": [],
                                                    "results": success_results,
                                                    "settings": retry_settings,
                                                    "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
                                                    "is_retry": True
                                                }
                                                
                                                save_mass_analysis_progress(
                                                    retry_skus,
                                                    set(),
                                                    success_results,
                                                    retry_settings
                                                )
                                                
                                                st.session_state["resume_mass_analysis"] = True
                                                st.session_state["saved_progress"] = retry_progress
                                                st.success(f"✅ Запланирована обработка {len(retry_skus)} товаров с ошибками")
                                                st.rerun()
                                    
                                    # Детальный отчет об ошибках
                                    # Пересчитываем счетчики из актуальных результатов
                                    current_error_count = len([r for r in mass_results if not r.get("Статус", "").startswith("✅")])
                                    if current_error_count > 0:
                                        st.markdown("---")
                                        st.markdown("### ❌ Детальный отчет об ошибках")
                                        
                                        # Фильтруем товары с ошибками
                                        error_results = [r for r in mass_results if not r.get("Статус", "").startswith("✅")]
                                        undefined_results = [r for r in mass_results if "⚠️ Параметры не определены" in r.get("Статус", "")]
                                        
                                        # Проверяем товары с незаполненными параметрами из таблицы
                                        param_values = get_param_values()
                                        all_param_names = list(st.session_state.get("param_options", {}).keys())
                                        skus_with_empty_params = []
                                        
                                        if all_param_names and param_values:
                                            # Получаем все артикулы из таблицы
                                            source_df = st.session_state.get("df")
                                            if source_df is None:
                                                source_df = st.session_state.get("display_df")
                                            if source_df is not None and "Артикул" in source_df.columns:
                                                for sku in source_df["Артикул"].dropna().unique():
                                                    sku_str = str(sku).replace(".0", "")
                                                    # Проверяем, заполнены ли все параметры для этого товара
                                                    filled_params_count = 0
                                                    for param_name in all_param_names:
                                                        if param_name in param_values and sku_str in param_values[param_name]:
                                                            value = param_values[param_name][sku_str]
                                                            if value and str(value).strip():
                                                                filled_params_count += 1
                                                    
                                                    # Если ни один параметр не заполнен, добавляем в список
                                                    if filled_params_count == 0:
                                                        skus_with_empty_params.append(sku_str)
                                        
                                        if error_results:
                                            error_df = pd.DataFrame(error_results)
                                            # Оставляем только важные колонки для отчета об ошибках
                                            error_report_cols = ["Артикул", "URL", "Статус"]
                                            if "Параметры" in error_df.columns:
                                                error_report_cols.append("Параметры")
                                            
                                            error_report_df = error_df[error_report_cols].copy()
                                            
                                            # Кнопка для обработки всех товаров с ошибками
                                            st.markdown("#### 🔄 Повторная обработка товаров с ошибками")
                                            col_retry_all, col_retry_info = st.columns([2, 3])
                                            with col_retry_all:
                                                if st.button("🔄 Обработать все товары с ошибками снова", type="primary", key="retry_all_errors"):
                                                    # Извлекаем все артикулы с ошибками
                                                    retry_skus = [str(r["Артикул"]) for r in error_results]
                                                    
                                                    # Сохраняем настройки для повторной обработки
                                                    retry_settings = {
                                                        "max_images": mass_max_images,
                                                        "delay": mass_delay
                                                    }
                                                    
                                                    # Сохраняем текущие успешные результаты для последующего объединения
                                                    success_results = [r for r in mass_results if r.get("Статус", "").startswith("✅")]
                                                    
                                                    # Создаем новый прогресс для повторной обработки
                                                    retry_progress = {
                                                        "skus_to_process": retry_skus,
                                                        "processed_skus": [],
                                                        "results": success_results,  # Сохраняем успешные результаты
                                                        "settings": retry_settings,
                                                        "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
                                                        "is_retry": True,
                                                        "original_results": mass_results  # Сохраняем все исходные результаты
                                                    }
                                                    
                                                    save_mass_analysis_progress(
                                                        retry_skus,
                                                        set(),
                                                        success_results,  # Сохраняем успешные результаты
                                                        retry_settings
                                                    )
                                                    
                                                    st.session_state["resume_mass_analysis"] = True
                                                    st.session_state["saved_progress"] = retry_progress
                                                    st.success(f"✅ Запланирована повторная обработка {len(retry_skus)} товаров с ошибками")
                                                    st.rerun()
                                            with col_retry_info:
                                                # Пересчитываем счетчики из актуальных результатов
                                                current_success_count_info = len([r for r in mass_results if r.get("Статус", "").startswith("✅")])
                                                st.info(f"📊 Будет обработано **{len(error_results)}** товаров с ошибками. Успешные результаты ({current_success_count_info}) будут сохранены.")
                                            
                                            st.divider()
                                            
                                            # Группируем ошибки по типу
                                            error_types = {}
                                            for _, row in error_report_df.iterrows():
                                                status = str(row.get("Статус", ""))
                                                if "APITimeoutError" in status or "timeout" in status.lower():
                                                    error_type = "⏱️ Таймаут API"
                                                elif "Rate limit" in status or "429" in status:
                                                    error_type = "🚦 Превышен лимит запросов"
                                                elif "Параметры не определены" in status:
                                                    error_type = "⚠️ Параметры не определены"
                                                elif "Ошибка" in status:
                                                    error_type = "❌ Прочие ошибки"
                                                else:
                                                    error_type = "❓ Неизвестная ошибка"
                                                
                                                if error_type not in error_types:
                                                    error_types[error_type] = []
                                                error_types[error_type].append(row.to_dict())
                                            
                                            # Показываем ошибки по типам
                                            st.markdown("#### 📊 Ошибки по типам")
                                            for error_type, errors in error_types.items():
                                                with st.expander(f"{error_type} ({len(errors)} товаров)", expanded=False):
                                                    error_type_df = pd.DataFrame(errors)
                                                    st.dataframe(error_type_df, use_container_width=True, height=min(400, len(errors) * 50))
                                                    
                                                    # Кнопка для повторной обработки товаров с ошибками конкретного типа
                                                    if st.button(f"🔄 Повторить обработку ({len(errors)} товаров)", key=f"retry_{error_type}"):
                                                        # Извлекаем артикулы для повторной обработки
                                                        retry_skus = [str(r["Артикул"]) for r in errors]
                                                        
                                                        # Сохраняем настройки для повторной обработки
                                                        retry_settings = {
                                                            "max_images": mass_max_images,
                                                            "delay": mass_delay
                                                        }
                                                        
                                                        # Сохраняем текущие успешные результаты
                                                        success_results = [r for r in mass_results if r.get("Статус", "").startswith("✅")]
                                                        
                                                        # Создаем новый прогресс для повторной обработки
                                                        retry_progress = {
                                                            "skus_to_process": retry_skus,
                                                            "processed_skus": [],
                                                            "results": success_results,  # Сохраняем успешные результаты
                                                            "settings": retry_settings,
                                                            "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
                                                            "is_retry": True,
                                                            "original_results": mass_results
                                                        }
                                                        
                                                        save_mass_analysis_progress(
                                                            retry_skus,
                                                            set(),
                                                            success_results,  # Сохраняем успешные результаты
                                                            retry_settings
                                                        )
                                                        
                                                        st.session_state["resume_mass_analysis"] = True
                                                        st.session_state["saved_progress"] = retry_progress
                                                        st.success(f"✅ Запланирована повторная обработка {len(retry_skus)} товаров")
                                                        st.rerun()
                                            
                                            st.divider()
                                            
                                            # Общая таблица всех ошибок
                                            st.markdown("#### 📋 Все товары с ошибками")
                                            st.dataframe(error_report_df, use_container_width=True, height=400)
                                            
                                            # Экспорт в CSV
                                            csv = error_report_df.to_csv(index=False).encode('utf-8-sig')
                                            st.download_button(
                                                label="📥 Скачать отчет об ошибках (CSV)",
                                                data=csv,
                                                file_name=f"mass_analysis_errors_{pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')}.csv",
                                                mime="text/csv",
                                                key="download_errors_csv"
                                            )
                                    
                                    # Сохраняем результаты в session_state для последующего просмотра
                                    st.session_state["mass_analysis_results"] = mass_results
                                    save_mass_analysis_results(mass_results)
                                    
                                    # Автоматически применяем параметры из результатов
                                    # Пересчитываем счетчики из актуальных результатов
                                    current_success_count = len([r for r in mass_results if r.get("Статус", "").startswith("✅")])
                                    if current_success_count > 0:
                                        applied_params_count = apply_mass_analysis_results_to_params(mass_results)
                                        if applied_params_count > 0:
                                            # Сохраняем параметры в файл
                                            save_param_values_to_file()
                                            st.success(f"✅ Анализ завершен! Параметры автоматически применены ({applied_params_count} параметров).")
                                        else:
                                            st.success(f"✅ Анализ завершен!")
                                    else:
                                        st.info("ℹ️ Нет успешных результатов для применения параметров")
                            else:
                                st.warning("⚠️ Нет товаров для анализа")
            
            st.divider()
            # ========== КОНЕЦ СЕКЦИИ: Определение параметров по ссылке ==========
            
            # Таблица с параметрами удалена - используется основная таблица в первой вкладке "📊 Анализ данных"
        
        with tab3:
            st.subheader("📈 Аналитика по параметрам")
            
            # Получаем данные параметров
            param_values = get_param_values()
            param_options = st.session_state.get("param_options", {})

            if not param_values and not param_options:
                st.warning("Сначала установите параметры товаров во второй вкладке")
            else:
                # Выбор параметра для анализа
                # Объединяем параметры из param_values и param_options, чтобы показывать все определенные параметры
                params_from_values = set(param_values.keys()) if param_values else set()
                params_from_options = set(param_options.keys()) if param_options else set()
                available_params = sorted(list(params_from_values | params_from_options))
                if available_params:
                    # Кнопка экспорта всех параметров в Excel
                    col_export_all, col_select = st.columns([1, 2])
                    
                    with col_export_all:
                        if st.button("📊 Экспорт всех параметров в Excel", type="secondary"):
                            try:
                                # Создаем Excel файл с несколькими листами
                                import io
                                from openpyxl import Workbook
                                
                                wb = Workbook()
                                # Удаляем дефолтный лист
                                wb.remove(wb.active)
                                
                                # Получаем имя загруженного файла для названия экспорта
                                base_filename = "analytics_all_parameters"
                                if hasattr(uploaded, 'name') and uploaded.name:
                                    name_without_ext = os.path.splitext(uploaded.name)[0]
                                    base_filename = f"{name_without_ext}_analytics_all_parameters"
                                
                                # Создаем лист для каждого параметра
                                for param_name in available_params:
                                    ws = wb.create_sheet(title=param_name)
                                    
                                    # Получаем данные для этого параметра
                                    param_values_set = set()
                                    if param_name in param_values:
                                        for sku, value in param_values[param_name].items():
                                            if value:
                                                param_values_set.add(value)
                                        
                                        # Создаем аналитику для этого параметра
                                        analytics_data = []
                                        
                                        for param_value in sorted(param_values_set):
                                            matching_skus = []
                                            if param_name in param_values:
                                                for sku, value in param_values[param_name].items():
                                                    if value == param_value:
                                                        matching_skus.append(sku)
                                            
                                            if matching_skus:
                                                mask = df["Артикул"].astype(str).str.replace(".0", "").isin(matching_skus)
                                                filtered_df = df[mask]
                                                
                                                if not filtered_df.empty:
                                                    total_revenue = filtered_df["Выручка"].sum() if "Выручка" in filtered_df.columns else 0
                                                    total_orders = filtered_df["Заказы"].sum() if "Заказы" in filtered_df.columns else 0
                                                    avg_price = filtered_df["Средняя цена"].mean() if "Средняя цена" in filtered_df.columns else 0
                                                    lost_revenue = filtered_df["Упущенная выручка"].sum() if "Упущенная выручка" in filtered_df.columns else 0
                                                    avg_position = filtered_df["Позиция в выдаче (средняя)"].mean() if "Позиция в выдаче (средняя)" in filtered_df.columns else 0
                                                    avg_cpm = filtered_df["Стоимость за 1000 показов на 1 артикул"].mean() if "Стоимость за 1000 показов на 1 артикул" in filtered_df.columns else 0
                                                    
                                                    analytics_data.append({
                                                        param_value: {
                                                            'Общая выручка': total_revenue,
                                                            'Количество артикулов': len(filtered_df),
                                                            'Выручка на 1 артикул': total_revenue / len(filtered_df) if len(filtered_df) > 0 else 0,
                                                            'Средняя цена без СПП': avg_price,
                                                            'Упущенная выручка': lost_revenue,
                                                            'Упущенная выручка на 1 артикул': lost_revenue / len(filtered_df) if len(filtered_df) > 0 else 0,
                                                            'Позиция в выдаче (средняя)': avg_position,
                                                            'Стоимость за 1000 показов на 1 артикул': avg_cpm
                                                        }
                                                    })
                                            
                                            # Записываем данные в лист
                                            if analytics_data:
                                                # Заголовки
                                                ws['A1'] = 'Метрика'
                                                col = 2
                                                param_values_list = sorted([list(item.keys())[0] for item in analytics_data])
                                                
                                                for param_val in param_values_list:
                                                    ws.cell(row=1, column=col, value=param_val)
                                                    col += 1
                                                
                                                # Данные
                                                metric_names = [
                                                    "Общая выручка",
                                                    "Количество артикулов", 
                                                    "Выручка на 1 артикул",
                                                    "Средняя цена без СПП",
                                                    "Упущенная выручка",
                                                    "Упущенная выручка на 1 артикул",
                                                    "Позиция в выдаче (средняя)",
                                                    "Стоимость за 1000 показов на 1 артикул"
                                                ]
                                                
                                                for row, metric in enumerate(metric_names, 2):
                                                    ws.cell(row=row, column=1, value=metric)
                                                    
                                                    col = 2
                                                    for param_val in param_values_list:
                                                        # Находим данные для этого значения параметра
                                                        for item in analytics_data:
                                                            if param_val in item:
                                                                metrics = item[param_val]
                                                                value = metrics.get(metric, 0)
                                                                if metric in ["Общая выручка", "Выручка на 1 артикул", "Средняя цена без СПП", "Упущенная выручка", "Упущенная выручка на 1 артикул"]:
                                                                    ws.cell(row=row, column=col, value=value)
                                                                else:
                                                                    ws.cell(row=row, column=col, value=value)
                                                                break
                                                    col += 1
                                
                                # Сохраняем в байты
                                excel_buffer = io.BytesIO()
                                wb.save(excel_buffer)
                                excel_buffer.seek(0)
                                
                                st.download_button(
                                    label="💾 Скачать Excel файл",
                                    data=excel_buffer.getvalue(),
                                    file_name=f"{base_filename}.xlsx",
                                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                                )
                                
                                st.success("✅ Excel файл готов к скачиванию!")
                                
                            except Exception as e:
                                st.error(f"❌ Ошибка создания Excel файла: {e}")
                    
                    with col_select:
                        # Определяем иерархию параметров
                        # Иерархия: Тип → Подтип (Рукав, Ворот) → Остальные параметры (Цвет, Строчка и т.д.)
                        hierarchy_params_list = get_hierarchy_params()
                        type_param = hierarchy_params_list[0] if hierarchy_params_list else "Тип"
                        subtype_params = get_subtype_params()  # Параметры, которые находятся внутри "Подтип"
                        visual_params = get_visual_params()
                        
                        # Разделяем параметры на категории
                        type_param_available = type_param in available_params
                        subtype_params_available = [p for p in subtype_params if p in available_params]
                        visual_params_list = [p for p in available_params if p in visual_params or any(vp in p for vp in visual_params)]
                        other_params_list = [p for p in available_params if p != type_param and p not in subtype_params and p not in visual_params_list]
                        
                        # Трехуровневая иерархия выбора
                        selected_type_value = None
                        selected_subtype_param = None
                        selected_subtype_value = None
                        selected_other_param = None
                        use_combined_analysis = False
                        combined_hierarchy_param = None
                        combined_hierarchy_value = None
                        combined_subtype_param = None
                        combined_subtype_value = None
                        
                        if type_param_available:
                            st.info(f"📊 **Иерархия сегментов**: Тип → Подтип (Рукав, Ворот) → Остальные параметры")
                            
                            # Уровень 1: Выбор параметра "Тип" и его значения
                            type_param_values = set()
                            if type_param in param_values:
                                for sku, value in param_values[type_param].items():
                                    if value and str(value).strip():
                                        type_param_values.add(str(value).strip())
                            
                            if type_param_values:
                                selected_type_values = st.multiselect(
                                    f"1️⃣ Выберите значения параметра '{type_param}' (можно выбрать несколько):",
                                    sorted(list(type_param_values)),
                                    key="analytics_type_value_selector",
                                    help="Выберите одно или несколько значений типа товара"
                                )
                                
                                if selected_type_values:
                                    if len(selected_type_values) == 1:
                                        selected_type_value = selected_type_values[0]
                                    else:
                                        selected_type_value = selected_type_values
                                    
                                    # Уровень 2: Выбор подтипа (Рукав, Ворот), если выбран тип
                                    if subtype_params_available:
                                        st.divider()
                                        selected_subtype_param = st.selectbox(
                                            "2️⃣ Выберите параметр подтипа:",
                                            ["Не выбран"] + subtype_params_available,
                                            key="analytics_subtype_param_selector",
                                            help="Выберите параметр подтипа (Рукав или Ворот)"
                                        )
                                        
                                        if selected_subtype_param != "Не выбран":
                                            # Получаем значения выбранного параметра подтипа
                                            subtype_param_values = set()
                                            if selected_subtype_param in param_values:
                                                for sku, value in param_values[selected_subtype_param].items():
                                                    if value and str(value).strip():
                                                        # Фильтруем только по выбранным типам
                                                        if type_param in param_values and sku in param_values[type_param]:
                                                            type_val = param_values[type_param][sku]
                                                            if isinstance(selected_type_value, list):
                                                                if str(type_val).strip() in [str(v).strip() for v in selected_type_value]:
                                                                    subtype_param_values.add(str(value).strip())
                                                            else:
                                                                if str(type_val).strip() == str(selected_type_value).strip():
                                                                    subtype_param_values.add(str(value).strip())
                                            
                                            if subtype_param_values:
                                                selected_subtype_values = st.multiselect(
                                                    f"Выберите значения параметра '{selected_subtype_param}' (можно выбрать несколько):",
                                                    sorted(list(subtype_param_values)),
                                                    key="analytics_subtype_value_selector",
                                                    help="Выберите одно или несколько значений подтипа"
                                                )
                                                
                                                if selected_subtype_values:
                                                    if len(selected_subtype_values) == 1:
                                                        selected_subtype_value = selected_subtype_values[0]
                                                    else:
                                                        selected_subtype_value = selected_subtype_values
                                                    combined_subtype_param = selected_subtype_param
                                                    combined_subtype_value = selected_subtype_value
                                            
                                            # Уровень 3: Выбор остальных параметров
                                            all_other_params = visual_params_list + other_params_list
                                            if all_other_params:
                                                st.divider()
                                                selected_other_param = st.selectbox(
                                                    "3️⃣ Выберите параметр для анализа:",
                                                    ["Не выбран"] + all_other_params,
                                                    key="analytics_other_param_selector",
                                                    help="Выберите параметр для анализа (Цвет, Строчка и т.д.)"
                                                )
                                                
                                                if selected_other_param != "Не выбран":
                                                    selected_param = selected_other_param
                                                    use_combined_analysis = True
                                                    combined_hierarchy_param = type_param
                                                    combined_hierarchy_value = selected_type_value
                                                else:
                                                    selected_param = selected_subtype_param
                                                    combined_hierarchy_param = type_param
                                                    combined_hierarchy_value = selected_type_value
                                            else:
                                                selected_param = selected_subtype_param
                                                combined_hierarchy_param = type_param
                                                combined_hierarchy_value = selected_type_value
                                        else:
                                            # Если подтип не выбран, можно выбрать остальные параметры
                                            all_other_params = visual_params_list + other_params_list
                                            if all_other_params:
                                                st.divider()
                                                selected_other_param = st.selectbox(
                                                    "2️⃣ Выберите параметр для анализа:",
                                                    ["Не выбран"] + all_other_params,
                                                    key="analytics_other_param_selector_no_subtype",
                                                    help="Выберите параметр для анализа (Цвет, Строчка и т.д.)"
                                                )
                                                
                                                if selected_other_param != "Не выбран":
                                                    selected_param = selected_other_param
                                                    use_combined_analysis = True
                                                    combined_hierarchy_param = type_param
                                                    combined_hierarchy_value = selected_type_value
                                                else:
                                                    selected_param = type_param
                                                    combined_hierarchy_param = None
                                                    combined_hierarchy_value = None
                                            else:
                                                selected_param = type_param
                                                combined_hierarchy_param = None
                                                combined_hierarchy_value = None
                                    else:
                                        # Если нет параметров подтипа, сразу выбираем остальные параметры
                                        all_other_params = visual_params_list + other_params_list
                                        if all_other_params:
                                            st.divider()
                                            selected_other_param = st.selectbox(
                                                "2️⃣ Выберите параметр для анализа:",
                                                ["Не выбран"] + all_other_params,
                                                key="analytics_other_param_selector_no_subtype",
                                                help="Выберите параметр для анализа (Цвет, Строчка и т.д.)"
                                            )
                                            
                                            if selected_other_param != "Не выбран":
                                                selected_param = selected_other_param
                                                use_combined_analysis = True
                                                combined_hierarchy_param = type_param
                                                combined_hierarchy_value = selected_type_value
                                            else:
                                                selected_param = type_param
                                                combined_hierarchy_param = None
                                                combined_hierarchy_value = None
                                        else:
                                            selected_param = type_param
                                            combined_hierarchy_param = None
                                            combined_hierarchy_value = None
                                else:
                                    selected_param = None
                                    combined_hierarchy_param = None
                                    combined_hierarchy_value = None
                            else:
                                if type_param in param_options:
                                    st.info(f"ℹ️ Параметр '{type_param}' определен, но еще не заполнен для товаров. Заполните его во вкладке '⚙️ Установка параметров'.")
                                else:
                                    st.warning(f"⚠️ Параметр '{type_param}' не найден. Создайте его во вкладке '⚙️ Установка параметров'.")
                                selected_param = None
                                combined_hierarchy_param = None
                                combined_hierarchy_value = None
                        else:
                            # Если нет параметра "Тип", используем обычный выбор
                            selected_param = st.selectbox(
                                "Выберите параметр для анализа",
                                available_params,
                                key="analytics_param_selector"
                            )
                            use_combined_analysis = False
                            combined_hierarchy_param = None
                            combined_hierarchy_value = None
                    
                    if selected_param and selected_param != "Не выбран":
                        # Формируем заголовок с учетом иерархии
                        title_parts = []
                        if combined_hierarchy_param and combined_hierarchy_value:
                            if isinstance(combined_hierarchy_value, list):
                                values_str = ", ".join(combined_hierarchy_value)
                                title_parts.append(f"{combined_hierarchy_param} = [{values_str}]")
                            else:
                                title_parts.append(f"{combined_hierarchy_param} = {combined_hierarchy_value}")
                        
                        if combined_subtype_param and combined_subtype_value:
                            if isinstance(combined_subtype_value, list):
                                subtype_str = ", ".join(combined_subtype_value)
                                title_parts.append(f"{combined_subtype_param} = [{subtype_str}]")
                            else:
                                title_parts.append(f"{combined_subtype_param} = {combined_subtype_value}")
                        
                        if title_parts:
                            hierarchy_str = " → ".join(title_parts)
                            st.write(f"**Аналитика по параметру: {selected_param} (в контексте: {hierarchy_str})**")
                        else:
                            st.write(f"**Аналитика по параметру: {selected_param}**")
                        
                        # Создаем DataFrame для анализа
                        analytics_data = []
                        
                        # Если используется комбинированный анализ, группируем по комбинации параметров
                        if use_combined_analysis and combined_hierarchy_param:
                            # Комбинированный анализ: группируем по комбинации иерархического и визуального параметров
                            combinations = {}
                            
                            # Собираем все комбинации значений двух параметров
                            for sku in df["Артикул"].astype(str).str.replace(".0", "").unique():
                                sku_str = str(sku)
                                hierarchy_value = None
                                visual_value = None
                                
                                if combined_hierarchy_param in param_values and sku_str in param_values[combined_hierarchy_param]:
                                    hierarchy_value = param_values[combined_hierarchy_param][sku_str]
                                
                                # Если выбрано конкретное значение(я) иерархии, фильтруем только по ним
                                if combined_hierarchy_value:
                                    if isinstance(combined_hierarchy_value, list):
                                        # Если выбрано несколько значений, проверяем вхождение в список
                                        if not hierarchy_value or str(hierarchy_value).strip() not in [str(v).strip() for v in combined_hierarchy_value]:
                                            continue
                                    else:
                                        # Если выбрано одно значение, проверяем точное совпадение
                                        if not hierarchy_value or str(hierarchy_value).strip() != str(combined_hierarchy_value).strip():
                                            continue
                                
                                # Если выбран подтип, фильтруем по нему
                                if combined_subtype_param and combined_subtype_value:
                                    if combined_subtype_param in param_values and sku_str in param_values[combined_subtype_param]:
                                        subtype_val = param_values[combined_subtype_param][sku_str]
                                        if isinstance(combined_subtype_value, list):
                                            if not subtype_val or str(subtype_val).strip() not in [str(v).strip() for v in combined_subtype_value]:
                                                continue
                                        else:
                                            if not subtype_val or str(subtype_val).strip() != str(combined_subtype_value).strip():
                                                continue
                                    else:
                                        continue
                                
                                if selected_param in param_values and sku_str in param_values[selected_param]:
                                    visual_value = param_values[selected_param][sku_str]
                                
                                if visual_value and str(visual_value).strip():
                                    # Нормализуем значения для избежания дубликатов (убираем пробелы, приводим к единому формату)
                                    # Используем strip() для удаления пробелов, но сохраняем оригинальный регистр для отображения
                                    normalized_visual = str(visual_value).strip()
                                    normalized_hierarchy = str(hierarchy_value).strip() if hierarchy_value else ""
                                    
                                    # Если выбрано конкретное значение иерархии, упрощаем ключ
                                    if combined_hierarchy_value:
                                        combo_key = f"{selected_param}: {normalized_visual}"
                                    else:
                                        combo_key = f"{combined_hierarchy_param}: {normalized_hierarchy} | {selected_param}: {normalized_visual}"
                                    
                                    # Нормализуем ключ для сравнения (приводим к нижнему регистру для избежания дубликатов)
                                    combo_key_normalized = combo_key.lower()
                                    
                                    # Используем нормализованный ключ для хранения, но сохраняем оригинальный для отображения
                                    if combo_key_normalized not in combinations:
                                        combinations[combo_key_normalized] = {
                                            "display_key": combo_key,  # Оригинальный ключ для отображения
                                            "skus": set()  # Set для хранения артикулов без дубликатов
                                        }
                                    combinations[combo_key_normalized]["skus"].add(sku_str)
                            
                            # Для каждой комбинации собираем метрики
                            for combo_key_normalized, combo_data in combinations.items():
                                combo_key = combo_data["display_key"]  # Используем оригинальный ключ для отображения
                                skus = combo_data["skus"]
                                # Преобразуем set в list для использования в isin
                                skus_list = list(skus)
                                mask = df["Артикул"].astype(str).str.replace(".0", "").isin(skus_list)
                                filtered_df = df[mask]
                                
                                if not filtered_df.empty:
                                    total_revenue = filtered_df["Выручка"].sum() if "Выручка" in filtered_df.columns else 0
                                    total_orders = filtered_df["Заказы"].sum() if "Заказы" in filtered_df.columns else 0
                                    avg_price = filtered_df["Средняя цена"].mean() if "Средняя цена" in filtered_df.columns else 0
                                    lost_revenue = filtered_df["Упущенная выручка"].sum() if "Упущенная выручка" in filtered_df.columns else 0
                                    revenue_per_product = total_revenue / len(filtered_df) if len(filtered_df) > 0 else 0
                                    lost_revenue_per_product = lost_revenue / len(filtered_df) if len(filtered_df) > 0 else 0
                                    avg_position = filtered_df["Позиция в выдаче"].mean() if "Позиция в выдаче" in filtered_df.columns else 0
                                    avg_cpm = filtered_df["Стоимость за 1000 показов"].mean() if "Стоимость за 1000 показов" in filtered_df.columns else 0
                                    
                                    analytics_data.append({
                                        "Метрика": selected_param,
                                        combo_key: {
                                            "Общая выручка": total_revenue,
                                            "Количество артикулов": len(filtered_df),
                                            "Выручка на 1 артикул": revenue_per_product,
                                            "Средняя цена без СПП": avg_price,
                                            "Упущенная выручка": lost_revenue,
                                            "Упущенная выручка на 1 артикул": lost_revenue_per_product,
                                            "Позиция в выдаче (средняя)": avg_position,
                                            "Стоимость за 1000 показов на 1 артикул": avg_cpm,
                                        }
                                    })
                        else:
                            # Обычный анализ по одному параметру
                            # Получаем уникальные значения параметра
                            param_values_set = set()
                            if selected_param in param_values:
                                for sku, value in param_values[selected_param].items():
                                    if value:
                                        # Если есть фильтр по значению(ям) иерархии, проверяем его
                                        if combined_hierarchy_value and combined_hierarchy_param:
                                            # Проверяем, что товар соответствует выбранному значению(ям) иерархии
                                            if combined_hierarchy_param in param_values and sku in param_values[combined_hierarchy_param]:
                                                hierarchy_val = param_values[combined_hierarchy_param][sku]
                                                if isinstance(combined_hierarchy_value, list):
                                                    # Если выбрано несколько значений, проверяем вхождение в список
                                                    if not hierarchy_val or str(hierarchy_val).strip() not in [str(v).strip() for v in combined_hierarchy_value]:
                                                        continue
                                                else:
                                                    # Если выбрано одно значение, проверяем точное совпадение
                                                    if not hierarchy_val or str(hierarchy_val).strip() != str(combined_hierarchy_value).strip():
                                                        continue
                                            else:
                                                continue
                                        param_values_set.add(value)
                            
                            # Для каждого значения параметра собираем метрики
                            for param_value in sorted(param_values_set):
                                # Находим артикулы с этим значением параметра
                                matching_skus = []
                                if selected_param in param_values:
                                    for sku, value in param_values[selected_param].items():
                                        if value == param_value:
                                            # Если есть фильтр по значению(ям) иерархии, проверяем его
                                            if combined_hierarchy_value and combined_hierarchy_param:
                                                if combined_hierarchy_param in param_values and sku in param_values[combined_hierarchy_param]:
                                                    hierarchy_val = param_values[combined_hierarchy_param][sku]
                                                    if isinstance(combined_hierarchy_value, list):
                                                        # Если выбрано несколько значений, проверяем вхождение в список
                                                        if not hierarchy_val or str(hierarchy_val).strip() not in [str(v).strip() for v in combined_hierarchy_value]:
                                                            continue
                                                    else:
                                                        # Если выбрано одно значение, проверяем точное совпадение
                                                        if not hierarchy_val or str(hierarchy_val).strip() != str(combined_hierarchy_value).strip():
                                                            continue
                                                else:
                                                    continue
                                        matching_skus.append(sku)
                            
                            if matching_skus:
                                # Фильтруем исходные данные по этим артикулам
                                mask = df["Артикул"].astype(str).str.replace(".0", "").isin(matching_skus)
                                filtered_df = df[mask]
                                
                                if not filtered_df.empty:
                                    # Вычисляем метрики
                                    total_revenue = filtered_df["Выручка"].sum() if "Выручка" in filtered_df.columns else 0
                                    total_orders = filtered_df["Заказы"].sum() if "Заказы" in filtered_df.columns else 0
                                    avg_price = filtered_df["Средняя цена"].mean() if "Средняя цена" in filtered_df.columns else 0
                                    lost_revenue = filtered_df["Упущенная выручка"].sum() if "Упущенная выручка" in filtered_df.columns else 0
                                    revenue_per_product = total_revenue / len(filtered_df) if len(filtered_df) > 0 else 0
                                    lost_revenue_per_product = lost_revenue / len(filtered_df) if len(filtered_df) > 0 else 0
                                    avg_position = filtered_df["Позиция в выдаче"].mean() if "Позиция в выдаче" in filtered_df.columns else 0
                                    avg_cpm = filtered_df["Стоимость за 1000 показов"].mean() if "Стоимость за 1000 показов" in filtered_df.columns else 0
                                    
                                    analytics_data.append({
                                        "Метрика": selected_param,
                                        param_value: {
                                            "Общая выручка": total_revenue,
                                            "Количество артикулов": len(filtered_df),
                                            "Выручка на 1 артикул": revenue_per_product,
                                            "Средняя цена без СПП": avg_price,
                                            "Упущенная выручка": lost_revenue,
                                            "Упущенная выручка на 1 артикул": lost_revenue_per_product,
                                            "Позиция в выдаче (средняя)": avg_position,
                                            "Стоимость за 1000 показов на 1 артикул": avg_cpm,
                                        }
                                    })
                        
                        if analytics_data:
                            # Создаем сводную таблицу
                            summary_data = {}
                            for item in analytics_data:
                                for param_val, metrics in item.items():
                                    if param_val != "Метрика":
                                        summary_data[param_val] = metrics
                            
                            # Создаем сводную таблицу в стиле как на картинке
                            if summary_data:
                                # Получаем все значения параметра (цвета) и сортируем их
                                param_values_list = sorted(summary_data.keys())
                                
                                # Создаем DataFrame с метриками по строкам и значениями параметра по столбцам
                                metric_names = [
                                    "Общая выручка",
                                    "Количество артикулов", 
                                    "Выручка на 1 артикул",
                                    "Средняя цена без СПП",
                                    "Упущенная выручка",
                                    "Упущенная выручка на 1 артикул",
                                    "Позиция в выдаче (средняя)",
                                    "Стоимость за 1000 показов на 1 артикул"
                                ]
                                
                                table_data = {"Метрика": metric_names}
                                
                                # Сохраняем числовые данные для цветового кодирования
                                numeric_data = {}
                                
                                # Добавляем данные для каждого значения параметра
                                for param_value in param_values_list:
                                    metrics = summary_data[param_value]
                                    # Сохраняем числовые значения
                                    numeric_data[param_value] = [
                                        metrics['Общая выручка'],
                                        metrics['Количество артикулов'],
                                        metrics['Выручка на 1 артикул'],
                                        metrics['Средняя цена без СПП'],
                                        metrics['Упущенная выручка'],
                                        metrics['Упущенная выручка на 1 артикул'],
                                        metrics['Позиция в выдаче (средняя)'],  # Для позиции меньше = лучше, обработаем отдельно
                                        metrics['Стоимость за 1000 показов на 1 артикул']
                                    ]
                                    
                                    # Форматированные значения для отображения
                                    table_data[param_value] = [
                                        f"₽{metrics['Общая выручка']:,.0f}".replace(",", " "),
                                        f"{metrics['Количество артикулов']:,.0f}".replace(",", " "),
                                        f"₽{metrics['Выручка на 1 артикул']:,.0f}".replace(",", " "),
                                        f"₽{metrics['Средняя цена без СПП']:,.0f}".replace(",", " "),
                                        f"₽{metrics['Упущенная выручка']:,.0f}".replace(",", " "),
                                        f"₽{metrics['Упущенная выручка на 1 артикул']:,.0f}".replace(",", " "),
                                        f"{metrics['Позиция в выдаче (средняя)']:,.0f}".replace(",", " "),
                                        f"{metrics['Стоимость за 1000 показов на 1 артикул']:,.0f}".replace(",", " ")
                                    ]
                                
                                # Создаем DataFrame
                                display_df = pd.DataFrame(table_data)
                                
                                # Функция для выделения лучших результатов
                                def highlight_best_values(values, reverse=False):
                                    """Выделяет зеленым только лучшие результаты"""
                                    if not values or all(pd.isna(v) or v == 0 for v in values):
                                        return ['background-color: white'] * len(values)
                                    
                                    # Очищаем от NaN и нулевых значений для поиска лучшего
                                    clean_values = [v for v in values if not pd.isna(v) and v != 0]
                                    if not clean_values:
                                        return ['background-color: white'] * len(values)
                                    
                                    # Находим лучшее значение
                                    if reverse:  # Для позиции: меньше = лучше
                                        best_val = min(clean_values)
                                    else:  # Для остальных метрик: больше = лучше
                                        best_val = max(clean_values)
                                    
                                    colors = []
                                    for val in values:
                                        if pd.isna(val) or val == 0:
                                            colors.append('background-color: white')
                                        elif val == best_val:
                                            colors.append('background-color: lightgreen')  # Зеленый для лучших
                                        else:
                                            colors.append('background-color: white')  # Белый для остальных
                                    
                                    return colors
                                
                                # Применяем цветовое кодирование
                                def apply_colors(df):
                                    # Создаем стили для каждой строки
                                    styles = pd.DataFrame('', index=df.index, columns=df.columns)
                                    
                                    for i, metric in enumerate(metric_names):
                                        row_values = []
                                        for param_value in param_values_list:
                                            row_values.append(numeric_data[param_value][i])
                                        
                                        # Для позиции используем обратную логику (меньше = лучше)
                                        reverse_logic = (metric == "Позиция в выдаче (средняя)")
                                        colors = highlight_best_values(row_values, reverse=reverse_logic)
                                        
                                        # Применяем цвета к соответствующим ячейкам
                                        for j, param_value in enumerate(param_values_list):
                                            styles.iloc[i, j + 1] = colors[j]  # +1 потому что первый столбец - "Метрика"
                                    
                                    return styles
                                
                                # Добавляем рейтинг
                                if "param_ratings" not in st.session_state:
                                    st.session_state["param_ratings"] = {}
                                
                                param_rating_key = f"{selected_param}_ratings"
                                if param_rating_key not in st.session_state["param_ratings"]:
                                    # Автоматически формируем рейтинг по приоритетам:
                                    # 1. Выручка на 1 артикул (больше = лучше)
                                    # 2. Средняя цена без СПП (больше = лучше) 
                                    # 3. Упущенная выручка на 1 артикул (меньше = лучше)
                                    
                                    def calculate_score(item):
                                        param_val, metrics = item
                                        # Нормализуем значения от 0 до 1
                                        revenue_per_sku = metrics["Выручка на 1 артикул"]
                                        avg_price = metrics["Средняя цена без СПП"]
                                        lost_revenue_per_sku = metrics["Упущенная выручка на 1 артикул"]
                                        
                                        # Находим мин/макс для нормализации
                                        all_revenues = [m["Выручка на 1 артикул"] for m in summary_data.values()]
                                        all_prices = [m["Средняя цена без СПП"] for m in summary_data.values()]
                                        all_lost = [m["Упущенная выручка на 1 артикул"] for m in summary_data.values()]
                                        
                                        # Нормализуем выручку (0-1, где 1 = максимум)
                                        if max(all_revenues) > min(all_revenues):
                                            norm_revenue = (revenue_per_sku - min(all_revenues)) / (max(all_revenues) - min(all_revenues))
                                        else:
                                            norm_revenue = 0.5
                                        
                                        # Нормализуем цену (0-1, где 1 = максимум)
                                        if max(all_prices) > min(all_prices):
                                            norm_price = (avg_price - min(all_prices)) / (max(all_prices) - min(all_prices))
                                        else:
                                            norm_price = 0.5
                                        
                                        # Нормализуем упущенную выручку (0-1, где 1 = минимум, т.е. лучше)
                                        if max(all_lost) > min(all_lost):
                                            norm_lost = 1 - (lost_revenue_per_sku - min(all_lost)) / (max(all_lost) - min(all_lost))
                                        else:
                                            norm_lost = 0.5
                                        
                                        # Взвешенная сумма с приоритетами
                                        score = (norm_revenue * 0.9) + (norm_price * 0.09) + (norm_lost * 0.01)
                                        return score
                                    
                                    # Сортируем по рассчитанному рейтингу
                                    sorted_by_score = sorted(
                                        summary_data.items(), 
                                        key=calculate_score,
                                        reverse=True
                                    )
                                    ratings = {param_val: i+1 for i, (param_val, _) in enumerate(sorted_by_score)}
                                    st.session_state["param_ratings"][param_rating_key] = ratings
                                
                                ratings = st.session_state["param_ratings"][param_rating_key]
                                
                                # Отображаем таблицу
                                st.write(f"**Сводная таблица по параметру: {selected_param}**")
                                st.info("💡 Цветовое выделение: 🟢 лучший результат в каждой строке. Для позиции в выдаче лучший = меньшее число. Рейтинг формируется по приоритетам: Выручка на 1 артикул (90%) → Средняя цена (9%) → Упущенная выручка на 1 артикул (1%)")
                                
                                # Создаем конфигурацию столбцов
                                column_config = {
                                    "Метрика": st.column_config.TextColumn("Метрика", width=250)
                                }
                                
                                # Настраиваем столбцы для значений параметров
                                for param_value in param_values_list:
                                    column_config[param_value] = st.column_config.TextColumn(
                                        param_value, 
                                        width=150
                                    )
                                
                                # Применяем стили и отображаем таблицу
                                styled_df = display_df.style.apply(lambda x: apply_colors(display_df), axis=None)
                                
                                # Отображаем стилизованную таблицу
                                st.dataframe(
                                    styled_df,
                                    column_config=column_config,
                                    use_container_width=True,
                                    hide_index=True
                                )
                                
                                # Добавляем строку с рейтингом отдельно (без цветового кодирования)
                                st.write("**Рейтинг:**")
                                rating_display_data = {"Метрика": ["Рейтинг"]}
                                for param_value in param_values_list:
                                    rating_display_data[param_value] = [str(ratings.get(param_value, len(param_values_list)+1))]
                                
                                rating_display_df = pd.DataFrame(rating_display_data)
                                st.dataframe(
                                    rating_display_df,
                                    column_config=column_config,
                                    use_container_width=True,
                                    hide_index=True
                                )
                                
                                st.divider()
                                
                                # Редактируемая таблица только для рейтинга
                                st.write("**Редактирование рейтинга:**")
                                
                                # Создаем DataFrame только для рейтинга
                                rating_edit_data = {}
                                for param_value in param_values_list:
                                    rating_edit_data[param_value] = [ratings.get(param_value, len(param_values_list)+1)]
                                
                                rating_edit_df = pd.DataFrame(rating_edit_data, index=["Рейтинг"])
                                
                                # Конфигурация для редактирования рейтинга
                                rating_column_config = {}
                                for param_value in param_values_list:
                                    rating_column_config[param_value] = st.column_config.NumberColumn(
                                        param_value,
                                        min_value=1,
                                        max_value=len(param_values_list),
                                        step=1,
                                        width=150
                                    )
                                
                                # Редактируемая таблица рейтинга
                                edited_rating_df = st.data_editor(
                                    rating_edit_df,
                                    column_config=rating_column_config,
                                    hide_index=False,
                                    key=f"rating_table_{selected_param}"
                                )
                                
                                # Сохраняем изменения рейтинга
                                if not edited_rating_df.equals(rating_edit_df):
                                    new_ratings = {}
                                    for param_value in param_values_list:
                                        new_ratings[param_value] = int(edited_rating_df.loc["Рейтинг", param_value])
                                    st.session_state["param_ratings"][param_rating_key] = new_ratings
                                    
                                    # Автоматически сохраняем рейтинги
                                    try:
                                        # Получаем удаленные параметры для фильтрации
                                        deleted_params = st.session_state.get("deleted_params", load_deleted_params_from_file())
                                        param_values = st.session_state.get("param_values", {})
                                        param_options = st.session_state.get("param_options", {})
                                        
                                        # Фильтруем удаленные параметры перед сохранением
                                        filtered_param_values = {
                                            k: v for k, v in param_values.items() 
                                            if k not in deleted_params
                                        } if deleted_params else param_values
                                        
                                        filtered_param_options = {
                                            k: v for k, v in param_options.items() 
                                            if k not in deleted_params
                                        } if deleted_params else param_options
                                        
                                        table_cache_data = {
                                            "param_values": filtered_param_values,
                                            "param_options": filtered_param_options,
                                            "param_ratings": st.session_state.get("param_ratings", {}),
                                            "timestamp": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S")
                                        }
                                        
                                        import json
                                        with open("table_cache.json", "w", encoding="utf-8") as f:
                                            json.dump(table_cache_data, f, ensure_ascii=False, indent=2)
                                        
                                        st.success("💾 Рейтинг автоматически сохранен")
                                    except Exception as e:
                                        st.error(f"❌ Ошибка сохранения рейтинга: {e}")
                                
                                # Кнопки управления
                                col_reset, col_export_analytics = st.columns(2)
                                
                                with col_reset:
                                    if st.button("🔄 Сбросить рейтинг", type="secondary"):
                                        # Пересчитываем рейтинг по приоритетам
                                        def calculate_score(item):
                                            param_val, metrics = item
                                            # Нормализуем значения от 0 до 1
                                            revenue_per_sku = metrics["Выручка на 1 артикул"]
                                            avg_price = metrics["Средняя цена без СПП"]
                                            lost_revenue_per_sku = metrics["Упущенная выручка на 1 артикул"]
                                            
                                            # Находим мин/макс для нормализации
                                            all_revenues = [m["Выручка на 1 артикул"] for m in summary_data.values()]
                                            all_prices = [m["Средняя цена без СПП"] for m in summary_data.values()]
                                            all_lost = [m["Упущенная выручка на 1 артикул"] for m in summary_data.values()]
                                            
                                            # Нормализуем выручку (0-1, где 1 = максимум)
                                            if max(all_revenues) > min(all_revenues):
                                                norm_revenue = (revenue_per_sku - min(all_revenues)) / (max(all_revenues) - min(all_revenues))
                                            else:
                                                norm_revenue = 0.5
                                            
                                            # Нормализуем цену (0-1, где 1 = максимум)
                                            if max(all_prices) > min(all_prices):
                                                norm_price = (avg_price - min(all_prices)) / (max(all_prices) - min(all_prices))
                                            else:
                                                norm_price = 0.5
                                            
                                            # Нормализуем упущенную выручку (0-1, где 1 = минимум, т.е. лучше)
                                            if max(all_lost) > min(all_lost):
                                                norm_lost = 1 - (lost_revenue_per_sku - min(all_lost)) / (max(all_lost) - min(all_lost))
                                            else:
                                                norm_lost = 0.5
                                            
                                            # Взвешенная сумма с приоритетами
                                            score = (norm_revenue * 0.9) + (norm_price * 0.09) + (norm_lost * 0.01)
                                            return score
                                        
                                        # Сортируем по рассчитанному рейтингу
                                        sorted_by_score = sorted(
                                            summary_data.items(), 
                                            key=calculate_score,
                                            reverse=True
                                        )
                                        ratings = {param_val: i+1 for i, (param_val, _) in enumerate(sorted_by_score)}
                                        st.session_state["param_ratings"][param_rating_key] = ratings
                                        st.rerun()
                                
                                with col_export_analytics:
                                    if st.button("📊 Экспорт аналитики"):
                                        # Создаем полную таблицу для экспорта (с рейтингом)
                                        export_data = display_df.copy()
                                        rating_row = ["Рейтинг"] + [str(ratings.get(param_val, len(param_values_list)+1)) for param_val in param_values_list]
                                        rating_export_df = pd.DataFrame([rating_row], columns=export_data.columns)
                                        full_export_df = pd.concat([export_data, rating_export_df], ignore_index=True)
                                        
                                        csv_data = full_export_df.to_csv(encoding='utf-8-sig', index=False)
                                        # Получаем имя загруженного файла для названия экспорта
                                        base_filename = f"analytics_{selected_param}"
                                        if hasattr(uploaded, 'name') and uploaded.name:
                                            # Убираем расширение и добавляем суффикс
                                            name_without_ext = os.path.splitext(uploaded.name)[0]
                                            base_filename = f"{name_without_ext}_analytics_{selected_param}"
                                        
                                        st.download_button(
                                            label="💾 Скачать CSV",
                                            data=csv_data,
                                            file_name=f"{base_filename}.csv",
                                            mime="text/csv"
                                        )
                                
                                # Дополнительная статистика
                                st.divider()
                                st.write("**Дополнительная статистика:**")
                                
                                col_stat1, col_stat2, col_stat3, col_stat4 = st.columns(4)
                                
                                total_products = sum(item["Количество артикулов"] for item in summary_data.values())
                                total_revenue = sum(item["Общая выручка"] for item in summary_data.values())
                                total_lost_revenue = sum(item["Упущенная выручка"] for item in summary_data.values())
                                avg_position_all = sum(item["Позиция в выдаче (средняя)"] * item["Количество артикулов"] for item in summary_data.values()) / total_products if total_products > 0 else 0
                                
                                col_stat1.metric("Всего товаров", f"{total_products} шт.")
                                col_stat2.metric("Общая выручка", f"₽{total_revenue:,.0f}".replace(",", " "))
                                col_stat3.metric("Упущенная выручка", f"₽{total_lost_revenue:,.0f}".replace(",", " "))
                                col_stat4.metric("Средняя позиция", f"{avg_position_all:.1f}")
                                
                        else:
                            st.info("Нет данных для анализа по выбранному параметру")
                
                # Добавляем анализ комбинаций иерархических параметров
                st.divider()
                st.subheader("📊 Анализ комбинаций иерархических параметров")
                
                # Определяем иерархию сегментов
                # Иерархия параметров: Подтип - это логическая группировка для Рукав и Ворот
                hierarchy_params = get_hierarchy_params()
                subtype_params = get_subtype_params()  # Параметры, которые находятся внутри "Подтип"
                visual_params = get_visual_params()
                
                # Получаем список полностью исключенных параметров
                excluded_params = set(st.session_state.get("excluded_params", []))
                
                # Фильтруем available_params, исключая полностью исключенные параметры
                active_available_params = [p for p in available_params if p not in excluded_params]
                
                # Разделяем параметры на категории (учитывая исключенные параметры)
                hierarchical_params_list = [p for p in hierarchy_params if p in active_available_params]
                visual_params_list = [p for p in active_available_params if p in visual_params or any(vp in p for vp in visual_params)]
                other_params_list = [p for p in active_available_params if p not in hierarchy_params and p not in visual_params_list]
                
                # Показываем информацию об иерархии
                if hierarchical_params_list:
                    # Формируем отображение иерархии с учетом "Подтип" как группировки
                    hierarchy_display = []
                    subtype_params_in_list = [p for p in subtype_params if p in hierarchical_params_list]
                    
                    for param in hierarchy_params:
                        if param in hierarchical_params_list:
                            if param in subtype_params:
                                # Если это первый параметр из подтипа, добавляем "Подтип" перед ним
                                if param == subtype_params[0] and subtype_params_in_list:
                                    subtype_str = " → ".join(subtype_params_in_list)
                                    hierarchy_display.append(f"Подтип ({subtype_str})")
                            else:
                                hierarchy_display.append(param)
                    
                    # Убираем дубликаты и формируем строку
                    hierarchy_str = " → ".join(hierarchy_display)
                    if not hierarchy_str:
                        hierarchy_str = " → ".join(hierarchical_params_list)
                    st.info(f"📊 **Иерархия сегментов**: {hierarchy_str} → Визуальные параметры")
                    
                    # Инициализация excluded_param_values если нет
                    if "excluded_param_values" not in st.session_state:
                        st.session_state["excluded_param_values"] = {}
                    
                    # UI для исключения значений параметров
                    with st.expander("🚫 Исключить значения параметров из анализа", expanded=False):
                        st.markdown("#### 🚫 Исключение значений параметров")
                        st.info("💡 Выберите конкретные значения параметров, которые нужно исключить из анализа комбинаций иерархических параметров. Товары с этими значениями не будут учитываться в комбинациях.")
                        
                        # Получаем все уникальные значения для каждого иерархического параметра
                        param_values_dict = {}
                        for param_name in hierarchical_params_list:
                            if param_name in param_values:
                                unique_values = set()
                                for sku_str, value in param_values[param_name].items():
                                    if value and str(value).strip():
                                        unique_values.add(str(value).strip())
                                if unique_values:
                                    param_values_dict[param_name] = sorted(list(unique_values))
                        
                        excluded_selected = {}
                        if param_values_dict:
                            for param_name, available_values in param_values_dict.items():
                                current_excluded = st.session_state["excluded_param_values"].get(param_name, [])
                                
                                excluded_values = st.multiselect(
                                    f"Исключить значения параметра '{param_name}':",
                                    options=available_values,
                                    default=current_excluded,
                                    help=f"Выберите значения параметра '{param_name}', которые нужно исключить из анализа комбинаций иерархических параметров",
                                    key=f"hierarchy_excluded_values_{param_name}"
                                )
                                
                                excluded_selected[param_name] = excluded_values
                            
                            # Обновляем excluded_param_values из session_state (значения из multiselect сохраняются автоматически)
                            current_excluded_param_values = st.session_state.get("excluded_param_values", {}).copy()
                            for param_name in hierarchical_params_list:
                                key = f"hierarchy_excluded_values_{param_name}"
                                if key in st.session_state:
                                    current_excluded_param_values[param_name] = st.session_state[key]
                                    excluded_selected[param_name] = st.session_state[key]
                            
                            st.session_state["excluded_param_values"] = current_excluded_param_values
                            
                            # Автоматически сохраняем настройки при изменении
                            save_excluded_params_settings()
                            
                            # Кнопка для сброса исключений
                            if st.button("🔄 Сбросить исключения для иерархических параметров", type="secondary", use_container_width=True, key="reset_hierarchy_excluded_values"):
                                # Сбрасываем только для иерархических параметров
                                current_excluded_param_values = st.session_state.get("excluded_param_values", {}).copy()
                                for param_name in hierarchical_params_list:
                                    if param_name in current_excluded_param_values:
                                        del current_excluded_param_values[param_name]
                                    # Также сбрасываем в multiselect
                                    key = f"hierarchy_excluded_values_{param_name}"
                                    if key in st.session_state:
                                        st.session_state[key] = []
                                st.session_state["excluded_param_values"] = current_excluded_param_values
                                save_excluded_params_settings()
                                st.rerun()
                            
                            # Показываем статистику исключений
                            total_excluded_values = sum(len(values) for param_name, values in excluded_selected.items() if param_name in hierarchical_params_list)
                            if total_excluded_values > 0:
                                st.success(f"✅ Исключено значений: {total_excluded_values}. Настройки применяются автоматически.")
                            else:
                                st.info("ℹ️ Выберите значения параметров для исключения из анализа")
                        else:
                            st.warning("⚠️ Нет доступных значений параметров для исключения")
                    
                    # Анализ комбинаций иерархических параметров
                    if len(hierarchical_params_list) > 1:
                        st.write("**Анализ комбинаций иерархических параметров:**")
                        
                        # Собираем все комбинации иерархических параметров
                        hierarchy_combinations = {}
                        
                        # Получаем список полностью исключенных параметров
                        excluded_params = set(st.session_state.get("excluded_params", []))
                        
                        # Получаем исключенные значения параметров
                        excluded_param_values = st.session_state.get("excluded_param_values", {})
                        
                        # Фильтруем иерархические параметры, исключая полностью исключенные
                        active_hierarchical_params = [p for p in hierarchical_params_list if p not in excluded_params]
                        
                        # Получаем все артикулы с заполненными иерархическими параметрами
                        for sku in df["Артикул"].astype(str).str.replace(".0", "").unique():
                            sku_str = str(sku)
                            combination_key_parts = []
                            combination_valid = True
                            
                            # Используем только активные (не исключенные) параметры
                            for param_name in active_hierarchical_params:
                                if param_name in param_values and sku_str in param_values[param_name]:
                                    value = param_values[param_name][sku_str]
                                    if value and str(value).strip():
                                        value_str = str(value).strip()
                                        
                                        # Проверяем, не исключено ли это значение параметра
                                        excluded_values_for_param = excluded_param_values.get(param_name, [])
                                        if value_str in excluded_values_for_param:
                                            combination_valid = False
                                            break
                                        
                                        combination_key_parts.append(f"{param_name}:{value_str}")
                                    else:
                                        combination_valid = False
                                        break
                                else:
                                    combination_valid = False
                                    break
                            
                            if combination_valid and combination_key_parts:
                                combination_key = " | ".join(combination_key_parts)
                                if combination_key not in hierarchy_combinations:
                                    hierarchy_combinations[combination_key] = []
                                hierarchy_combinations[combination_key].append(sku_str)
                        
                        if hierarchy_combinations:
                            # Рассчитываем метрики для каждой комбинации
                            combination_analytics = []
                            for combination_key, skus in hierarchy_combinations.items():
                                mask = df["Артикул"].astype(str).str.replace(".0", "").isin(skus)
                                filtered_df = df[mask]
                                
                                if not filtered_df.empty:
                                    total_revenue = filtered_df["Выручка"].sum() if "Выручка" in filtered_df.columns else 0
                                    total_orders = filtered_df["Заказы"].sum() if "Заказы" in filtered_df.columns else 0
                                    revenue_per_product = total_revenue / len(filtered_df) if len(filtered_df) > 0 else 0
                                    avg_price = filtered_df["Средняя цена"].mean() if "Средняя цена" in filtered_df.columns else 0
                                    
                                    combination_analytics.append({
                                        "Комбинация": combination_key,
                                        "Количество товаров": len(filtered_df),
                                        "Общая выручка": total_revenue,
                                        "Выручка на 1 артикул": revenue_per_product,
                                        "Средняя цена": avg_price
                                    })
                            
                            if combination_analytics:
                                # Сортируем по выручке на 1 артикул
                                combination_analytics.sort(key=lambda x: x["Выручка на 1 артикул"], reverse=True)
                                
                                # Показываем топ-5 комбинаций
                                st.write("**Топ-5 комбинаций иерархических параметров:**")
                                top_combinations_df = pd.DataFrame(combination_analytics[:5])
                                st.dataframe(top_combinations_df, use_container_width=True)
                                
                                # Сохраняем лучшую комбинацию
                                best_hierarchy_combination = combination_analytics[0]["Комбинация"]
                                
                                # Находим артикулы, соответствующие лучшей комбинации иерархии
                                best_combination_skus = hierarchy_combinations[best_hierarchy_combination]
                                
                                # Получаем рейтинги параметров из session_state
                                param_ratings = {}
                                # available_params уже определен выше в коде (строка 4600)
                                for param in available_params:
                                    rating_key = f"{param}_ratings"
                                    if rating_key in st.session_state.get("param_ratings", {}):
                                        param_ratings[param] = st.session_state["param_ratings"][rating_key]
                                
                                # Находим лучшие визуальные и другие параметры для этой иерархии
                                best_visual_params = {}
                                best_other_params = {}
                                
                                # Используем уже определенные списки параметров (определены выше в коде)
                                # visual_params_list и other_params_list уже определены в строках 5476-5477
                                
                                # Для визуальных параметров находим значения с рейтингом 1
                                for param_name in visual_params_list:
                                    if param_name in param_ratings:
                                        ratings = param_ratings[param_name]
                                        for value, rating in ratings.items():
                                            if rating == 1:
                                                best_visual_params[param_name] = value
                                                break
                                
                                # Для других параметров находим значения с рейтингом 1
                                for param_name in other_params_list:
                                    if param_name in param_ratings:
                                        ratings = param_ratings[param_name]
                                        for value, rating in ratings.items():
                                            if rating == 1:
                                                best_other_params[param_name] = value
                                                break
                                
                                # Формируем полную строку комбинации
                                full_combination_parts = [best_hierarchy_combination]
                                
                                # Добавляем визуальные параметры
                                if best_visual_params:
                                    visual_parts = [f"{k}:{v}" for k, v in best_visual_params.items()]
                                    full_combination_parts.extend(visual_parts)
                                
                                # Добавляем другие параметры
                                if best_other_params:
                                    other_parts = [f"{k}:{v}" for k, v in best_other_params.items()]
                                    full_combination_parts.extend(other_parts)
                                
                                # Формируем полную комбинацию
                                full_combination = " | ".join(full_combination_parts)
                                
                                st.success(f"🏆 **Лучшая комбинация иерархии**: {full_combination}")
                        else:
                            st.info("ℹ️ Не найдено товаров с заполненными всеми иерархическими параметрами")
                    else:
                        st.info("ℹ️ Для анализа комбинаций нужно минимум 2 иерархических параметра")
                
                # Добавляем анализ лучших полных комбинаций всех параметров
                st.divider()
                st.subheader("🏆 Топ-10 лучших комбинаций параметров")
                st.info("💡 Система анализирует все возможные комбинации параметров и находит лучшие по метрикам: Выручка на 1 артикул (90%) → Средняя цена (9%) → Упущенная выручка на 1 артикул (1%)")
                
                # Получаем период отчета для фильтрации новинок
                report_end_date = None
                if "Дата создания" in df.columns and not df["Дата создания"].isna().all():
                    # Используем максимальную дату из "Дата создания" как дату отчета
                    report_end_date = df["Дата создания"].dropna().max()
                else:
                    # Пытаемся получить период из анализа
                    df_raw = st.session_state.get("df_raw")
                    header_row = st.session_state.get("header_row")
                    if df_raw is not None and header_row is not None:
                        period_info = get_analysis_period(df, df_raw, header_row, error_callback=st.error)
                        if period_info and "end_date" in period_info:
                            report_end_date = period_info["end_date"]
                    # Если не нашли, используем текущую дату
                    if report_end_date is None:
                        report_end_date = pd.Timestamp.now()
                
                # Добавляем выбор периода для создания комбинаций новинок
                novelty_filter_options = {
                    "Все товары": None,
                    "Создать комбинации для новинок (6 месяцев)": 6,
                    "Создать комбинации для новинок (3 месяца)": 3
                }
                
                selected_novelty_filter = st.selectbox(
                    "🔍 Комбинации для новинок:",
                    options=list(novelty_filter_options.keys()),
                    index=0,
                    help="Выберите период для создания отдельных комбинаций новинок. Товары, появившиеся в выбранный период, будут иметь дополнительный параметр 'Период появления' в комбинациях."
                )
                
                novelty_months = novelty_filter_options[selected_novelty_filter]
                
                # Определяем, какие товары являются новинками
                novelty_skus = set()
                if novelty_months is not None:
                    if "Дата создания" not in df.columns:
                        st.warning("⚠️ Для создания комбинаций новинок требуется колонка 'Дата создания'. Параметр не будет добавлен.")
                        novelty_months = None
                    elif report_end_date is None:
                        st.warning("⚠️ Не удалось определить дату отчета. Параметр новинок не будет добавлен.")
                        novelty_months = None
                    else:
                        # Вычисляем дату начала периода для новинок
                        if isinstance(report_end_date, pd.Timestamp):
                            start_date_for_novelties = report_end_date - pd.DateOffset(months=novelty_months)
                        else:
                            start_date_for_novelties = pd.to_datetime(report_end_date) - pd.DateOffset(months=novelty_months)
                        
                        # Находим товары-новинки: те, у которых "Дата создания" в пределах периода новинок
                        # Важно: проверяем, что дата создания не пустая
                        novelty_mask = (
                            (df["Дата создания"] >= start_date_for_novelties) & 
                            (df["Дата создания"] <= report_end_date) &
                            (df["Дата создания"].notna())
                        )
                        novelty_skus = set(
                            df.loc[novelty_mask, "Артикул"].astype(str).str.replace(".0", "").unique()
                        )
                        
                        if novelty_skus:
                            st.info(f"📦 Для новинок (товары с {start_date_for_novelties.strftime('%d.%m.%Y')} по {report_end_date.strftime('%d.%m.%Y')}, всего {len(novelty_skus)} товаров) будут созданы отдельные комбинации с параметром 'Период появления'")
                        else:
                            st.warning(f"⚠️ Не найдено новинок за последние {novelty_months} месяцев")
                
                # Собираем все полные комбинации параметров
                param_values = st.session_state.get("param_values", {})
                all_combinations = {}
                
                # Получаем список полностью исключенных параметров
                excluded_params = set(st.session_state.get("excluded_params", []))
                
                # Фильтруем available_params, исключая полностью исключенные параметры
                active_params = [p for p in available_params if p not in excluded_params]
                
                # Проходим по всем артикулам и собираем их полные комбинации параметров
                all_skus = df["Артикул"].astype(str).str.replace(".0", "").unique()
                
                # Разделяем товары на новинки и не-новинки для создания отдельных комбинаций
                for sku in all_skus:
                    sku_str = str(sku)
                    combination_parts = []
                    
                    # Собираем все заполненные параметры для этого артикула (только активные, не исключенные)
                    # НЕ требуется, чтобы все параметры были заполнены - создаем комбинацию с частично заполненными
                    for param_name in active_params:
                        if param_name in param_values and sku_str in param_values[param_name]:
                            value = param_values[param_name][sku_str]
                            if value and str(value).strip():
                                combination_parts.append(f"{param_name}:{value}")
                    
                    # Создаем комбинацию, если есть хотя бы один заполненный параметр
                    if not combination_parts:
                        continue
                    
                    # Если выбран период для новинок, создаем отдельные комбинации для новинок и не-новинок
                    if novelty_months is not None:
                        # Дополнительная проверка: проверяем дату создания напрямую для каждого товара
                        is_novelty = False
                        if sku_str in novelty_skus:
                            # Дополнительно проверяем дату создания напрямую в данных
                            if "Дата создания" in df.columns and report_end_date is not None:
                                # Получаем все строки для этого артикула
                                sku_mask = df["Артикул"].astype(str).str.replace(".0", "") == sku_str
                                sku_rows = df[sku_mask]
                                
                                if not sku_rows.empty:
                                    # Проверяем, есть ли хотя бы одна строка с датой создания в периоде новинок
                                    if isinstance(report_end_date, pd.Timestamp):
                                        start_date_for_novelties = report_end_date - pd.DateOffset(months=novelty_months)
                                    else:
                                        start_date_for_novelties = pd.to_datetime(report_end_date) - pd.DateOffset(months=novelty_months)
                                    
                                    # Проверяем дату создания
                                    date_mask = (
                                        (sku_rows["Дата создания"] >= start_date_for_novelties) & 
                                        (sku_rows["Дата создания"] <= report_end_date) &
                                        (sku_rows["Дата создания"].notna())
                                    )
                                    is_novelty = date_mask.any()
                            else:
                                # Если нет даты создания, используем только проверку по novelty_skus
                                is_novelty = True
                        else:
                            is_novelty = False
                        
                        if is_novelty:
                            # Для новинок: добавляем параметр "Период появления" и создаем отдельную комбинацию
                            novelty_combination_parts = combination_parts.copy()
                            novelty_combination_parts.append(f"Период появления:Новинка ({novelty_months} месяцев)")
                            combination_key = " | ".join(sorted(novelty_combination_parts))
                            if combination_key not in all_combinations:
                                all_combinations[combination_key] = []
                            all_combinations[combination_key].append(sku_str)
                        else:
                            # Для не-новинок: создаем обычную комбинацию без параметра "Период появления"
                            combination_key = " | ".join(sorted(combination_parts))
                            if combination_key not in all_combinations:
                                all_combinations[combination_key] = []
                            all_combinations[combination_key].append(sku_str)
                    else:
                        # Если фильтр новинок не выбран, создаем обычные комбинации для всех товаров
                        combination_key = " | ".join(sorted(combination_parts))
                        if combination_key not in all_combinations:
                            all_combinations[combination_key] = []
                        all_combinations[combination_key].append(sku_str)
                
                if all_combinations:
                    # Рассчитываем метрики для каждой комбинации
                    combination_analytics = []
                    
                    for combination_key, skus in all_combinations.items():
                        # Проверяем, является ли это комбинацией новинок
                        is_novelty_combination = novelty_months is not None and "Период появления:Новинка" in combination_key
                        
                        # Создаем маску для фильтрации товаров
                        mask = df["Артикул"].astype(str).str.replace(".0", "").isin(skus)
                        
                        # Если это комбинация новинок, дополнительно фильтруем по дате создания
                        if is_novelty_combination and "Дата создания" in df.columns and report_end_date is not None:
                            if isinstance(report_end_date, pd.Timestamp):
                                start_date_for_novelties = report_end_date - pd.DateOffset(months=novelty_months)
                            else:
                                start_date_for_novelties = pd.to_datetime(report_end_date) - pd.DateOffset(months=novelty_months)
                            
                            # Дополнительная фильтрация: только товары с датой создания в периоде новинок
                            novelty_date_mask = (
                                (df["Дата создания"] >= start_date_for_novelties) & 
                                (df["Дата создания"] <= report_end_date)
                            )
                            mask = mask & novelty_date_mask
                        
                        filtered_df = df[mask]
                        
                        if not filtered_df.empty:
                            total_revenue = filtered_df["Выручка"].sum() if "Выручка" in filtered_df.columns else 0
                            total_orders = filtered_df["Заказы"].sum() if "Заказы" in filtered_df.columns else 0
                            avg_price = filtered_df["Средняя цена"].mean() if "Средняя цена" in filtered_df.columns else 0
                            lost_revenue = filtered_df["Упущенная выручка"].sum() if "Упущенная выручка" in filtered_df.columns else 0
                            revenue_per_product = total_revenue / len(filtered_df) if len(filtered_df) > 0 else 0
                            lost_revenue_per_product = lost_revenue / len(filtered_df) if len(filtered_df) > 0 else 0
                            avg_position = filtered_df["Позиция в выдаче"].mean() if "Позиция в выдаче" in filtered_df.columns else 0
                            avg_cpm = filtered_df["Стоимость за 1000 показов"].mean() if "Стоимость за 1000 показов" in filtered_df.columns else 0
                            cpm_per_product = avg_cpm / len(filtered_df) if len(filtered_df) > 0 else 0
                            
                            combination_analytics.append({
                                "Комбинация": combination_key,
                                "Общая выручка": total_revenue,
                                "Количество артикулов": len(filtered_df),
                                "Выручка на 1 артикул": revenue_per_product,
                                "Средняя цена без СПП": avg_price,
                                "Упущенная выручка": lost_revenue,
                                "Упущенная выручка на 1 артикул": lost_revenue_per_product,
                                "Позиция в выдаче (средняя)": avg_position,
                                "Стоимость за 1000 показов на 1 артикул": cpm_per_product
                            })
                    
                    if combination_analytics:
                        # Рассчитываем рейтинг для каждой комбинации
                        # Нормализуем значения для расчета рейтинга
                        all_revenues = [c["Выручка на 1 артикул"] for c in combination_analytics]
                        all_prices = [c["Средняя цена без СПП"] for c in combination_analytics]
                        all_lost = [c["Упущенная выручка на 1 артикул"] for c in combination_analytics]
                        
                        def calculate_combination_score(combo):
                            revenue_per_sku = combo["Выручка на 1 артикул"]
                            avg_price = combo["Средняя цена без СПП"]
                            lost_revenue_per_sku = combo["Упущенная выручка на 1 артикул"]
                            
                            # Нормализуем выручку (0-1, где 1 = максимум)
                            if max(all_revenues) > min(all_revenues):
                                norm_revenue = (revenue_per_sku - min(all_revenues)) / (max(all_revenues) - min(all_revenues))
                            else:
                                norm_revenue = 0.5
                            
                            # Нормализуем цену (0-1, где 1 = максимум)
                            if max(all_prices) > min(all_prices):
                                norm_price = (avg_price - min(all_prices)) / (max(all_prices) - min(all_prices))
                            else:
                                norm_price = 0.5
                            
                            # Нормализуем упущенную выручку (0-1, где 1 = минимум, т.е. лучше)
                            if max(all_lost) > min(all_lost):
                                norm_lost = 1 - (lost_revenue_per_sku - min(all_lost)) / (max(all_lost) - min(all_lost))
                            else:
                                norm_lost = 0.5
                            
                            # Взвешенная сумма с приоритетами: Выручка на 1 артикул (90%) → Средняя цена (9%) → Упущенная выручка на 1 артикул (1%)
                            score = (norm_revenue * 0.9) + (norm_price * 0.09) + (norm_lost * 0.01)
                            return score
                        
                        # Разделяем комбинации на новинки и не-новинки, если выбран период для новинок
                        if novelty_months is not None:
                            novelty_combinations = []
                            regular_combinations = []
                            
                            for combo in combination_analytics:
                                if "Период появления:Новинка" in combo["Комбинация"]:
                                    novelty_combinations.append(combo)
                                else:
                                    regular_combinations.append(combo)
                            
                            # Рассчитываем рейтинг отдельно для новинок
                            if novelty_combinations:
                                novelty_revenues = [c["Выручка на 1 артикул"] for c in novelty_combinations]
                                novelty_prices = [c["Средняя цена без СПП"] for c in novelty_combinations]
                                novelty_lost = [c["Упущенная выручка на 1 артикул"] for c in novelty_combinations]
                                
                                def calculate_novelty_score(combo):
                                    revenue_per_sku = combo["Выручка на 1 артикул"]
                                    avg_price = combo["Средняя цена без СПП"]
                                    lost_revenue_per_sku = combo["Упущенная выручка на 1 артикул"]
                                    
                                    if max(novelty_revenues) > min(novelty_revenues):
                                        norm_revenue = (revenue_per_sku - min(novelty_revenues)) / (max(novelty_revenues) - min(novelty_revenues))
                                    else:
                                        norm_revenue = 0.5
                                    
                                    if max(novelty_prices) > min(novelty_prices):
                                        norm_price = (avg_price - min(novelty_prices)) / (max(novelty_prices) - min(novelty_prices))
                                    else:
                                        norm_price = 0.5
                                    
                                    if max(novelty_lost) > min(novelty_lost):
                                        norm_lost = 1 - (lost_revenue_per_sku - min(novelty_lost)) / (max(novelty_lost) - min(novelty_lost))
                                    else:
                                        norm_lost = 0.5
                                    
                                    score = (norm_revenue * 0.9) + (norm_price * 0.09) + (norm_lost * 0.01)
                                    return score
                                
                                for combo in novelty_combinations:
                                    combo["Рейтинг"] = calculate_novelty_score(combo)
                                novelty_combinations.sort(key=lambda x: x["Рейтинг"], reverse=True)
                            
                            # Рассчитываем рейтинг отдельно для не-новинок
                            if regular_combinations:
                                regular_revenues = [c["Выручка на 1 артикул"] for c in regular_combinations]
                                regular_prices = [c["Средняя цена без СПП"] for c in regular_combinations]
                                regular_lost = [c["Упущенная выручка на 1 артикул"] for c in regular_combinations]
                                
                                def calculate_regular_score(combo):
                                    revenue_per_sku = combo["Выручка на 1 артикул"]
                                    avg_price = combo["Средняя цена без СПП"]
                                    lost_revenue_per_sku = combo["Упущенная выручка на 1 артикул"]
                                    
                                    if max(regular_revenues) > min(regular_revenues):
                                        norm_revenue = (revenue_per_sku - min(regular_revenues)) / (max(regular_revenues) - min(regular_revenues))
                                    else:
                                        norm_revenue = 0.5
                                    
                                    if max(regular_prices) > min(regular_prices):
                                        norm_price = (avg_price - min(regular_prices)) / (max(regular_prices) - min(regular_prices))
                                    else:
                                        norm_price = 0.5
                                    
                                    if max(regular_lost) > min(regular_lost):
                                        norm_lost = 1 - (lost_revenue_per_sku - min(regular_lost)) / (max(regular_lost) - min(regular_lost))
                                    else:
                                        norm_lost = 0.5
                                    
                                    score = (norm_revenue * 0.9) + (norm_price * 0.09) + (norm_lost * 0.01)
                                    return score
                                
                                for combo in regular_combinations:
                                    combo["Рейтинг"] = calculate_regular_score(combo)
                                regular_combinations.sort(key=lambda x: x["Рейтинг"], reverse=True)
                            
                            # Сохраняем разделенные комбинации
                            combination_analytics_novelty = novelty_combinations
                            combination_analytics_regular = regular_combinations
                            # Для обратной совместимости оставляем combination_analytics как объединенный список
                            combination_analytics = novelty_combinations + regular_combinations
                        else:
                            # Если фильтр новинок не выбран, рассчитываем рейтинг для всех комбинаций вместе
                            for combo in combination_analytics:
                                combo["Рейтинг"] = calculate_combination_score(combo)
                            
                            # Сортируем по рейтингу (от большего к меньшему)
                            combination_analytics.sort(key=lambda x: x["Рейтинг"], reverse=True)
                            
                            # Разделяем комбинации на новинки и не-новинки
                            if novelty_months is not None:
                                combination_analytics_novelty = [c for c in combination_analytics if "Период появления:Новинка" in c["Комбинация"]]
                                combination_analytics_regular = [c for c in combination_analytics if "Период появления:Новинка" not in c["Комбинация"]]
                            else:
                                combination_analytics_novelty = []
                                combination_analytics_regular = combination_analytics
                        
                        # Загружаем настройки исключения параметров из файла (если еще не загружены)
                        if "excluded_params_loaded" not in st.session_state:
                            load_excluded_params_settings()
                            st.session_state["excluded_params_loaded"] = True
                        
                        # Инициализируем список исключенных значений параметров
                        if "excluded_param_values" not in st.session_state:
                            st.session_state["excluded_param_values"] = {}
                        
                        # Инициализируем список полностью исключенных параметров
                        if "excluded_params" not in st.session_state:
                            st.session_state["excluded_params"] = []
                        
                        # Собираем все уникальные значения для каждого параметра
                        param_values_dict = {}
                        for combo in combination_analytics:
                            combo_str = combo["Комбинация"]
                            # Парсим комбинацию: "Параметр1:Значение1 | Параметр2:Значение2 | ..."
                            parts = [p.strip() for p in combo_str.split("|")]
                            for part in parts:
                                if ":" in part:
                                    param_name, param_value = part.split(":", 1)
                                    param_name = param_name.strip()
                                    param_value = param_value.strip()
                                    if param_name not in param_values_dict:
                                        param_values_dict[param_name] = set()
                                    param_values_dict[param_name].add(param_value)
                        
                        # Дополняем значениями из param_options, чтобы были доступны все варианты параметров
                        # (даже те, которые не присутствуют в текущих комбинациях)
                        param_options = st.session_state.get("param_options", {})
                        for param_name, options_list in param_options.items():
                            if param_name not in param_values_dict:
                                param_values_dict[param_name] = set()
                            # Добавляем все значения из param_options
                            for option_value in options_list:
                                if option_value and str(option_value).strip():
                                    param_values_dict[param_name].add(str(option_value).strip())
                        
                        # Показываем интерфейс для исключения значений параметров и самих параметров
                        with st.expander("🚫 Исключить значения параметров из анализа", expanded=False):
                            st.info("💡 Выберите конкретные значения параметров для исключения. Все комбинации, содержащие эти значения, будут исключены из топ-10.")
                            st.info("💡 Вы также можете полностью исключить параметр из анализа. Товары останутся, но параметр не будет участвовать в формировании комбинаций и рейтинге.")
                            
                            # Раздел 1: Скрытие параметров
                            st.markdown("### 👁️ Скрыть параметры")
                            current_excluded_params = st.session_state.get("excluded_params", [])
                            
                            # Фильтруем значения по умолчанию, чтобы они были только из доступных опций
                            available_param_names = sorted(param_values_dict.keys())
                            filtered_default = [p for p in current_excluded_params if p in available_param_names]
                            
                            excluded_params_selected = st.multiselect(
                                "Скрыть параметры (не будут показываться в таблице и не будут учитываться в топ комбинациях):",
                                options=available_param_names,
                                default=filtered_default,
                                help="Выберите параметры, которые нужно скрыть. Параметры не будут отображаться в таблице и не будут учитываться при формировании комбинаций. Товары останутся в таблице."
                            )
                            
                            # Обновляем список исключенных параметров
                            st.session_state["excluded_params"] = excluded_params_selected
                            # Сохраняем настройки при изменении
                            save_excluded_params_settings()
                            
                            # Раздел 2: Исключение конкретных значений параметров
                            st.markdown("### 🚫 Исключить конкретные значения параметров")
                            
                            # Для каждого параметра создаем мультиселект (только для неисключенных параметров)
                            excluded_selected = {}
                            for param_name in sorted(param_values_dict.keys()):
                                # Пропускаем полностью исключенные параметры
                                if param_name in excluded_params_selected:
                                    continue
                                
                                available_values = sorted(list(param_values_dict[param_name]))
                                current_excluded = st.session_state["excluded_param_values"].get(param_name, [])
                                
                                excluded_values = st.multiselect(
                                    f"Исключить значения параметра '{param_name}':",
                                    options=available_values,
                                    default=current_excluded,
                                    help=f"Выберите значения параметра '{param_name}', которые нужно исключить из анализа"
                                )
                                
                                excluded_selected[param_name] = excluded_values
                            
                            # Обновляем список исключенных значений
                            st.session_state["excluded_param_values"] = excluded_selected
                            # Сохраняем настройки при изменении
                            save_excluded_params_settings()
                            
                            # Кнопка для сброса всех исключений
                            if st.button("🔄 Сбросить все исключения", type="secondary"):
                                st.session_state["excluded_param_values"] = {}
                                st.session_state["excluded_params"] = []
                                # Сохраняем очищенные настройки
                                save_excluded_params_settings()
                                st.rerun()
                            
                            # Показываем статистику исключений
                            total_excluded_params = len(excluded_params_selected)
                            total_excluded_values = sum(len(values) for values in excluded_selected.values())
                            
                            if total_excluded_params > 0 or total_excluded_values > 0:
                                st.markdown("---")
                                st.markdown("**Статистика исключений:**")
                                if total_excluded_params > 0:
                                    st.write(f"  ❌ Полностью исключено параметров: {total_excluded_params}")
                                    for param_name in excluded_params_selected:
                                        st.write(f"    • {param_name}")
                                if total_excluded_values > 0:
                                    excluded_list = []
                                    for param_name, values in excluded_selected.items():
                                        if values:
                                            excluded_list.append(f"{param_name}: {', '.join(values)}")
                                    st.write(f"  🚫 Исключено значений параметров: {total_excluded_values}")
                                    for item in excluded_list:
                                        st.write(f"    • {item}")
                        
                        # Получаем список полностью исключенных параметров
                        excluded_params = set(st.session_state.get("excluded_params", []))
                        
                        # Функция для удаления исключенных параметров из строки комбинации
                        def remove_excluded_params_from_combo(combo_str):
                            """Удаляет исключенные параметры из строки комбинации"""
                            if not combo_str:
                                return combo_str
                            parts = [p.strip() for p in combo_str.split("|")]
                            filtered_parts = []
                            for part in parts:
                                if ":" in part:
                                    param_name, param_value = part.split(":", 1)
                                    param_name = param_name.strip()
                                    # Пропускаем исключенные параметры
                                    if param_name not in excluded_params:
                                        filtered_parts.append(part.strip())
                            return " | ".join(sorted(filtered_parts))
                        
                        # Функция для фильтрации комбинаций по исключенным значениям параметров
                        def should_exclude_combination(combo_str):
                            """Проверяет, нужно ли исключить комбинацию"""
                            parts = [p.strip() for p in combo_str.split("|")]
                            for part in parts:
                                if ":" in part:
                                    param_name, param_value = part.split(":", 1)
                                    param_name = param_name.strip()
                                    param_value = param_value.strip()
                                    # Пропускаем полностью исключенные параметры
                                    if param_name in excluded_params:
                                        continue
                                    # Проверяем, исключено ли это значение параметра
                                    excluded_values = st.session_state["excluded_param_values"].get(param_name, [])
                                    if param_value in excluded_values:
                                        return True
                            return False
                        
                        # Переформируем комбинации: удаляем исключенные параметры и перегруппировываем
                        # Создаем новый словарь комбинаций БЕЗ исключенных параметров
                        regrouped_combinations = {}
                        for combo in combination_analytics:
                            # Удаляем исключенные параметры из строки комбинации
                            cleaned_combo_str = remove_excluded_params_from_combo(combo["Комбинация"])
                            
                            # Пропускаем комбинации с исключенными значениями
                            if should_exclude_combination(combo["Комбинация"]):
                                continue
                            
                            # Пропускаем пустые комбинации
                            if not cleaned_combo_str:
                                continue
                            
                            # Перегруппировываем: собираем все артикулы для очищенной комбинации
                            if cleaned_combo_str not in regrouped_combinations:
                                regrouped_combinations[cleaned_combo_str] = {
                                    "skus": [],
                                    "original_combos": []
                                }
                            
                            # Добавляем артикулы из исходной комбинации
                            combo_skus = all_combinations.get(combo["Комбинация"], [])
                            
                            # Если это комбинация новинок, проверяем дату создания для каждого артикула
                            is_original_novelty_combo = novelty_months is not None and "Период появления:Новинка" in combo["Комбинация"]
                            if is_original_novelty_combo and "Дата создания" in df.columns and report_end_date is not None:
                                if isinstance(report_end_date, pd.Timestamp):
                                    start_date_for_novelties = report_end_date - pd.DateOffset(months=novelty_months)
                                else:
                                    start_date_for_novelties = pd.to_datetime(report_end_date) - pd.DateOffset(months=novelty_months)
                                
                                # Фильтруем артикулы: оставляем только те, у которых дата создания в периоде новинок
                                filtered_skus = []
                                for sku in combo_skus:
                                    sku_mask = df["Артикул"].astype(str).str.replace(".0", "") == sku
                                    sku_rows = df[sku_mask]
                                    
                                    if not sku_rows.empty:
                                        date_mask = (
                                            (sku_rows["Дата создания"] >= start_date_for_novelties) & 
                                            (sku_rows["Дата создания"] <= report_end_date) &
                                            (sku_rows["Дата создания"].notna())
                                        )
                                        if date_mask.any():
                                            filtered_skus.append(sku)
                                
                                combo_skus = filtered_skus
                            
                            regrouped_combinations[cleaned_combo_str]["skus"].extend(combo_skus)
                            regrouped_combinations[cleaned_combo_str]["original_combos"].append(combo)
                        
                        # Пересчитываем метрики для перегруппированных комбинаций
                        regrouped_analytics = []
                        for cleaned_combo_str, combo_data in regrouped_combinations.items():
                            skus = list(set(combo_data["skus"]))  # Убираем дубликаты
                            if not skus:
                                continue
                            
                            # Проверяем, является ли это комбинацией новинок
                            is_novelty_combo = novelty_months is not None and "Период появления:Новинка" in cleaned_combo_str
                            
                            mask = df["Артикул"].astype(str).str.replace(".0", "").isin(skus)
                            
                            # Если это комбинация новинок, дополнительно фильтруем по дате создания
                            if is_novelty_combo and "Дата создания" in df.columns and report_end_date is not None:
                                if isinstance(report_end_date, pd.Timestamp):
                                    start_date_for_novelties = report_end_date - pd.DateOffset(months=novelty_months)
                                else:
                                    start_date_for_novelties = pd.to_datetime(report_end_date) - pd.DateOffset(months=novelty_months)
                                
                                # Дополнительная фильтрация: только товары с датой создания в периоде новинок
                                novelty_date_mask = (
                                    (df["Дата создания"] >= start_date_for_novelties) & 
                                    (df["Дата создания"] <= report_end_date)
                                )
                                mask = mask & novelty_date_mask
                            
                            filtered_df = df[mask]
                            
                            if not filtered_df.empty:
                                total_revenue = filtered_df["Выручка"].sum() if "Выручка" in filtered_df.columns else 0
                                total_orders = filtered_df["Заказы"].sum() if "Заказы" in filtered_df.columns else 0
                                avg_price = filtered_df["Средняя цена"].mean() if "Средняя цена" in filtered_df.columns else 0
                                lost_revenue = filtered_df["Упущенная выручка"].sum() if "Упущенная выручка" in filtered_df.columns else 0
                                revenue_per_product = total_revenue / len(filtered_df) if len(filtered_df) > 0 else 0
                                lost_revenue_per_product = lost_revenue / len(filtered_df) if len(filtered_df) > 0 else 0
                                avg_position = filtered_df["Позиция в выдаче"].mean() if "Позиция в выдаче" in filtered_df.columns else 0
                                avg_cpm = filtered_df["Стоимость за 1000 показов"].mean() if "Стоимость за 1000 показов" in filtered_df.columns else 0
                                cpm_per_product = avg_cpm / len(filtered_df) if len(filtered_df) > 0 else 0
                                
                                # Применяем СПП для расчета цены без СПП
                                spp = st.session_state.get("spp", 15)
                                avg_price_without_spp = avg_price / (1 - float(spp) / 100.0) if float(spp) < 100 else avg_price
                                
                                regrouped_analytics.append({
                                    "Комбинация": cleaned_combo_str,
                                    "Количество артикулов": len(filtered_df),
                                    "Общая выручка": total_revenue,
                                    "Выручка на 1 артикул": revenue_per_product,
                                    "Средняя цена без СПП": avg_price_without_spp,
                                    "Упущенная выручка": lost_revenue,
                                    "Упущенная выручка на 1 артикул": lost_revenue_per_product,
                                    "Позиция в выдаче (средняя)": avg_position,
                                    "Стоимость за 1000 показов на 1 артикул": cpm_per_product
                                })
                        
                        # Пересчитываем рейтинг для перегруппированных комбинаций
                        if regrouped_analytics:
                            all_revenues = [c["Выручка на 1 артикул"] for c in regrouped_analytics]
                            all_prices = [c["Средняя цена без СПП"] for c in regrouped_analytics]
                            all_lost = [c["Упущенная выручка на 1 артикул"] for c in regrouped_analytics]
                            
                            def calculate_combination_score(combo):
                                revenue_per_sku = combo["Выручка на 1 артикул"]
                                avg_price_without_spp = combo["Средняя цена без СПП"]
                                lost_revenue_per_sku = combo["Упущенная выручка на 1 артикул"]
                                
                                # Нормализуем выручку (0-1)
                                if max(all_revenues) > min(all_revenues):
                                    norm_revenue = (revenue_per_sku - min(all_revenues)) / (max(all_revenues) - min(all_revenues))
                                else:
                                    norm_revenue = 0.5
                                
                                # Нормализуем цену (0-1, где 1 = максимум, т.е. лучше)
                                if max(all_prices) > min(all_prices):
                                    norm_price = (avg_price_without_spp - min(all_prices)) / (max(all_prices) - min(all_prices))
                                else:
                                    norm_price = 0.5
                                
                                # Нормализуем упущенную выручку (0-1, где 1 = минимум, т.е. лучше)
                                if max(all_lost) > min(all_lost):
                                    norm_lost = 1 - (lost_revenue_per_sku - min(all_lost)) / (max(all_lost) - min(all_lost))
                                else:
                                    norm_lost = 0.5
                                
                                # Взвешенная сумма с приоритетами: Выручка на 1 артикул (90%) → Средняя цена (9%) → Упущенная выручка на 1 артикул (1%)
                                score = (norm_revenue * 0.9) + (norm_price * 0.09) + (norm_lost * 0.01)
                                return score
                            
                            for combo in regrouped_analytics:
                                combo["Рейтинг"] = calculate_combination_score(combo)
                            
                            regrouped_analytics.sort(key=lambda x: x["Рейтинг"], reverse=True)
                        
                        # Используем перегруппированные комбинации
                        filtered_combinations = regrouped_analytics
                        
                        # Разделяем комбинации на новинки и не-новинки, если выбран период для новинок
                        if novelty_months is not None:
                            filtered_novelty_combinations = [c for c in filtered_combinations if "Период появления:Новинка" in c["Комбинация"]]
                            filtered_regular_combinations = [c for c in filtered_combinations if "Период появления:Новинка" not in c["Комбинация"]]
                            
                            # Рассчитываем рейтинг отдельно для новинок
                            if filtered_novelty_combinations:
                                novelty_revenues = [c["Выручка на 1 артикул"] for c in filtered_novelty_combinations]
                                novelty_prices = [c["Средняя цена без СПП"] for c in filtered_novelty_combinations]
                                novelty_lost = [c["Упущенная выручка на 1 артикул"] for c in filtered_novelty_combinations]
                                
                                def calculate_novelty_score_regrouped(combo):
                                    revenue_per_sku = combo["Выручка на 1 артикул"]
                                    avg_price = combo["Средняя цена без СПП"]
                                    lost_revenue_per_sku = combo["Упущенная выручка на 1 артикул"]
                                    
                                    if max(novelty_revenues) > min(novelty_revenues):
                                        norm_revenue = (revenue_per_sku - min(novelty_revenues)) / (max(novelty_revenues) - min(novelty_revenues))
                                    else:
                                        norm_revenue = 0.5
                                    
                                    if max(novelty_prices) > min(novelty_prices):
                                        norm_price = (avg_price - min(novelty_prices)) / (max(novelty_prices) - min(novelty_prices))
                                    else:
                                        norm_price = 0.5
                                    
                                    if max(novelty_lost) > min(novelty_lost):
                                        norm_lost = 1 - (lost_revenue_per_sku - min(novelty_lost)) / (max(novelty_lost) - min(novelty_lost))
                                    else:
                                        norm_lost = 0.5
                                    
                                    score = (norm_revenue * 0.9) + (norm_price * 0.09) + (norm_lost * 0.01)
                                    return score
                                
                                for combo in filtered_novelty_combinations:
                                    combo["Рейтинг"] = calculate_novelty_score_regrouped(combo)
                                filtered_novelty_combinations.sort(key=lambda x: x["Рейтинг"], reverse=True)
                            
                            # Рассчитываем рейтинг отдельно для не-новинок
                            if filtered_regular_combinations:
                                regular_revenues = [c["Выручка на 1 артикул"] for c in filtered_regular_combinations]
                                regular_prices = [c["Средняя цена без СПП"] for c in filtered_regular_combinations]
                                regular_lost = [c["Упущенная выручка на 1 артикул"] for c in filtered_regular_combinations]
                                
                                def calculate_regular_score_regrouped(combo):
                                    revenue_per_sku = combo["Выручка на 1 артикул"]
                                    avg_price = combo["Средняя цена без СПП"]
                                    lost_revenue_per_sku = combo["Упущенная выручка на 1 артикул"]
                                    
                                    if max(regular_revenues) > min(regular_revenues):
                                        norm_revenue = (revenue_per_sku - min(regular_revenues)) / (max(regular_revenues) - min(regular_revenues))
                                    else:
                                        norm_revenue = 0.5
                                    
                                    if max(regular_prices) > min(regular_prices):
                                        norm_price = (avg_price - min(regular_prices)) / (max(regular_prices) - min(regular_prices))
                                    else:
                                        norm_price = 0.5
                                    
                                    if max(regular_lost) > min(regular_lost):
                                        norm_lost = 1 - (lost_revenue_per_sku - min(regular_lost)) / (max(regular_lost) - min(regular_lost))
                                    else:
                                        norm_lost = 0.5
                                    
                                    score = (norm_revenue * 0.9) + (norm_price * 0.09) + (norm_lost * 0.01)
                                    return score
                                
                                for combo in filtered_regular_combinations:
                                    combo["Рейтинг"] = calculate_regular_score_regrouped(combo)
                                filtered_regular_combinations.sort(key=lambda x: x["Рейтинг"], reverse=True)
                        else:
                            filtered_novelty_combinations = []
                            filtered_regular_combinations = filtered_combinations
                        
                        # Создаем словарь для быстрого доступа к артикулам по очищенной комбинации
                        cleaned_combo_to_skus = {}
                        for cleaned_combo_str, combo_data in regrouped_combinations.items():
                            cleaned_combo_to_skus[cleaned_combo_str] = list(set(combo_data["skus"]))
                        
                        # Показываем топ-10 отдельно для новинок и не-новинок
                        top_10_novelty_combinations = filtered_novelty_combinations[:10] if novelty_months is not None else []
                        top_10_regular_combinations = filtered_regular_combinations[:10]
                        
                        # Для обратной совместимости создаем объединенный список
                        top_10_combinations = top_10_novelty_combinations + top_10_regular_combinations
                        
                        # Сохраняем данные о комбинациях в session_state для использования в вкладке "План продаж"
                        st.session_state['top_10_novelty_combinations'] = top_10_novelty_combinations
                        st.session_state['top_10_regular_combinations'] = top_10_regular_combinations
                        st.session_state['top_10_combinations'] = top_10_combinations
                        st.session_state['cleaned_combo_to_skus'] = cleaned_combo_to_skus
                        st.session_state['all_combinations'] = all_combinations
                        st.session_state['novelty_months'] = novelty_months
                        
                        # Функция для форматирования данных комбинаций
                        def format_combinations_display(combinations_list, start_idx=1):
                            display_data = []
                            for idx, combo in enumerate(combinations_list, start_idx):
                                # Получаем количество товаров из комбинации
                                product_count = combo.get("Количество артикулов", 0)
                                
                                display_data.append({
                                    "Место": f"#{idx}",
                                    "Комбинация": combo["Комбинация"],
                                    "Количество товаров": f"{product_count} шт.",
                                    "Общая выручка": f"₽{combo['Общая выручка']:,.0f}".replace(",", " "),
                                    "Выручка на 1 артикул": f"₽{combo['Выручка на 1 артикул']:,.0f}".replace(",", " "),
                                    "Средняя цена без СПП": f"₽{combo['Средняя цена без СПП']:,.0f}".replace(",", " "),
                                    "Упущенная выручка": f"₽{combo['Упущенная выручка']:,.0f}".replace(",", " "),
                                    "Упущенная выручка на 1 артикул": f"₽{combo['Упущенная выручка на 1 артикул']:,.0f}".replace(",", " "),
                                    "Позиция в выдаче (средняя)": f"{combo['Позиция в выдаче (средняя)']:.1f}",
                                    "Стоимость за 1000 показов на 1 артикул": f"₽{combo['Стоимость за 1000 показов на 1 артикул']:,.0f}".replace(",", " "),
                                    "Рейтинг": f"{combo['Рейтинг']:.4f}"
                                })
                            return display_data
                        
                        # Показываем комбинации новинок отдельно, если они есть
                        if novelty_months is not None and top_10_novelty_combinations:
                            st.markdown("### 🆕 Топ-10 комбинаций новинок")
                            st.info(f"💡 Комбинации только для товаров, появившихся за последние {novelty_months} месяцев")
                            
                            display_data_novelty = format_combinations_display(top_10_novelty_combinations, 1)
                            top_10_novelty_df = pd.DataFrame(display_data_novelty)
                            st.dataframe(top_10_novelty_df, use_container_width=True, hide_index=True)
                            
                            if top_10_novelty_combinations:
                                best_novelty_combo = top_10_novelty_combinations[0]
                                st.success(f"🥇 **Лучшая комбинация новинок**: {best_novelty_combo['Комбинация']}")
                                st.markdown(f"**Рейтинг:** {best_novelty_combo['Рейтинг']:.4f} | **Выручка на 1 артикул:** ₽{best_novelty_combo['Выручка на 1 артикул']:,.0f}".replace(",", " "))
                            
                            st.divider()
                        
                        # Показываем комбинации не-новинок отдельно
                        if top_10_regular_combinations:
                            if novelty_months is not None:
                                st.markdown("### 📦 Топ-10 комбинаций остальных товаров")
                                st.info("💡 Комбинации для товаров, которые не являются новинками")
                            else:
                                st.markdown("### 🏆 Топ-10 лучших комбинаций параметров")
                            
                            display_data_regular = format_combinations_display(top_10_regular_combinations, 1)
                            top_10_regular_df = pd.DataFrame(display_data_regular)
                            st.dataframe(top_10_regular_df, use_container_width=True, hide_index=True)
                            
                            if top_10_regular_combinations:
                                best_regular_combo = top_10_regular_combinations[0]
                                st.success(f"🥇 **Лучшая комбинация**: {best_regular_combo['Комбинация']}")
                                st.markdown(f"**Рейтинг:** {best_regular_combo['Рейтинг']:.4f} | **Выручка на 1 артикул:** ₽{best_regular_combo['Выручка на 1 артикул']:,.0f}".replace(",", " "))
                        else:
                            # Если комбинации не сформировались, показываем сообщение
                            if novelty_months is not None:
                                st.warning("⚠️ Не найдено комбинаций для остальных товаров. Возможно, все товары являются новинками или все комбинации были исключены.")
                            else:
                                st.warning("⚠️ Не найдено комбинаций параметров. Возможные причины:")
                                st.write("  • Нет товаров с заполненными параметрами")
                                st.write("  • Все комбинации были исключены через фильтры")
                                st.write("  • Все параметры были скрыты или исключены")
                                
                                # Показываем отладочную информацию
                                with st.expander("🔍 Отладочная информация", expanded=False):
                                    st.write(f"**all_combinations:** {len(all_combinations)} комбинаций")
                                    st.write(f"**combination_analytics:** {len(combination_analytics)} комбинаций")
                                    st.write(f"**regrouped_analytics:** {len(regrouped_analytics) if 'regrouped_analytics' in locals() else 'не определено'}")
                                    st.write(f"**filtered_regular_combinations:** {len(filtered_regular_combinations) if 'filtered_regular_combinations' in locals() else 'не определено'}")
                                    st.write(f"**excluded_params:** {list(excluded_params)}")
                                    st.write(f"**active_params:** {len(active_params)} параметров")
                        
                        # Добавляем возможность просмотра товаров для каждой комбинации
                        if top_10_combinations:
                            st.divider()
                            st.subheader("📦 Детали комбинации")
                            
                            # Формируем список всех комбинаций для выбора (новинки + остальные)
                            combo_options = []
                            if novelty_months is not None and top_10_novelty_combinations:
                                for idx, combo in enumerate(top_10_novelty_combinations, 1):
                                    combo_options.append(f"🆕 #{idx} (Новинка) - {combo['Комбинация']}")
                            
                            if top_10_regular_combinations:
                                for idx, combo in enumerate(top_10_regular_combinations, 1):
                                    prefix = "📦" if novelty_months is not None else ""
                                    combo_options.append(f"{prefix} #{idx} - {combo['Комбинация']}")
                            selected_combo_idx = st.selectbox(
                                "Выберите комбинацию для просмотра товаров:",
                                options=combo_options,
                                help="Выберите комбинацию из топ-10, чтобы увидеть все товары с такими параметрами"
                            )
                            
                            if selected_combo_idx:
                                # Определяем, из какого списка выбрана комбинация
                                is_novelty_selection = "🆕" in selected_combo_idx or "(Новинка)" in selected_combo_idx
                                
                                # Извлекаем индекс выбранной комбинации
                                idx_part = selected_combo_idx.split(" - ")[0].replace("#", "").replace("🆕", "").replace("📦", "").replace("(Новинка)", "").strip()
                                selected_idx = int(idx_part) - 1
                                
                                # Выбираем комбинацию из соответствующего списка
                                if is_novelty_selection and novelty_months is not None and top_10_novelty_combinations:
                                    if selected_idx < len(top_10_novelty_combinations):
                                        selected_combo = top_10_novelty_combinations[selected_idx]
                                    else:
                                        selected_combo = None
                                else:
                                    if selected_idx < len(top_10_regular_combinations):
                                        selected_combo = top_10_regular_combinations[selected_idx]
                                    else:
                                        selected_combo = None
                                
                                if selected_combo:
                                    selected_combo_key = selected_combo["Комбинация"]
                                else:
                                    selected_combo_key = None
                                
                                if not selected_combo_key:
                                    st.warning("⚠️ Комбинация не найдена")
                                else:
                                    # Функция для удаления параметра "Период появления" из комбинации
                                    def remove_novelty_param(combo_str):
                                        """Удаляет параметр 'Период появления' из строки комбинации"""
                                        if not combo_str:
                                            return combo_str
                                        parts = [p.strip() for p in combo_str.split("|")]
                                        filtered_parts = [p for p in parts if not p.startswith("Период появления:")]
                                        return " | ".join(sorted(filtered_parts))
                                    
                                    # Удаляем параметр "Период появления" из ключа для поиска в cleaned_combo_to_skus
                                    # (так как в regrouped_combinations ключ может быть без этого параметра)
                                    cleaned_selected_key = remove_novelty_param(selected_combo_key)
                                    
                                    # Парсим выбранную комбинацию на параметры (без параметра "Период появления")
                                    selected_parts = set([p.strip() for p in cleaned_selected_key.split("|") if p.strip()])
                                    
                                    # Находим артикулы для этой комбинации
                                    # Используем перегруппированные комбинации (они уже содержат очищенные комбинации)
                                    combo_skus = None
                                    
                                    # Сначала ищем по очищенному ключу в cleaned_combo_to_skus
                                    if cleaned_selected_key in cleaned_combo_to_skus:
                                        combo_skus = cleaned_combo_to_skus[cleaned_selected_key]
                                    # Если не найдено, пробуем найти по полному ключу
                                    elif selected_combo_key in cleaned_combo_to_skus:
                                        combo_skus = cleaned_combo_to_skus[selected_combo_key]
                                    # Если не найдено, ищем в cleaned_combo_to_skus по совпадению параметров (без учета "Период появления")
                                    else:
                                        for cleaned_key, skus in cleaned_combo_to_skus.items():
                                            # Удаляем параметр "Период появления" из ключа для сравнения
                                            cleaned_key_no_novelty = remove_novelty_param(cleaned_key)
                                            cleaned_key_parts = set([p.strip() for p in cleaned_key_no_novelty.split("|") if p.strip()])
                                            
                                            # Сравниваем параметры (без учета "Период появления")
                                            if selected_parts == cleaned_key_parts:
                                                combo_skus = skus
                                                break
                                    
                                    # Если не найдено, ищем в оригинальных комбинациях
                                    if combo_skus is None:
                                        if selected_combo_key in all_combinations:
                                            combo_skus = all_combinations[selected_combo_key]
                                        # Если это комбинация новинок и артикулы все еще не найдены, ищем в оригинальных комбинациях с параметром "Период появления"
                                        elif is_novelty_selection and novelty_months is not None:
                                            # Ищем оригинальные комбинации новинок, которые могут соответствовать выбранной комбинации
                                            for orig_combo_key, orig_skus in all_combinations.items():
                                                # Проверяем, содержит ли оригинальная комбинация параметр новинок
                                                if "Период появления:Новинка" in orig_combo_key:
                                                    # Удаляем параметр "Период появления" из оригинальной комбинации для сравнения
                                                    orig_cleaned = remove_novelty_param(orig_combo_key)
                                                    orig_parts = set([p.strip() for p in orig_cleaned.split("|") if p.strip()])
                                                    
                                                    # Сравниваем: все параметры из selected_combo_key должны быть в orig_parts
                                                    # (orig_parts может содержать дополнительные параметры, которые были исключены)
                                                    if selected_parts.issubset(orig_parts) or selected_parts == orig_parts:
                                                        combo_skus = orig_skus
                                                        break
                                    
                                    # Если артикулы все еще не найдены, показываем предупреждение
                                    if not combo_skus:
                                        st.warning(f"⚠️ Не удалось найти товары для комбинации: {selected_combo_key}")
                                    
                                    # Фильтруем данные по артикулам
                                    if combo_skus:
                                        mask = df["Артикул"].astype(str).str.replace(".0", "").isin(combo_skus)
                                        combo_products_df = df[mask].copy()
                                        
                                        # Если это комбинация новинок, дополнительно фильтруем по дате создания
                                        # Используем флаг is_novelty_selection вместо проверки ключа
                                        is_novelty_combo = is_novelty_selection and novelty_months is not None
                                        if is_novelty_combo and "Дата создания" in combo_products_df.columns and report_end_date is not None:
                                            if isinstance(report_end_date, pd.Timestamp):
                                                start_date_for_novelties = report_end_date - pd.DateOffset(months=novelty_months)
                                            else:
                                                start_date_for_novelties = pd.to_datetime(report_end_date) - pd.DateOffset(months=novelty_months)
                                            
                                            # Фильтруем только товары с датой создания в периоде новинок
                                            novelty_date_mask = (
                                                (combo_products_df["Дата создания"] >= start_date_for_novelties) & 
                                                (combo_products_df["Дата создания"] <= report_end_date) &
                                                (combo_products_df["Дата создания"].notna())
                                            )
                                            combo_products_df = combo_products_df[novelty_date_mask].copy()
                                        
                                        if not combo_products_df.empty:
                                            st.markdown(f"**Комбинация:** {selected_combo_key}")
                                            st.markdown(f"**Количество товаров:** {len(combo_products_df)}")
                                            
                                            # Получаем конец периода анализа
                                            report_end_date_local = report_end_date
                                            if report_end_date_local is None:
                                                df_raw = st.session_state.get("df_raw")
                                                header_row = st.session_state.get("header_row")
                                                if df_raw is not None and header_row is not None:
                                                    period_info = get_analysis_period(df, df_raw, header_row, error_callback=st.error)
                                                    if period_info and "end_date" in period_info:
                                                        report_end_date_local = period_info["end_date"]
                                                if report_end_date_local is None:
                                                    report_end_date_local = pd.Timestamp.now()
                                            
                                            # Преобразуем в Timestamp если нужно
                                            if not isinstance(report_end_date_local, pd.Timestamp):
                                                report_end_date_local = pd.to_datetime(report_end_date_local)
                                            
                                            # Показываем основные метрики
                                            col1, col2, col3, col4 = st.columns(4)
                                            with col1:
                                                total_rev = combo_products_df["Выручка"].sum() if "Выручка" in combo_products_df.columns else 0
                                                st.metric("Общая выручка", f"₽{total_rev:,.0f}".replace(",", " "))
                                            with col2:
                                                avg_rev = total_rev / len(combo_products_df) if len(combo_products_df) > 0 else 0
                                                st.metric("Выручка на 1 артикул", f"₽{avg_rev:,.0f}".replace(",", " "))
                                            with col3:
                                                avg_price = combo_products_df["Средняя цена"].mean() if "Средняя цена" in combo_products_df.columns else 0
                                                st.metric("Средняя цена", f"₽{avg_price:,.0f}".replace(",", " "))
                                            with col4:
                                                # Средняя заказов в месяц на 1 артикул (с учетом возраста каждого товара)
                                                orders_per_month_list = []
                                                if "Заказы" in combo_products_df.columns and "Дата создания" in combo_products_df.columns:
                                                    for _, row in combo_products_df.iterrows():
                                                        orders = row.get("Заказы", 0)
                                                        if pd.notna(orders) and orders > 0:
                                                            creation_date = row.get("Дата создания")
                                                            if pd.notna(creation_date):
                                                                # Преобразуем дату создания в Timestamp
                                                                if not isinstance(creation_date, pd.Timestamp):
                                                                    creation_date = pd.to_datetime(creation_date, errors='coerce')
                                                                
                                                                if pd.notna(creation_date):
                                                                    # Рассчитываем количество месяцев от даты создания до конца периода
                                                                    months_diff = (report_end_date_local - creation_date).days / 30.0
                                                                    # Минимум 1 месяц, чтобы избежать деления на ноль
                                                                    months_diff = max(months_diff, 1.0)
                                                                    
                                                                    # Заказы в месяц для этого товара
                                                                    orders_per_month = orders / months_diff
                                                                    orders_per_month_list.append(orders_per_month)
                                                
                                                if orders_per_month_list:
                                                    avg_orders_per_month = sum(orders_per_month_list) / len(orders_per_month_list)
                                                else:
                                                    # Fallback: если нет дат создания, используем старый метод
                                                    total_orders = combo_products_df["Заказы"].sum() if "Заказы" in combo_products_df.columns else 0
                                                    avg_orders_per_month = total_orders / len(combo_products_df) if len(combo_products_df) > 0 else 0
                                                
                                                st.metric("Средняя заказов в месяц на 1 артикул", f"{avg_orders_per_month:.1f}")
                                            
                                            # Дополнительные метрики
                                            col5, col6, col7, col8 = st.columns(4)
                                            with col5:
                                                total_lost_rev = combo_products_df["Упущенная выручка"].sum() if "Упущенная выручка" in combo_products_df.columns else 0
                                                st.metric("Упущенная выручка", f"₽{total_lost_rev:,.0f}".replace(",", " "))
                                            with col6:
                                                avg_lost_rev = total_lost_rev / len(combo_products_df) if len(combo_products_df) > 0 else 0
                                                st.metric("Упущенная выручка на артикул", f"₽{avg_lost_rev:,.0f}".replace(",", " "))
                                            with col7:
                                                # Среднее продаж в месяц на 1 артикул (с учетом возраста каждого товара)
                                                sales_per_month_list = []
                                                if "Дата создания" in combo_products_df.columns:
                                                    # Получаем процент выкупа
                                                    buyout_pct = st.session_state.get("buyout_pct", 25)
                                                    buyout_k = float(buyout_pct) / 100.0 if buyout_pct else 0.25
                                                    
                                                    for _, row in combo_products_df.iterrows():
                                                        creation_date = row.get("Дата создания")
                                                        if pd.notna(creation_date):
                                                            # Преобразуем дату создания в Timestamp
                                                            if not isinstance(creation_date, pd.Timestamp):
                                                                creation_date = pd.to_datetime(creation_date, errors='coerce')
                                                            
                                                            if pd.notna(creation_date):
                                                                # Рассчитываем количество месяцев от даты создания до конца периода
                                                                months_diff = (report_end_date_local - creation_date).days / 30.0
                                                                # Минимум 1 месяц, чтобы избежать деления на ноль
                                                                months_diff = max(months_diff, 1.0)
                                                                
                                                                # Получаем продажи (выкупы) для этого товара
                                                                if "Выкупы" in combo_products_df.columns:
                                                                    buyouts = row.get("Выкупы", 0)
                                                                    if pd.notna(buyouts):
                                                                        sales = buyouts
                                                                    else:
                                                                        # Если нет выкупов, рассчитываем через заказы и процент выкупа
                                                                        orders = row.get("Заказы", 0) if "Заказы" in combo_products_df.columns else 0
                                                                        sales = orders * buyout_k if pd.notna(orders) else 0
                                                                else:
                                                                    # Если нет колонки "Выкупы", рассчитываем через заказы и процент выкупа
                                                                    orders = row.get("Заказы", 0) if "Заказы" in combo_products_df.columns else 0
                                                                    sales = orders * buyout_k if pd.notna(orders) else 0
                                                                
                                                                if sales > 0:
                                                                    # Продажи в месяц для этого товара
                                                                    sales_per_month = sales / months_diff
                                                                    sales_per_month_list.append(sales_per_month)
                                                
                                                if sales_per_month_list:
                                                    avg_sales_per_month = sum(sales_per_month_list) / len(sales_per_month_list)
                                                else:
                                                    # Fallback: если нет дат создания, используем старый метод
                                                    if "Выкупы" in combo_products_df.columns:
                                                        total_buyouts = combo_products_df["Выкупы"].sum()
                                                        avg_sales_per_month = total_buyouts / len(combo_products_df) if len(combo_products_df) > 0 else 0
                                                    else:
                                                        buyout_pct = st.session_state.get("buyout_pct", 25)
                                                        buyout_k = float(buyout_pct) / 100.0 if buyout_pct else 0.25
                                                        total_orders_for_sales = combo_products_df["Заказы"].sum() if "Заказы" in combo_products_df.columns else 0
                                                        total_buyouts = total_orders_for_sales * buyout_k
                                                        avg_sales_per_month = total_buyouts / len(combo_products_df) if len(combo_products_df) > 0 else 0
                                                
                                                st.metric("Среднее продаж в месяц на 1 артикул", f"{avg_sales_per_month:.1f}")
                                            with col8:
                                                # Оборачиваемость на единицу товара (на артикул): средняя оборачиваемость одного артикула
                                                total_orders_turnover = combo_products_df["Заказы"].sum() if "Заказы" in combo_products_df.columns else 0
                                                
                                                # Проверяем наличие данных об остатках
                                                has_stock = False
                                                avg_stock = 0
                                                if "Остаток" in combo_products_df.columns:
                                                    avg_stock = combo_products_df["Остаток"].mean()
                                                    has_stock = True
                                                elif "Stock" in combo_products_df.columns:
                                                    avg_stock = combo_products_df["Stock"].mean()
                                                    has_stock = True
                                                
                                                # Рассчитываем оборачиваемость на артикул
                                                if has_stock and avg_stock > 0:
                                                    # Если есть остатки: оборачиваемость на артикул = (Заказы артикула за 30 дней) / Остаток артикула
                                                    # Средняя оборачиваемость = среднее значение оборачиваемости всех артикулов
                                                    turnover_per_sku_list = []
                                                    for _, row in combo_products_df.iterrows():
                                                        sku_orders = row.get("Заказы", 0) if pd.notna(row.get("Заказы", 0)) else 0
                                                        sku_stock = row.get("Остаток", 0) if "Остаток" in combo_products_df.columns and pd.notna(row.get("Остаток", 0)) else row.get("Stock", 0) if "Stock" in combo_products_df.columns and pd.notna(row.get("Stock", 0)) else 0
                                                        if sku_stock > 0:
                                                            # Оборачиваемость на артикул = заказы за 30 дней / остаток
                                                            turnover_per_sku = sku_orders / sku_stock
                                                            turnover_per_sku_list.append(turnover_per_sku)
                                                    
                                                    if turnover_per_sku_list:
                                                        avg_turnover_per_sku = sum(turnover_per_sku_list) / len(turnover_per_sku_list)
                                                    else:
                                                        avg_turnover_per_sku = 0
                                                else:
                                                    # Если нет остатков: оборачиваемость на артикул = средние заказы на артикул
                                                    avg_turnover_per_sku = total_orders_turnover / len(combo_products_df) if len(combo_products_df) > 0 else 0
                                                
                                                turnover_per_sku_display = f"{avg_turnover_per_sku:.2f}" if avg_turnover_per_sku > 0 else "N/A"
                                                st.metric("Оборачиваемость на артикул", turnover_per_sku_display)
                                            
                                            # Показываем таблицу товаров
                                            st.markdown("**Список товаров:**")
                                            
                                            # Создаем копию DataFrame для работы
                                            display_combo_df = combo_products_df.copy()
                                            
                                            # Добавляем изображения
                                            import base64
                                            imgs = []
                                            img_size = 150
                                            for sku in display_combo_df["Артикул"].astype(str):
                                                sku_clean = sku.replace(".0", "")
                                                path = get_cached_image_path(sku_clean)
                                                if path and os.path.exists(path):
                                                    img_bytes = load_image_bytes(path, img_size)
                                                    if img_bytes:
                                                        b64_data = base64.b64encode(img_bytes).decode()
                                                        data_uri = f"data:image/jpeg;base64,{b64_data}"
                                                        imgs.append(data_uri)
                                                    else:
                                                        imgs.append("")
                                                else:
                                                    imgs.append("")
                                            
                                            display_combo_df.insert(1, "Изображение", imgs)
                                            
                                            # Добавляем ссылки на Wildberries
                                            if "Артикул" in display_combo_df.columns:
                                                display_combo_df["Ссылка"] = display_combo_df["Артикул"].astype(str).str.replace(".0", "").apply(
                                                    lambda sku: f"https://www.wildberries.ru/catalog/{sku}/detail.aspx"
                                                )
                                            
                                            # Добавляем параметры в таблицу
                                            for param_name in available_params:
                                                if param_name in param_values:
                                                    display_combo_df[param_name] = display_combo_df["Артикул"].astype(str).str.replace(".0", "").apply(
                                                        lambda sku: param_values[param_name].get(str(sku), "")
                                                    )
                                            
                                            # Форматируем дату создания, если она есть
                                            if "Дата создания" in display_combo_df.columns:
                                                display_combo_df["Дата создания"] = pd.to_datetime(display_combo_df["Дата создания"], errors="coerce")
                                                # Форматируем дату для отображения
                                                display_combo_df["Дата создания"] = display_combo_df["Дата создания"].dt.strftime("%d.%m.%Y")
                                            
                                            # Настраиваем порядок колонок (как в основной таблице)
                                            main_cols = ["Артикул", "Изображение", "Ссылка"]
                                            if "Дата создания" in display_combo_df.columns:
                                                main_cols.append("Дата создания")
                                            if "Выручка" in display_combo_df.columns:
                                                main_cols.append("Выручка")
                                            if "Заказы" in display_combo_df.columns:
                                                main_cols.append("Заказы")
                                            if "Средняя цена" in display_combo_df.columns:
                                                main_cols.append("Средняя цена")
                                            if "Цена (с СПП)" in display_combo_df.columns:
                                                main_cols.append("Цена (с СПП)")
                                            if "Позиция в выдаче" in display_combo_df.columns:
                                                main_cols.append("Позиция в выдаче")
                                            if "Упущенная выручка" in display_combo_df.columns:
                                                main_cols.append("Упущенная выручка")
                                            if "Прибыль" in display_combo_df.columns:
                                                main_cols.append("Прибыль")
                                            if "Стоимость за 1000 показов" in display_combo_df.columns:
                                                main_cols.append("Стоимость за 1000 показов")
                                            
                                            # Добавляем параметры
                                            param_cols = [p for p in available_params if p in display_combo_df.columns]
                                            
                                            # Остальные колонки
                                            other_cols = [c for c in display_combo_df.columns if c not in main_cols and c not in param_cols]
                                            
                                            # Формируем финальный порядок
                                            final_order = [c for c in main_cols + param_cols + other_cols if c in display_combo_df.columns]
                                            display_combo_df = display_combo_df[final_order]
                                            
                                            # Настройка конфигурации столбцов
                                            from streamlit import column_config as cc
                                            col_cfg = {}
                                            
                                            # Конфигурация для изображений
                                            if "Изображение" in display_combo_df.columns:
                                                col_cfg["Изображение"] = cc.ImageColumn("Изображение", width=img_size + 20)
                                            
                                            # Конфигурация для артикула
                                            if "Артикул" in display_combo_df.columns:
                                                col_cfg["Артикул"] = cc.NumberColumn("Артикул", format="%.0f", width=120)
                                            
                                            # Конфигурация для ссылки
                                            if "Ссылка" in display_combo_df.columns:
                                                col_cfg["Ссылка"] = cc.LinkColumn("Ссылка", display_text="🔗", width=60)
                                            
                                            # Конфигурация для числовых столбцов
                                            money_columns = ["Выручка", "Средняя цена", "Цена (с СПП)", "Упущенная выручка", "Прибыль", "Стоимость за 1000 показов"]
                                            for col in money_columns:
                                                if col in display_combo_df.columns:
                                                    col_cfg[col] = cc.NumberColumn(col, format="%.0f", width=120)
                                            
                                            # Конфигурация для позиции
                                            if "Позиция в выдаче" in display_combo_df.columns:
                                                col_cfg["Позиция в выдаче"] = cc.NumberColumn("Позиция в выдаче", format="%.1f", width=100)
                                            
                                            # Конфигурация для параметров
                                            for param_name in param_cols:
                                                if param_name in display_combo_df.columns:
                                                    col_cfg[param_name] = cc.TextColumn(param_name, width=150)
                                            
                                            # Отображаем таблицу
                                            st.dataframe(
                                                display_combo_df,
                                                use_container_width=True,
                                                hide_index=True,
                                                column_config=col_cfg
                                            )
                                            
                                            # Кнопка для анализа товаров в комбинации
                                            st.divider()
                                            st.markdown("### 🤖 ИИ-анализ комбинации")
                                            
                                            if st.button("🔍 Проанализировать товары с помощью ИИ", type="primary", use_container_width=True):
                                                with st.spinner("🔄 Анализирую товары с помощью ИИ... Это может занять некоторое время."):
                                                    # Определяем категорию (можно сделать настраиваемой)
                                                    category = "Рашрашд мужской (компрессионная одежда)"
                                                    
                                                    # Анализируем товары в комбинации
                                                    analysis_result = analyze_combination_products_with_ai(
                                                        combo_products_df, 
                                                        selected_combo_key,
                                                        category=category
                                                    )
                                                    
                                                    if "error" in analysis_result:
                                                        st.error(f"❌ {analysis_result['error']}")
                                                        if "raw_response" in analysis_result:
                                                            with st.expander("📄 Полный ответ ИИ"):
                                                                st.text(analysis_result["raw_response"])
                                                    else:
                                                        # Отображаем результаты анализа
                                                        st.success("✅ Анализ завершен!")
                                                        
                                                        # Общие характеристики
                                                        if "common_characteristics" in analysis_result:
                                                            st.markdown("#### 📊 Общие характеристики")
                                                            st.info(analysis_result["common_characteristics"])
                                                        
                                                        # Сильные стороны
                                                        if "strengths" in analysis_result and analysis_result["strengths"]:
                                                            st.markdown("#### ✅ Сильные стороны")
                                                            for strength in analysis_result["strengths"]:
                                                                st.markdown(f"- {strength}")
                                                        
                                                        # Слабые стороны
                                                        if "weaknesses" in analysis_result and analysis_result["weaknesses"]:
                                                            st.markdown("#### ⚠️ Слабые стороны")
                                                            for weakness in analysis_result["weaknesses"]:
                                                                st.markdown(f"- {weakness}")
                                                        
                                                        # Рекомендации
                                                        if "recommendations" in analysis_result and analysis_result["recommendations"]:
                                                            st.markdown("#### 💡 Рекомендации по улучшению")
                                                            for rec in analysis_result["recommendations"]:
                                                                priority_emoji = "🔴" if rec.get("priority") == "high" else "🟡" if rec.get("priority") == "medium" else "🟢"
                                                                st.markdown(f"**{priority_emoji} {rec.get('category', 'Общее')}**")
                                                                st.markdown(f"- {rec.get('recommendation', '')}")
                                                                if rec.get('expected_impact'):
                                                                    st.caption(f"💭 Ожидаемый эффект: {rec['expected_impact']}")
                                                        
                                                        # Конкурентные преимущества
                                                        if "competitive_advantages" in analysis_result and analysis_result["competitive_advantages"]:
                                                            st.markdown("#### 🏆 Потенциальные конкурентные преимущества")
                                                            for advantage in analysis_result["competitive_advantages"]:
                                                                st.markdown(f"- {advantage}")
                                                        
                                                        # Рыночные инсайты
                                                        if "market_insights" in analysis_result:
                                                            st.markdown("#### 📈 Рыночные инсайты")
                                                            st.info(analysis_result["market_insights"])
                                                        
                                                        # Анализ категории и CAGR
                                                        st.divider()
                                                        st.markdown("### 📊 Анализ категории и CAGR")
                                                        
                                                        cagr_data = get_category_cagr_analysis(category)
                                                        
                                                        col1, col2, col3 = st.columns(3)
                                                        with col1:
                                                            st.metric("CAGR (5 лет)", f"{cagr_data.get('cagr_5_years', 0):.1f}%")
                                                        with col2:
                                                            st.metric("Прогноз роста 2025", f"{cagr_data.get('projected_growth_2025', 0):.1f}%")
                                                        with col3:
                                                            st.metric("Размер рынка 2024", cagr_data.get('market_size_2024', 'N/A'))
                                                        
                                                        st.markdown("#### 🚀 Ключевые драйверы роста")
                                                        for driver in cagr_data.get('key_drivers', []):
                                                            st.markdown(f"- {driver}")
                                                        
                                                        st.markdown("#### 📈 Тренды рынка")
                                                        for trend in cagr_data.get('trends', []):
                                                            st.markdown(f"- {trend}")
                                                        
                                                        st.markdown(f"**Уровень конкуренции:** {cagr_data.get('competition_level', 'N/A')}")
                                                        st.markdown(f"**Зрелость рынка:** {cagr_data.get('market_maturity', 'N/A')}")
                                                        
                                                        # Анализ WGSN
                                                        st.divider()
                                                        st.markdown("### 📚 Анализ трендов WGSN")
                                                        
                                                        with st.spinner("🔄 Анализирую файлы WGSN... Это может занять некоторое время."):
                                                            # Читаем файлы WGSN
                                                            wgsn_content = read_wgsn_files()
                                                            
                                                            if "error" in wgsn_content:
                                                                st.warning(f"⚠️ {wgsn_content['error']}")
                                                            else:
                                                                # Анализируем тренды WGSN с помощью ИИ
                                                                wgsn_analysis = analyze_wgsn_trends_with_ai(
                                                                    wgsn_content,
                                                                    category=category,
                                                                    combination_key=selected_combo_key
                                                                )
                                                                
                                                                if "error" in wgsn_analysis:
                                                                    st.error(f"❌ {wgsn_analysis['error']}")
                                                                    if "raw_response" in wgsn_analysis:
                                                                        with st.expander("📄 Полный ответ ИИ по WGSN"):
                                                                            st.text(wgsn_analysis["raw_response"])
                                                                else:
                                                                    st.success("✅ Анализ WGSN завершен!")
                                                                    
                                                                    # Резюме трендов WGSN
                                                                    if "wgsn_trends_summary" in wgsn_analysis:
                                                                        st.markdown("#### 📋 Резюме трендов WGSN")
                                                                        st.markdown(wgsn_analysis["wgsn_trends_summary"])
                                                                    
                                                                    # Анализ категории
                                                                    if "category_analysis" in wgsn_analysis:
                                                                        st.markdown("#### 📊 Анализ категории на основе WGSN")
                                                                        cat_analysis = wgsn_analysis["category_analysis"]
                                                                        
                                                                        col1, col2 = st.columns(2)
                                                                        with col1:
                                                                            if "current_trends" in cat_analysis:
                                                                                st.markdown("**✅ Актуальные тренды:**")
                                                                                st.info(cat_analysis["current_trends"])
                                                                        
                                                                        with col2:
                                                                            if "emerging_trends" in cat_analysis:
                                                                                st.markdown("**🔮 Появляющиеся тренды:**")
                                                                                st.success(cat_analysis["emerging_trends"])
                                                                        
                                                                        if "declining_trends" in cat_analysis:
                                                                            st.markdown("**⚠️ Устаревающие тренды:**")
                                                                            st.warning(cat_analysis["declining_trends"])
                                                                    
                                                                    # Детальный анализ параметров комбинации
                                                                    if "combination_parameter_analysis" in wgsn_analysis and wgsn_analysis["combination_parameter_analysis"]:
                                                                        st.markdown("#### 🔍 Детальный анализ параметров комбинации")
                                                                        for param_analysis in wgsn_analysis["combination_parameter_analysis"]:
                                                                            status_emoji = "✅" if param_analysis.get("wgsn_trend_status") == "Соответствует" else "⚠️" if param_analysis.get("wgsn_trend_status") == "Частично соответствует" else "❌"
                                                                            
                                                                            with st.expander(f"{status_emoji} **{param_analysis.get('parameter', 'Параметр')}** = {param_analysis.get('current_value', 'N/A')}"):
                                                                                st.markdown(f"**Статус по трендам WGSN:** {param_analysis.get('wgsn_trend_status', 'N/A')}")
                                                                                
                                                                                if param_analysis.get('wgsn_recommendation'):
                                                                                    st.markdown("**💡 Рекомендация WGSN:**")
                                                                                    st.info(param_analysis['wgsn_recommendation'])
                                                                                
                                                                                if param_analysis.get('suggested_values'):
                                                                                    st.markdown("**📌 Рекомендуемые значения:**")
                                                                                    for value in param_analysis['suggested_values']:
                                                                                        st.markdown(f"- {value}")
                                                                                
                                                                                if param_analysis.get('rationale'):
                                                                                    st.markdown("**📝 Обоснование:**")
                                                                                    st.markdown(param_analysis['rationale'])
                                                                    
                                                                    # Релевантные тренды
                                                                    if "relevant_trends" in wgsn_analysis and wgsn_analysis["relevant_trends"]:
                                                                        st.markdown("#### 🎯 Релевантные тренды из WGSN")
                                                                        for trend in wgsn_analysis["relevant_trends"]:
                                                                            trend_type_emoji = {
                                                                "Цвет": "🎨",
                                                                "Материал": "🧵",
                                                                "Дизайн": "✂️",
                                                                "Технология": "⚙️",
                                                                "Стиль": "👔",
                                                                "Функциональность": "⚡"
                                                            }.get(trend.get('trend_type', ''), "📌")
                                                                            
                                                                            with st.expander(f"{trend_type_emoji} **{trend.get('trend_name', 'Тренд')}** ({trend.get('trend_type', 'Общее')}) - из {trend.get('source_file', 'WGSN')}"):
                                                                                st.markdown("**📄 Описание:**")
                                                                                st.markdown(trend.get('description', ''))
                                                                                
                                                                                st.markdown("**🎯 Релевантность для категории:**")
                                                                                st.info(trend.get('relevance_to_category', ''))
                                                                                
                                                                                st.markdown("**🔗 Применение к комбинации:**")
                                                                                st.markdown(trend.get('application_to_combination', ''))
                                                                                
                                                                                if trend.get('implementation_steps'):
                                                                                    st.markdown("**📋 Шаги внедрения:**")
                                                                                    for i, step in enumerate(trend.get('implementation_steps', []), 1):
                                                                                        st.markdown(f"{i}. {step}")
                                                                                
                                                                                if trend.get('expected_market_impact'):
                                                                                    st.markdown("**💼 Ожидаемое влияние на рынок:**")
                                                                                    st.success(trend.get('expected_market_impact', ''))
                                                                    
                                                                    # Рекомендации на основе трендов WGSN
                                                                    if "trend_recommendations" in wgsn_analysis and wgsn_analysis["trend_recommendations"]:
                                                                        st.markdown("#### 💡 Детальные рекомендации на основе трендов WGSN")
                                                                        for rec in wgsn_analysis["trend_recommendations"]:
                                                                            priority_emoji = "🔴" if rec.get("priority") == "high" else "🟡" if rec.get("priority") == "medium" else "🟢"
                                                                            
                                                                            with st.expander(f"{priority_emoji} **{rec.get('trend_category', 'Общее')}** - {rec.get('timeline', 'Срок не указан')}"):
                                                                                st.markdown("**💡 Рекомендация:**")
                                                                                st.markdown(rec.get('recommendation', ''))
                                                                                
                                                                                if rec.get('specific_changes'):
                                                                                    st.markdown("**🔄 Конкретные изменения:**")
                                                                                    st.info(rec.get('specific_changes', ''))
                                                                                
                                                                                if rec.get('expected_impact'):
                                                                                    st.markdown("**💭 Ожидаемый эффект:**")
                                                                                    st.success(rec.get('expected_impact', ''))
                                                                                
                                                                                if rec.get('wgsn_source'):
                                                                                    st.markdown("**📚 Источник WGSN:**")
                                                                                    st.caption(rec.get('wgsn_source', ''))
                                                                    
                                                                    # Предложения новых комбинаций
                                                                    if "new_combination_suggestions" in wgsn_analysis and wgsn_analysis["new_combination_suggestions"]:
                                                                        st.markdown("#### 🆕 Предложения новых комбинаций на основе WGSN")
                                                                        for new_combo in wgsn_analysis["new_combination_suggestions"]:
                                                                            with st.expander(f"**{new_combo.get('combination', 'Новая комбинация')}**"):
                                                                                st.markdown("**📝 Обоснование:**")
                                                                                st.info(new_combo.get('rationale', ''))
                                                                                
                                                                                if new_combo.get('wgsn_trends_used'):
                                                                                    st.markdown("**🎯 Использованные тренды WGSN:**")
                                                                                    for trend in new_combo.get('wgsn_trends_used', []):
                                                                                        st.markdown(f"- {trend}")
                                                                                
                                                                                if new_combo.get('competitive_advantage'):
                                                                                    st.markdown("**🏆 Конкурентное преимущество:**")
                                                                                    st.success(new_combo.get('competitive_advantage', ''))
                                                                    
                                                                    # Будущие тренды
                                                                    if "future_trends" in wgsn_analysis and wgsn_analysis["future_trends"]:
                                                                        st.markdown("#### 🔮 Будущие тренды")
                                                                        for trend in wgsn_analysis["future_trends"]:
                                                                            if isinstance(trend, dict):
                                                                                with st.expander(f"**{trend.get('trend_name', 'Тренд')}** - {trend.get('timeframe', 'Срок не указан')}"):
                                                                                    st.markdown("**📄 Описание:**")
                                                                                    st.markdown(trend.get('description', ''))
                                                                                    
                                                                                    if trend.get('preparation_steps'):
                                                                                        st.markdown("**📋 Шаги подготовки:**")
                                                                                        for i, step in enumerate(trend.get('preparation_steps', []), 1):
                                                                                            st.markdown(f"{i}. {step}")
                                                                            else:
                                                                                st.markdown(f"- {trend}")
                                                                    
                                                                    # Конкурентные преимущества из трендов
                                                                    if "competitive_advantages_from_trends" in wgsn_analysis and wgsn_analysis["competitive_advantages_from_trends"]:
                                                                        st.markdown("#### 🏆 Конкурентные преимущества на основе трендов WGSN")
                                                                        for advantage in wgsn_analysis["competitive_advantages_from_trends"]:
                                                                            if isinstance(advantage, dict):
                                                                                with st.expander(f"**{advantage.get('advantage', 'Преимущество')}**"):
                                                                                    st.markdown("**📚 Основано на тренде WGSN:**")
                                                                                    st.info(advantage.get('wgsn_trend_basis', ''))
                                                                                    
                                                                                    if advantage.get('implementation'):
                                                                                        st.markdown("**⚙️ Реализация:**")
                                                                                        st.markdown(advantage.get('implementation', ''))
                                                                                    
                                                                                    if advantage.get('market_positioning'):
                                                                                        st.markdown("**📍 Позиционирование на рынке:**")
                                                                                        st.success(advantage.get('market_positioning', ''))
                                                                            else:
                                                                                st.markdown(f"- {advantage}")
                                                                    
                                                                    # План действий
                                                                    if "action_plan" in wgsn_analysis:
                                                                        st.markdown("#### 📋 План действий на основе WGSN")
                                                                        action_plan = wgsn_analysis["action_plan"]
                                                                        
                                                                        if action_plan.get("immediate_actions"):
                                                                            st.markdown("**⚡ Немедленные действия:**")
                                                                            for action in action_plan.get("immediate_actions", []):
                                                                                st.markdown(f"- {action}")
                                                                        
                                                                        if action_plan.get("short_term_actions"):
                                                                            st.markdown("**📅 Краткосрочные действия (3 месяца):**")
                                                                            for action in action_plan.get("short_term_actions", []):
                                                                                st.markdown(f"- {action}")
                                                                        
                                                                        if action_plan.get("long_term_actions"):
                                                                            st.markdown("**🗓️ Долгосрочные действия (6-12 месяцев):**")
                                                                            for action in action_plan.get("long_term_actions", []):
                                                                                st.markdown(f"- {action}")
                                                                    
                                                                    # Рыночные инсайты из WGSN
                                                                    if "market_insights" in wgsn_analysis:
                                                                        st.markdown("#### 📈 Рыночные инсайты на основе WGSN")
                                                                        st.markdown(wgsn_analysis["market_insights"])
                                                                    
                                                                    # Источники файлов
                                                                    if "source_files" in wgsn_analysis:
                                                                        st.caption(f"📁 Проанализированные файлы: {', '.join(wgsn_analysis['source_files'])}")
                                                                    
                                                                    # Показываем полный ответ для отладки (опционально)
                                                                    if st.session_state.get('debug_ai_analysis', False):
                                                                        with st.expander("🔍 Отладочная информация (полный ответ ИИ по WGSN)", expanded=False):
                                                                            st.text(wgsn_analysis.get("raw_response", ""))
                                                        
                                                        # Показываем полный ответ для отладки (опционально)
                                                        if st.session_state.get('debug_ai_analysis', False):
                                                            with st.expander("🔍 Отладочная информация (полный ответ ИИ)", expanded=False):
                                                                st.text(analysis_result.get("raw_response", ""))
                                                        
                                                        # Раздел для загрузки отчетов и плана продаж
                                                        st.divider()
                                                        st.markdown("### 📊 План продаж на основе отчетов")
                                                        
                                                        # Инициализация session_state для хранения отчетов комбинаций
                                                        if 'combination_reports' not in st.session_state:
                                                            st.session_state['combination_reports'] = {}
                                                        
                                                        # Загрузка отчета для комбинации
                                                        combo_report_key = f"report_{selected_combo_key}"
                                                        missing_reports_key = f"tovar_missing_{selected_combo_key}"
                                                        
                                                        # АВТОМАТИЧЕСКАЯ ЗАГРУЗКА ИЗ ПАПКИ TOVAR
                                                        st.markdown("#### 🔄 Автоматическая загрузка из папки Tovar")
                                                        st.caption("Система автоматически найдет и загрузит отчеты для товаров этой комбинации из папки Tovar")
                                                        
                                                        # Получаем артикулы из комбинации
                                                        combo_skus_list = [str(sku).replace(".0", "") for sku in combo_skus] if combo_skus else []
                                                        
                                                        # Быстрая проверка причин отсутствия отчетов
                                                        check_missing_key = f"check_missing_{selected_combo_key}"
                                                        if st.button("🔍 Показать причины отсутствия отчетов", key=check_missing_key):
                                                            with st.spinner("🔍 Проверяю наличие отчетов в папке Tovar..."):
                                                                _, missing_reports = find_reports_with_missing(
                                                                    tuple(combo_skus_list),
                                                                    "Tovar",
                                                                )
                                                                st.session_state[missing_reports_key] = missing_reports
                                                        
                                                        # Автоматическая загрузка при первом открытии, если отчет еще не загружен
                                                        auto_load_done_key = f"auto_load_done_{selected_combo_key}"
                                                        if (combo_report_key not in st.session_state.get('combination_reports', {}) and 
                                                            auto_load_done_key not in st.session_state and
                                                            combo_skus_list):
                                                            # Пробуем автоматически загрузить
                                                            with st.spinner("🔍 Автоматически ищу отчеты в папке Tovar..."):
                                                                found_reports, missing_reports = find_reports_with_missing(
                                                                    tuple(combo_skus_list),
                                                                    "Tovar",
                                                                )
                                                                
                                                                if found_reports:
                                                                    # Объединяем данные из всех отчетов
                                                                    all_reports_data = []
                                                                    loaded_skus = []
                                                                    
                                                                    for sku, report_info in found_reports.items():
                                                                        data = report_info['data'].copy()
                                                                        data['Артикул'] = sku
                                                                        all_reports_data.append(data)
                                                                        loaded_skus.append(sku)
                                                                    
                                                                    if all_reports_data:
                                                                        # Объединяем все данные
                                                                        combined_data = pd.concat(all_reports_data, ignore_index=True)
                                                                        
                                                                        # Группируем по дате и суммируем показатели
                                                                        aggregated_data = combined_data.groupby('Дата').agg({
                                                                            'Заказы': 'sum',
                                                                            'Продажи': 'sum',
                                                                            'Средняя цена': 'mean'  # Средняя цена по всем товарам
                                                                        }).reset_index()
                                                                        
                                                                        # Сохраняем в session_state
                                                                        st.session_state['combination_reports'][combo_report_key] = {
                                                                            'data': aggregated_data,
                                                                            'combination': selected_combo_key,
                                                                            'filename': f"Автоматически загружено из Tovar ({len(found_reports)} отчетов)",
                                                                            'source': 'auto_tovar',
                                                                            'loaded_skus': loaded_skus
                                                                        }
                                                                        
                                                                        st.session_state[auto_load_done_key] = True
                                                                        st.session_state[f"tovar_missing_{selected_combo_key}"] = missing_reports
                                                                        st.rerun()
                                                                else:
                                                                    # Помечаем, что попытка была, чтобы не повторять
                                                                    st.session_state[auto_load_done_key] = True
                                                                st.session_state[f"tovar_missing_{selected_combo_key}"] = missing_reports
                                                        
                                                        # Кнопка для ручной автоматической загрузки
                                                        auto_load_key = f"auto_load_{selected_combo_key}"
                                                        if st.button("🔄 Автоматически загрузить отчеты из папки Tovar", key=auto_load_key, type="primary"):
                                                            with st.spinner("🔍 Ищу отчеты в папке Tovar..."):
                                                                # Ищем и загружаем отчеты
                                                                found_reports, missing_reports = find_reports_with_missing(
                                                                    tuple(combo_skus_list),
                                                                    "Tovar",
                                                                )
                                                                
                                                                if found_reports:
                                                                    # Объединяем данные из всех отчетов
                                                                    all_reports_data = []
                                                                    loaded_skus = []
                                                                    
                                                                    for sku, report_info in found_reports.items():
                                                                        data = report_info['data'].copy()
                                                                        data['Артикул'] = sku
                                                                        all_reports_data.append(data)
                                                                        loaded_skus.append(sku)
                                                                    
                                                                    if all_reports_data:
                                                                        # Объединяем все данные
                                                                        combined_data = pd.concat(all_reports_data, ignore_index=True)
                                                                        
                                                                        # Группируем по дате и суммируем показатели
                                                                        aggregated_data = combined_data.groupby('Дата').agg({
                                                                            'Заказы': 'sum',
                                                                            'Продажи': 'sum',
                                                                            'Средняя цена': 'mean'  # Средняя цена по всем товарам
                                                                        }).reset_index()
                                                                        
                                                                        # Сохраняем в session_state
                                                                        st.session_state['combination_reports'][combo_report_key] = {
                                                                            'data': aggregated_data,
                                                                            'combination': selected_combo_key,
                                                                            'filename': f"Автоматически загружено из Tovar ({len(found_reports)} отчетов)",
                                                                            'source': 'auto_tovar',
                                                                            'loaded_skus': loaded_skus
                                                                        }
                                                                        
                                                                        st.success(f"✅ Автоматически загружено {len(found_reports)} отчетов для артикулов: {', '.join(loaded_skus[:5])}{'...' if len(loaded_skus) > 5 else ''}")
                                                                        st.session_state[f"tovar_missing_{selected_combo_key}"] = missing_reports
                                                                        st.rerun()
                                                                    else:
                                                                        st.warning("⚠️ Не удалось обработать найденные отчеты")
                                                                else:
                                                                    st.info(f"ℹ️ Не найдено отчетов в папке Tovar для артикулов: {', '.join(combo_skus_list[:5])}{'...' if len(combo_skus_list) > 5 else ''}")
                                                                st.session_state[f"tovar_missing_{selected_combo_key}"] = missing_reports
                                                                
                                                                # Показываем какие артикулы есть в комбинации
                                                                if combo_skus_list:
                                                                    with st.expander("📋 Артикулы в комбинации", expanded=False):
                                                                        st.write(", ".join(combo_skus_list))
                                                        
                                                        # Проверяем, есть ли уже загруженные отчеты
                                                        if combo_report_key in st.session_state.get('combination_reports', {}):
                                                            report_info = st.session_state['combination_reports'][combo_report_key]
                                                            if report_info.get('source') == 'auto_tovar':
                                                                st.success(f"✅ Отчеты загружены автоматически из папки Tovar")
                                                                if 'loaded_skus' in report_info:
                                                                    st.caption(f"Загружено для артикулов: {', '.join(report_info['loaded_skus'][:5])}{'...' if len(report_info['loaded_skus']) > 5 else ''}")
                                                        
                                                        # Показываем, для каких артикулов отчеты не найдены/не загружены
                                                        missing_reports_key = f"tovar_missing_{selected_combo_key}"
                                                        if st.session_state.get(missing_reports_key):
                                                            missing_reports = st.session_state[missing_reports_key]
                                                            st.warning(
                                                                f"⚠️ Отчеты не загружены для {len(missing_reports)} артикулов."
                                                            )
                                                            with st.expander("❗️Отчеты не загружены (причины)", expanded=False):
                                                                st.markdown(
                                                                    "\n".join(
                                                                        [f"- {sku}: {reason}" for sku, reason in missing_reports.items()]
                                                                    )
                                                                )
                                                        
                                                        st.divider()
                                                        
                                                        # РУЧНАЯ ЗАГРУЗКА
                                                        st.markdown("#### 📤 Ручная загрузка отчета")
                                                        st.caption("Или загрузите Excel/CSV файл вручную с данными по дням (заказы, продажи, средняя цена)")
                                                        st.info("💡 **Совет:** Вы можете загрузить отчеты для разных комбинаций товаров. Все загруженные отчеты будут отображаться на одном графике для сравнения.")
                                                        
                                                        # Показываем информацию о текущем отчете, если он загружен автоматически
                                                        if combo_report_key in st.session_state.get('combination_reports', {}):
                                                            current_report = st.session_state['combination_reports'][combo_report_key]
                                                            if current_report.get('source') == 'auto_tovar':
                                                                st.info(f"📁 Текущий отчет: {current_report.get('filename', 'Автоматически загружен')}")
                                                                if st.button("🔄 Обновить автоматическую загрузку", key=f"refresh_auto_{selected_combo_key}"):
                                                                    # Удаляем старый отчет и загружаем заново
                                                                    if combo_report_key in st.session_state['combination_reports']:
                                                                        del st.session_state['combination_reports'][combo_report_key]
                                                                    st.rerun()
                                                        
                                                        uploaded_report = st.file_uploader(
                                                            "Выберите файл с отчетом (ручная загрузка)",
                                                            type=['xlsx', 'xls', 'csv'],
                                                            key=f"report_uploader_{selected_combo_key}",
                                                            help="Файл должен содержать колонки: Дата, Заказы, Продажи (или Выкупы), Средняя цена. Ручная загрузка заменит автоматически загруженный отчет."
                                                        )
                                                        
                                                        if uploaded_report is not None:
                                                            try:
                                                                # Обрабатываем загруженный файл
                                                                if uploaded_report.name.endswith('.csv'):
                                                                    report_df = pd.read_csv(uploaded_report)
                                                                else:
                                                                    report_df = pd.read_excel(uploaded_report)
                                                                
                                                                # Нормализуем названия колонок
                                                                report_df.columns = report_df.columns.str.strip()
                                                                
                                                                # Ищем колонку с датой
                                                                date_col = None
                                                                for col in report_df.columns:
                                                                    if 'дата' in col.lower() or 'date' in col.lower():
                                                                        date_col = col
                                                                        break
                                                                
                                                                if date_col is None:
                                                                    st.error("❌ Не найдена колонка с датой в отчете")
                                                                else:
                                                                    # Преобразуем дату
                                                                    report_df[date_col] = pd.to_datetime(report_df[date_col], errors='coerce')
                                                                    report_df = report_df.dropna(subset=[date_col])
                                                                    
                                                                    # Ищем колонки с данными
                                                                    orders_col = None
                                                                    sales_col = None
                                                                    price_col = None
                                                                    
                                                                    for col in report_df.columns:
                                                                        col_lower = col.lower()
                                                                        if ('заказ' in col_lower or 'order' in col_lower) and orders_col is None:
                                                                            orders_col = col
                                                                        elif ('продаж' in col_lower or 'выкуп' in col_lower or 'sale' in col_lower) and sales_col is None:
                                                                            sales_col = col
                                                                        elif ('цена' in col_lower or 'price' in col_lower) and price_col is None:
                                                                            price_col = col
                                                                    
                                                                    # Создаем нормализованный DataFrame
                                                                    normalized_data = pd.DataFrame()
                                                                    normalized_data['Дата'] = report_df[date_col]
                                                                    normalized_data['Заказы'] = report_df[orders_col] if orders_col else 0
                                                                    normalized_data['Продажи'] = report_df[sales_col] if sales_col else 0
                                                                    normalized_data['Средняя цена'] = report_df[price_col] if price_col else 0
                                                                    
                                                                    # Сохраняем данные в session_state
                                                                    st.session_state['combination_reports'][combo_report_key] = {
                                                                        'data': normalized_data,
                                                                        'combination': selected_combo_key,
                                                                        'filename': uploaded_report.name
                                                                    }
                                                                    
                                                                    st.success(f"✅ Отчет загружен успешно! Загружено {len(normalized_data)} записей")
                                                                    
                                                                    # Показываем предпросмотр данных
                                                                    with st.expander("📋 Предпросмотр данных", expanded=False):
                                                                        st.dataframe(normalized_data.head(10))
                                                            except Exception as e:
                                                                st.error(f"❌ Ошибка при обработке файла: {str(e)}")
                                                        
                                                        # Показываем загруженные отчеты и строим график
                                                        if combo_report_key in st.session_state.get('combination_reports', {}):
                                                            report_data = st.session_state['combination_reports'][combo_report_key]['data']
                                                            
                                                            st.markdown("#### 📈 График плана продаж")
                                                            
                                                            # Получаем все загруженные отчеты для сравнения
                                                            all_reports = st.session_state.get('combination_reports', {})
                                                            
                                                            if len(all_reports) > 0:
                                                                # Создаем объединенный DataFrame для сравнения
                                                                comparison_data = []
                                                                
                                                                for report_key, report_info in all_reports.items():
                                                                    data = report_info['data'].copy()
                                                                    data['Комбинация'] = report_info['combination']
                                                                    comparison_data.append(data)
                                                                
                                                                if comparison_data:
                                                                    combined_df = pd.concat(comparison_data, ignore_index=True)
                                                                    
                                                                    # Находим общий период дат
                                                                    all_dates = combined_df['Дата'].unique()
                                                                    all_dates = sorted(all_dates)
                                                                    
                                                                    # Создаем полный диапазон дат
                                                                    if len(all_dates) > 1:
                                                                        date_range = pd.date_range(start=all_dates[0], end=all_dates[-1], freq='D')
                                                                    else:
                                                                        date_range = pd.date_range(start=all_dates[0], periods=30, freq='D')
                                                                    
                                                                    # Строим график с тремя вариантами
                                                                    fig = go.Figure()
                                                                    
                                                                    # Для каждой комбинации рассчитываем статистику
                                                                    for combo_name in combined_df['Комбинация'].unique():
                                                                        combo_data = combined_df[combined_df['Комбинация'] == combo_name].copy()
                                                                        
                                                                        # Сортируем по дате
                                                                        combo_data = combo_data.sort_values('Дата')
                                                                        
                                                                        # Создаем полный ряд дат для этой комбинации
                                                                        full_combo_data = pd.DataFrame({'Дата': date_range})
                                                                        full_combo_data = full_combo_data.merge(
                                                                            combo_data[['Дата', 'Заказы', 'Продажи', 'Средняя цена']],
                                                                            on='Дата',
                                                                            how='left'
                                                                        )
                                                                        full_combo_data = full_combo_data.fillna(0)
                                                                        
                                                                        # Рассчитываем продажи (если есть средняя цена и заказы)
                                                                        if 'Средняя цена' in full_combo_data.columns and 'Заказы' in full_combo_data.columns:
                                                                            full_combo_data['Выручка'] = full_combo_data['Заказы'] * full_combo_data['Средняя цена']
                                                                        
                                                                        # Рассчитываем статистику для трех вариантов
                                                                        # Используем только фактические данные (не заполненные нулями)
                                                                        actual_sales_data = combo_data[combo_data['Продажи'] > 0]['Продажи'].values
                                                                        
                                                                        if len(actual_sales_data) > 0:
                                                                            sales_mean = np.mean(actual_sales_data)
                                                                            sales_std = np.std(actual_sales_data) if len(actual_sales_data) > 1 else 0
                                                                            
                                                                            # Низкий вариант (среднее - 1 стандартное отклонение, но не меньше минимального значения)
                                                                            low_plan = max(0, sales_mean - sales_std)
                                                                            # Средний вариант (среднее)
                                                                            mid_plan = sales_mean
                                                                            # Высокий вариант (среднее + 1 стандартное отклонение)
                                                                            high_plan = sales_mean + sales_std
                                                                        else:
                                                                            # Если нет данных о продажах, используем заказы как основу
                                                                            actual_orders_data = combo_data[combo_data['Заказы'] > 0]['Заказы'].values
                                                                            if len(actual_orders_data) > 0:
                                                                                # Предполагаем процент выкупа 25% по умолчанию
                                                                                buyout_rate = st.session_state.get("buyout_pct", 25) / 100.0
                                                                                orders_mean = np.mean(actual_orders_data)
                                                                                orders_std = np.std(actual_orders_data) if len(actual_orders_data) > 1 else 0
                                                                                
                                                                                sales_mean = orders_mean * buyout_rate
                                                                                sales_std = orders_std * buyout_rate
                                                                                
                                                                                low_plan = max(0, sales_mean - sales_std)
                                                                                mid_plan = sales_mean
                                                                                high_plan = sales_mean + sales_std
                                                                            else:
                                                                                # Если вообще нет данных, пропускаем эту комбинацию
                                                                                continue
                                                                            
                                                                            # Добавляем линии плана
                                                                            fig.add_trace(go.Scatter(
                                                                                x=date_range,
                                                                                y=[low_plan] * len(date_range),
                                                                                mode='lines',
                                                                                name=f'{combo_name} - Низкий план',
                                                                                line=dict(color='red', width=2),
                                                                                hovertemplate='Низкий план: %{y:.1f}<extra></extra>'
                                                                            ))
                                                                            
                                                                            fig.add_trace(go.Scatter(
                                                                                x=date_range,
                                                                                y=[mid_plan] * len(date_range),
                                                                                mode='lines',
                                                                                name=f'{combo_name} - Средний план',
                                                                                line=dict(color='orange', width=2),
                                                                                hovertemplate='Средний план: %{y:.1f}<extra></extra>'
                                                                            ))
                                                                            
                                                                            fig.add_trace(go.Scatter(
                                                                                x=date_range,
                                                                                y=[high_plan] * len(date_range),
                                                                                mode='lines',
                                                                                name=f'{combo_name} - Высокий план',
                                                                                line=dict(color='green', width=2),
                                                                                hovertemplate='Высокий план: %{y:.1f}<extra></extra>'
                                                                            ))
                                                                            
                                                                            # Добавляем фактические данные (если есть)
                                                                            # Фильтруем только записи с данными (не нули)
                                                                            actual_data = combo_data[combo_data['Продажи'] > 0].copy()
                                                                            
                                                                            if len(actual_data) > 0:
                                                                                actual_dates = actual_data['Дата'].values
                                                                                actual_sales = actual_data['Продажи'].values
                                                                                
                                                                                fig.add_trace(go.Scatter(
                                                                                    x=actual_dates,
                                                                                    y=actual_sales,
                                                                                    mode='lines+markers',
                                                                                    name=f'{combo_name} - Факт',
                                                                                    line=dict(color='blue', width=2),
                                                                                    marker=dict(size=6),
                                                                                    hovertemplate='Дата: %{x|%d.%m.%Y}<br>Продажи: %{y:.1f}<extra></extra>',
                                                                                    connectgaps=False  # Не соединять пропуски
                                                                                ))
                                                                    
                                                                    # Настройка графика
                                                                    fig.update_layout(
                                                                        title='План продаж: Низкий, Средний, Высокий варианты',
                                                                        xaxis_title='Дата',
                                                                        yaxis_title='Продажи, шт',
                                                                        hovermode='x unified',
                                                                        height=600,
                                                                        legend=dict(
                                                                            orientation="v",
                                                                            yanchor="top",
                                                                            y=1,
                                                                            xanchor="left",
                                                                            x=1.01
                                                                        )
                                                                    )
                                                                    
                                                                    st.plotly_chart(fig, use_container_width=True)
                                                                    
                                                                    # Показываем статистику
                                                                    st.markdown("#### 📊 Статистика планов")
                                                                    stats_cols = st.columns(min(len(all_reports), 4))  # Максимум 4 колонки
                                                                    
                                                                    for idx, (report_key, report_info) in enumerate(all_reports.items()):
                                                                        if idx >= len(stats_cols):
                                                                            break
                                                                        with stats_cols[idx]:
                                                                            combo_name = report_info['combination']
                                                                            data = report_info['data']
                                                                            
                                                                            # Используем только фактические данные
                                                                            actual_sales = data[data['Продажи'] > 0]['Продажи'].values
                                                                            
                                                                            if len(actual_sales) > 0:
                                                                                sales_mean = np.mean(actual_sales)
                                                                                sales_std = np.std(actual_sales) if len(actual_sales) > 1 else 0
                                                                                
                                                                                # Показываем количество дней с данными
                                                                                days_with_data = len(actual_sales)
                                                                                total_days = len(data)
                                                                                
                                                                                st.markdown(f"**{combo_name[:30]}...**" if len(combo_name) > 30 else f"**{combo_name}**")
                                                                                st.caption(f"Дней с данными: {days_with_data} из {total_days}")
                                                                                st.metric("Низкий план", f"{max(0, sales_mean - sales_std):.1f}")
                                                                                st.metric("Средний план", f"{sales_mean:.1f}")
                                                                                st.metric("Высокий план", f"{sales_mean + sales_std:.1f}")
                                                                            else:
                                                                                # Если нет данных о продажах, используем заказы
                                                                                actual_orders = data[data['Заказы'] > 0]['Заказы'].values
                                                                                if len(actual_orders) > 0:
                                                                                    buyout_rate = st.session_state.get("buyout_pct", 25) / 100.0
                                                                                    orders_mean = np.mean(actual_orders)
                                                                                    orders_std = np.std(actual_orders) if len(actual_orders) > 1 else 0
                                                                                    
                                                                                    sales_mean = orders_mean * buyout_rate
                                                                                    sales_std = orders_std * buyout_rate
                                                                                    
                                                                                    st.markdown(f"**{combo_name[:30]}...**" if len(combo_name) > 30 else f"**{combo_name}**")
                                                                                    st.caption("⚠️ Рассчитано на основе заказов")
                                                                                    st.metric("Низкий план", f"{max(0, sales_mean - sales_std):.1f}")
                                                                                    st.metric("Средний план", f"{sales_mean:.1f}")
                                                                                    st.metric("Высокий план", f"{sales_mean + sales_std:.1f}")
                                                                                else:
                                                                                    st.markdown(f"**{combo_name[:30]}...**" if len(combo_name) > 30 else f"**{combo_name}**")
                                                                                    st.warning("Нет данных")
                                                                    
                                                                    # Кнопка для удаления отчета
                                                                    if st.button(f"🗑️ Удалить отчет для '{selected_combo_key}'", key=f"delete_report_{selected_combo_key}"):
                                                                        if combo_report_key in st.session_state['combination_reports']:
                                                                            del st.session_state['combination_reports'][combo_report_key]
                                                                        st.rerun()
                                                            else:
                                                                st.info("📊 Загрузите отчет для построения графика плана продаж")
                                        else:
                                            st.warning("⚠️ Не найдено товаров для выбранной комбинации")
                                    else:
                                        st.warning("⚠️ Комбинация не найдена в данных. Возможно, данные были изменены.")
                            else:
                                st.info("ℹ️ Выберите комбинацию из списка выше")
                        else:
                            st.warning("⚠️ Все комбинации исключены. Сбросьте исключения, чтобы увидеть топ-10.")
                    else:
                        st.info("ℹ️ Не найдено комбинаций с полными данными по всем параметрам")
                else:
                    st.info("ℹ️ Не найдено товаров с заполненными всеми параметрами. Заполните параметры для всех товаров, чтобы увидеть лучшие комбинации.")
        
        # Вкладка "План продаж"
        # Определяем номер вкладки в зависимости от наличия других вкладок
        if PROPHET_AVAILABLE:
            sales_plan_tab = tab5  # После tab4 (Прогнозирование)
        else:
            sales_plan_tab = tab4  # После tab3 (Аналитика по параметрам)
        
        with sales_plan_tab:
            st.subheader("🗺️ План продаж")
            
            # Проверяем наличие данных о комбинациях
            top_10_combinations = st.session_state.get('top_10_combinations', [])
            top_10_novelty_combinations = st.session_state.get('top_10_novelty_combinations', [])
            top_10_regular_combinations = st.session_state.get('top_10_regular_combinations', [])
            cleaned_combo_to_skus = st.session_state.get('cleaned_combo_to_skus', {})
            novelty_months = st.session_state.get('novelty_months', None)
            
            if not top_10_combinations:
                st.info("ℹ️ Сначала перейдите во вкладку '📈 Аналитика по параметрам' и сформируйте топ комбинаций, чтобы использовать план продаж.")
            else:
                # Формируем список всех комбинаций для выбора
                combo_options = []
                if novelty_months is not None and top_10_novelty_combinations:
                    for idx, combo in enumerate(top_10_novelty_combinations, 1):
                        combo_options.append(f"🆕 #{idx} (Новинка) - {combo['Комбинация']}")
                
                if top_10_regular_combinations:
                    for idx, combo in enumerate(top_10_regular_combinations, 1):
                        prefix = "📦" if novelty_months is not None else ""
                        combo_options.append(f"{prefix} #{idx} - {combo['Комбинация']}")
                
                selected_combo_idx = st.selectbox(
                    "Выберите комбинацию для плана продаж:",
                    options=combo_options,
                    help="Выберите комбинацию из топ-10, чтобы загрузить отчеты и построить план продаж",
                    key="sales_plan_combo_select"
                )
                
                if selected_combo_idx:
                    # Определяем, из какого списка выбрана комбинация
                    is_novelty_selection = "🆕" in selected_combo_idx or "(Новинка)" in selected_combo_idx
                    
                    # Извлекаем индекс выбранной комбинации
                    idx_part = selected_combo_idx.split(" - ")[0].replace("#", "").replace("🆕", "").replace("📦", "").replace("(Новинка)", "").strip()
                    selected_idx = int(idx_part) - 1
                    
                    # Выбираем комбинацию из соответствующего списка
                    if is_novelty_selection and novelty_months is not None and top_10_novelty_combinations:
                        if selected_idx < len(top_10_novelty_combinations):
                            selected_combo = top_10_novelty_combinations[selected_idx]
                        else:
                            selected_combo = None
                    else:
                        if selected_idx < len(top_10_regular_combinations):
                            selected_combo = top_10_regular_combinations[selected_idx]
                        else:
                            selected_combo = None
                    
                    if selected_combo:
                        selected_combo_key = selected_combo['Комбинация']
                        # Сохраняем выбранную комбинацию для синхронизации между вкладками
                        st.session_state["selected_combo_key_global"] = selected_combo_key
                        
                        # Получаем артикулы для выбранной комбинации
                        combo_skus = None
                        cleaned_combo_str = selected_combo_key
                        if cleaned_combo_str in cleaned_combo_to_skus:
                            combo_skus = cleaned_combo_to_skus[cleaned_combo_str]
                        else:
                            # Пробуем найти по частичному совпадению
                            for orig_combo, orig_skus in cleaned_combo_to_skus.items():
                                selected_parts = set(selected_combo_key.split(" | "))
                                orig_parts = set(orig_combo.split(" | "))
                                if selected_parts.issubset(orig_parts) or selected_parts == orig_parts:
                                    combo_skus = orig_skus
                                    break
                        
                        if combo_skus:
                            # Применяем фильтр артикулов из "Анализ данных"
                            combo_skus, excluded_skus = filter_skus_by_analysis_with_details(combo_skus)
                            if excluded_skus:
                                excluded_preview = ", ".join([str(s) for s in excluded_skus[:10]])
                                suffix = f" (+{len(excluded_skus) - 10})" if len(excluded_skus) > 10 else ""
                                st.caption(
                                    f"🧹 Исключено артикулов из фильтра анализа: {len(excluded_skus)} "
                                    f"(фильтр «Анализ данных»). {excluded_preview}{suffix}"
                                )
                            # Создаём вкладки внутри плана продаж
                            plan_subtab1, plan_subtab2, plan_subtab3, plan_subtab4 = st.tabs(["📊 План", "📈 Ситуация", "📋 Таблица", "💬 Чат с ИИ"])
                            
                            with plan_subtab1:
                                # Инициализация session_state для хранения отчетов комбинаций
                                if 'combination_reports' not in st.session_state:
                                    st.session_state['combination_reports'] = {}
                                
                                # Загрузка отчета для комбинации
                                combo_report_key = f"report_{selected_combo_key}"
                                missing_reports_key = f"tovar_missing_{selected_combo_key}"
                            
                            # Получаем артикулы из комбинации
                            combo_skus_list = [str(sku).replace(".0", "") for sku in combo_skus] if combo_skus else []
                            
                            # Получаем данные о товарах комбинации для базовой цены
                            df = st.session_state.get('df', None)
                            combo_products_df = None
                            base_price = None
                            if df is not None and combo_skus:
                                mask = df["Артикул"].astype(str).str.replace(".0", "").isin(combo_skus_list)
                                combo_products_df = df[mask].copy()
                                
                                if not combo_products_df.empty:
                                    # Берем базовую цену из таблицы
                                    if "Базовая цена, ₽" in combo_products_df.columns:
                                        base_price = combo_products_df["Базовая цена, ₽"].mean()
                                    elif "Базовая цена" in combo_products_df.columns:
                                        base_price = combo_products_df["Базовая цена"].mean()
                                    elif "Средняя цена без СПП" in combo_products_df.columns:
                                        base_price = combo_products_df["Средняя цена без СПП"].mean()
                                    elif "Средняя цена" in combo_products_df.columns:
                                        base_price = combo_products_df["Средняя цена"].mean()
                            
                            # АВТОМАТИЧЕСКАЯ ЗАГРУЗКА ИЗ ПАПКИ TOVAR (свернуто)
                            with st.expander("🔄 Автоматическая загрузка из папки Tovar", expanded=False):
                                st.caption("Система автоматически найдет и загрузит отчеты для товаров этой комбинации из папки Tovar")
                                
                                check_missing_key = f"check_missing_plan_{selected_combo_key}"
                                if st.button("🔍 Показать причины отсутствия отчетов", key=check_missing_key):
                                    with st.spinner("🔍 Проверяю наличие отчетов в папке Tovar..."):
                                        _, missing_reports = find_reports_with_missing(
                                            tuple(combo_skus_list),
                                            "Tovar"
                                        )
                                        st.session_state[missing_reports_key] = missing_reports
                                    
                                # Автоматическая загрузка при первом открытии, если отчет еще не загружен
                                auto_load_done_key = f"auto_load_done_{selected_combo_key}"
                                if (combo_report_key not in st.session_state.get('combination_reports', {}) and 
                                    auto_load_done_key not in st.session_state and
                                    combo_skus_list):
                                    # Пробуем автоматически загрузить
                                    with st.spinner("🔍 Автоматически ищу отчеты в папке Tovar..."):
                                        found_reports, missing_reports = find_reports_with_missing(
                                            tuple(combo_skus_list),
                                            "Tovar"
                                        )
                                    
                                    if found_reports:
                                        # Объединяем данные из всех отчетов
                                        all_reports_data = []
                                        loaded_skus = []
                                        
                                        for sku, report_info in found_reports.items():
                                            data = report_info['data'].copy()
                                            data['Артикул'] = sku
                                            all_reports_data.append(data)
                                            loaded_skus.append(sku)
                                        
                                        if all_reports_data:
                                            # Объединяем все данные
                                            combined_data = pd.concat(all_reports_data, ignore_index=True)
                                            
                                            # Группируем по дате и суммируем показатели
                                            aggregated_data = combined_data.groupby('Дата').agg({
                                                'Заказы': 'sum',
                                                'Продажи': 'sum',
                                                'Средняя цена': 'mean'  # Средняя цена по всем товарам
                                            }).reset_index()
                                            
                                            # Сохраняем в session_state
                                            st.session_state['combination_reports'][combo_report_key] = {
                                                'data': aggregated_data,
                                                'combination': selected_combo_key,
                                                'filename': f"Автоматически загружено из Tovar ({len(found_reports)} отчетов)",
                                                'source': 'auto_tovar',
                                                'loaded_skus': loaded_skus
                                            }
                                            
                                            st.session_state[auto_load_done_key] = True
                                            st.session_state[missing_reports_key] = missing_reports
                                            st.rerun()
                                    else:
                                        # Помечаем, что попытка была, чтобы не повторять
                                        st.session_state[auto_load_done_key] = True
                                        st.session_state[missing_reports_key] = missing_reports
                            
                                # Кнопка для ручной автоматической загрузки
                                auto_load_key = f"auto_load_{selected_combo_key}"
                                if st.button("🔄 Автоматически загрузить отчеты из папки Tovar", key=auto_load_key, type="primary"):
                                    with st.spinner("🔍 Ищу отчеты в папке Tovar..."):
                                        # Ищем и загружаем отчеты
                                        found_reports, missing_reports = find_reports_with_missing(
                                            tuple(combo_skus_list),
                                            "Tovar"
                                        )
                                        
                                        if found_reports:
                                            # Объединяем данные из всех отчетов
                                            all_reports_data = []
                                            loaded_skus = []
                                            
                                            for sku, report_info in found_reports.items():
                                                data = report_info['data'].copy()
                                                data['Артикул'] = sku
                                                all_reports_data.append(data)
                                                loaded_skus.append(sku)
                                            
                                            if all_reports_data:
                                                # Объединяем все данные
                                                combined_data = pd.concat(all_reports_data, ignore_index=True)
                                                
                                                # Группируем по дате и суммируем показатели
                                                aggregated_data = combined_data.groupby('Дата').agg({
                                                    'Заказы': 'sum',
                                                    'Продажи': 'sum',
                                                    'Средняя цена': 'mean'  # Средняя цена по всем товарам
                                                }).reset_index()
                                                
                                                # Сохраняем в session_state
                                                st.session_state['combination_reports'][combo_report_key] = {
                                                    'data': aggregated_data,
                                                    'combination': selected_combo_key,
                                                    'filename': f"Автоматически загружено из Tovar ({len(found_reports)} отчетов)",
                                                    'source': 'auto_tovar',
                                                    'loaded_skus': loaded_skus
                                                }
                                                
                                                st.success(f"✅ Автоматически загружено {len(found_reports)} отчетов для артикулов: {', '.join(loaded_skus[:5])}{'...' if len(loaded_skus) > 5 else ''}")
                                                st.session_state[missing_reports_key] = missing_reports
                                                st.rerun()
                                            else:
                                                st.warning("⚠️ Не удалось обработать найденные отчеты")
                                        else:
                                            st.info(f"ℹ️ Не найдено отчетов в папке Tovar для артикулов: {', '.join(combo_skus_list[:5])}{'...' if len(combo_skus_list) > 5 else ''}")
                                            st.session_state[missing_reports_key] = missing_reports
                                            
                                            # Показываем какие артикулы есть в комбинации
                                            if combo_skus_list:
                                                with st.expander("📋 Артикулы в комбинации", expanded=False):
                                                    st.write(", ".join(combo_skus_list))
                                
                                # Проверяем, есть ли уже загруженные отчеты
                                if combo_report_key in st.session_state.get('combination_reports', {}):
                                    report_info = st.session_state['combination_reports'][combo_report_key]
                                    if report_info.get('source') == 'auto_tovar':
                                        st.success(f"✅ Отчеты загружены автоматически из папки Tovar")
                                        if 'loaded_skus' in report_info:
                                            st.caption(f"Загружено для артикулов: {', '.join(report_info['loaded_skus'][:5])}{'...' if len(report_info['loaded_skus']) > 5 else ''}")
                                    
                                    missing_reports = st.session_state.get(missing_reports_key)
                                    if missing_reports:
                                        if st.button("🔎 Уточнить причины ошибок чтения", key=f"enrich_missing_{selected_combo_key}"):
                                            missing_reports = enrich_missing_reports(
                                                missing_reports,
                                                combo_skus_list,
                                                "Tovar"
                                            )
                                            st.session_state[missing_reports_key] = missing_reports
                                            st.rerun()
                                        st.warning(f"⚠️ Отчеты не загружены для {len(missing_reports)} артикулов.")
                                        with st.expander("❗️Отчеты не загружены (причины)", expanded=False):
                                            st.markdown(
                                                "\n".join(
                                                    [f"- {sku}: {reason}" for sku, reason in missing_reports.items()]
                                                )
                                            )
                            
                            # РУЧНАЯ ЗАГРУЗКА (свернуто)
                            with st.expander("📤 Ручная загрузка отчета", expanded=False):
                                st.caption("Или загрузите Excel/CSV файл вручную с данными по дням (заказы, продажи, средняя цена)")
                                
                                # Показываем информацию о текущем отчете, если он загружен автоматически
                                if combo_report_key in st.session_state.get('combination_reports', {}):
                                    current_report = st.session_state['combination_reports'][combo_report_key]
                                    if current_report.get('source') == 'auto_tovar':
                                        st.info(f"📁 Текущий отчет: {current_report.get('filename', 'Автоматически загружен')}")
                                        if st.button("🔄 Обновить автоматическую загрузку", key=f"refresh_auto_{selected_combo_key}"):
                                            # Удаляем старый отчет и загружаем заново
                                            if combo_report_key in st.session_state['combination_reports']:
                                                del st.session_state['combination_reports'][combo_report_key]
                                            if auto_load_done_key in st.session_state:
                                                del st.session_state[auto_load_done_key]
                                            st.rerun()
                                
                                uploaded_report = st.file_uploader(
                                    "Выберите файл с отчетом (ручная загрузка)",
                                    type=['xlsx', 'xls', 'csv'],
                                    key=f"report_uploader_{selected_combo_key}",
                                    help="Файл должен содержать колонки: Дата, Заказы, Продажи (или Выкупы), Средняя цена. Ручная загрузка заменит автоматически загруженный отчет."
                                )
                            
                            if uploaded_report is not None:
                                try:
                                    # Обрабатываем загруженный файл
                                    if uploaded_report.name.endswith('.csv'):
                                        report_df = pd.read_csv(uploaded_report)
                                    else:
                                        report_df = pd.read_excel(uploaded_report)
                                    
                                    # Нормализуем названия колонок
                                    report_df.columns = report_df.columns.str.strip()
                                    
                                    # Ищем колонку с датой
                                    date_col = None
                                    for col in report_df.columns:
                                        if 'дата' in col.lower() or 'date' in col.lower():
                                            date_col = col
                                            break
                                    
                                    if date_col is None:
                                        st.error("❌ Не найдена колонка с датой в отчете")
                                    else:
                                        # Преобразуем дату
                                        report_df[date_col] = pd.to_datetime(report_df[date_col], errors='coerce')
                                        report_df = report_df.dropna(subset=[date_col])
                                        
                                        # Ищем колонки с данными
                                        orders_col = None
                                        sales_col = None
                                        price_col = None
                                        
                                        for col in report_df.columns:
                                            col_lower = col.lower()
                                            if ('заказ' in col_lower or 'order' in col_lower) and orders_col is None:
                                                orders_col = col
                                            elif ('продаж' in col_lower or 'выкуп' in col_lower or 'sale' in col_lower) and sales_col is None:
                                                sales_col = col
                                            elif ('цена' in col_lower or 'price' in col_lower) and price_col is None:
                                                price_col = col
                                        
                                        # Создаем нормализованный DataFrame
                                        normalized_data = pd.DataFrame()
                                        normalized_data['Дата'] = report_df[date_col]
                                        normalized_data['Заказы'] = report_df[orders_col] if orders_col else 0
                                        normalized_data['Продажи'] = report_df[sales_col] if sales_col else 0
                                        normalized_data['Средняя цена'] = report_df[price_col] if price_col else 0
                                        
                                        # Сохраняем данные в session_state
                                        st.session_state['combination_reports'][combo_report_key] = {
                                            'data': normalized_data,
                                            'combination': selected_combo_key,
                                            'filename': uploaded_report.name,
                                            'source': 'manual'
                                        }
                                        
                                        st.success(f"✅ Отчет загружен успешно! Загружено {len(normalized_data)} записей")
                                        
                                        # Показываем предпросмотр данных
                                        with st.expander("📋 Предпросмотр данных", expanded=False):
                                            st.dataframe(normalized_data.head(10))
                                        st.rerun()
                                except Exception as e:
                                    st.error(f"❌ Ошибка при обработке файла: {str(e)}")
                            
                            # Показываем загруженные отчеты и строим график
                            if combo_report_key in st.session_state.get('combination_reports', {}):
                                report_data = st.session_state['combination_reports'][combo_report_key]['data']
                                
                                st.markdown("#### 📈 График плана продаж")
                                
                                # Выбор режима отображения: комбинация или отдельный товар
                                view_mode = st.radio(
                                    "Режим просмотра:",
                                    ["📊 Комбинация товаров", "📦 Отдельный товар"],
                                    key=f"view_mode_{selected_combo_key}",
                                    horizontal=True
                                )
                                
                                # Если выбран режим отдельного товара, показываем выбор товара
                                selected_sku_for_plan = None
                                if view_mode == "📦 Отдельный товар":
                                    if combo_skus_list:
                                        # Получаем названия товаров для выбора
                                        sku_options = []
                                        for sku in combo_skus_list:
                                            # Пытаемся получить название товара из данных
                                            sku_name = sku
                                            if combo_products_df is not None and not combo_products_df.empty:
                                                sku_row = combo_products_df[combo_products_df["Артикул"].astype(str).str.replace(".0", "") == sku]
                                                if not sku_row.empty:
                                                    # Пытаемся найти название в колонках
                                                    name_cols = [col for col in sku_row.columns if 'название' in col.lower() or 'name' in col.lower() or 'товар' in col.lower()]
                                                    if name_cols:
                                                        sku_name = f"{sku} - {sku_row[name_cols[0]].iloc[0]}"
                                            sku_options.append(sku_name)
                                        
                                        selected_sku_idx = st.selectbox(
                                            "Выберите товар:",
                                            options=range(len(combo_skus_list)),
                                            format_func=lambda x: sku_options[x],
                                            key=f"sku_select_{selected_combo_key}"
                                        )
                                        selected_sku_for_plan = combo_skus_list[selected_sku_idx]
                                    else:
                                        st.warning("⚠️ Нет товаров в комбинации")
                                
                                # Выбор промежутка времени для просмотра данных
                                st.markdown("#### 📅 Период анализа")
                                date_col1, date_col2 = st.columns(2)
                                
                                with date_col1:
                                    min_date = None
                                    max_date = None
                                    if combo_report_key in st.session_state.get('combination_reports', {}):
                                        report_data = st.session_state['combination_reports'][combo_report_key]['data']
                                        if not report_data.empty and 'Дата' in report_data.columns:
                                            min_date = report_data['Дата'].min()
                                            max_date = report_data['Дата'].max()
                                    
                                    if min_date and max_date:
                                        date_from = st.date_input(
                                            "Дата начала:",
                                            value=min_date.date() if isinstance(min_date, pd.Timestamp) else min_date,
                                            min_value=min_date.date() if isinstance(min_date, pd.Timestamp) else min_date,
                                            max_value=max_date.date() if isinstance(max_date, pd.Timestamp) else max_date,
                                            key=f"date_from_{selected_combo_key}"
                                        )
                                    else:
                                        date_from = None
                                
                                with date_col2:
                                    if min_date and max_date:
                                        date_to = st.date_input(
                                            "Дата окончания:",
                                            value=max_date.date() if isinstance(max_date, pd.Timestamp) else max_date,
                                            min_value=min_date.date() if isinstance(min_date, pd.Timestamp) else min_date,
                                            max_value=max_date.date() if isinstance(max_date, pd.Timestamp) else max_date,
                                            key=f"date_to_{selected_combo_key}"
                                        )
                                    else:
                                        date_to = None
                                
                                # KPI для выбранного периода
                                if date_from and date_to and combo_report_key in st.session_state.get('combination_reports', {}):
                                    period_report_data = st.session_state['combination_reports'][combo_report_key]['data'].copy()
                                    if not period_report_data.empty and 'Дата' in period_report_data.columns:
                                        date_from_ts = pd.to_datetime(date_from)
                                        date_to_ts = pd.to_datetime(date_to)
                                        period_data = period_report_data[
                                            (period_report_data['Дата'] >= date_from_ts) & 
                                            (period_report_data['Дата'] <= date_to_ts)
                                        ].copy()
                                        
                                        if not period_data.empty:
                                            # Рассчитываем KPI для периода
                                            # Фильтруем только дни с продажами > 0
                                            period_sales_data = period_data[period_data['Продажи'] > 0].copy()
                                            
                                            if len(period_sales_data) > 0:
                                                # Группируем по дням и считаем среднее продаж в каждый день
                                                # Проверяем, есть ли колонка 'Артикул' (индивидуальные отчеты)
                                                if 'Артикул' in period_sales_data.columns:
                                                    # Для индивидуальных отчетов группируем по дате и считаем среднее по товарам
                                                    daily_sales = period_sales_data.groupby('Дата')['Продажи'].mean().reset_index()
                                                else:
                                                    # Для агрегированных данных просто берем продажи по дням
                                                    daily_sales = period_sales_data.groupby('Дата')['Продажи'].first().reset_index()
                                                
                                                # Средние продажи в день (среднее по дням)
                                                avg_sales_per_day = daily_sales['Продажи'].mean()
                                                
                                                # Максимальные и минимальные продажи (максимум среднего по дням)
                                                max_sales = daily_sales['Продажи'].max()
                                                min_sales = daily_sales['Продажи'].min()
                                                
                                                # Общие продажи (сумма средних по дням)
                                                total_sales = daily_sales['Продажи'].sum()
                                                
                                                days_with_sales = len(daily_sales)
                                                total_days = len(period_data)
                                                
                                                # Средний чек из базовой цены
                                                avg_check = base_price if base_price else 0
                                                
                                                # Выручка
                                                revenue = total_sales * avg_check if avg_check > 0 else 0
                                                
                                                # Рассчитываем рост/падение в процентах
                                                # Сравниваем с предыдущим периодом той же длительности
                                                period_duration = (date_to_ts - date_from_ts).days + 1
                                                prev_period_start = date_from_ts - pd.Timedelta(days=period_duration)
                                                prev_period_end = date_from_ts - pd.Timedelta(days=1)
                                                
                                                prev_period_data = period_report_data[
                                                    (period_report_data['Дата'] >= prev_period_start) & 
                                                    (period_report_data['Дата'] <= prev_period_end)
                                                ].copy()
                                                
                                                sales_growth = None
                                                avg_check_growth = None
                                                
                                                if not prev_period_data.empty:
                                                    prev_period_sales_data = prev_period_data[prev_period_data['Продажи'] > 0].copy()
                                                    if len(prev_period_sales_data) > 0:
                                                        prev_avg_sales_per_day = prev_period_sales_data['Продажи'].mean()
                                                        
                                                        if prev_avg_sales_per_day > 0:
                                                            sales_growth = ((avg_sales_per_day - prev_avg_sales_per_day) / prev_avg_sales_per_day) * 100
                                                        
                                                        # Средний чек предыдущего периода
                                                        if 'Средняя цена' in prev_period_sales_data.columns:
                                                            prev_avg_check = prev_period_sales_data['Средняя цена'].mean()
                                                        else:
                                                            prev_avg_check = base_price if base_price else 0
                                                        
                                                        if prev_avg_check > 0:
                                                            avg_check_growth = ((avg_check - prev_avg_check) / prev_avg_check) * 100
                                                
                                                # Отображаем KPI
                                                st.markdown("##### 📊 KPI за период")
                                                kpi_col1, kpi_col2, kpi_col3, kpi_col4 = st.columns(4)
                                                
                                                with kpi_col1:
                                                    # Получаем процент выкупа
                                                    buyout_pct_kpi = st.session_state.get("buyout_pct", 25)
                                                    buyout_k_kpi = buyout_pct_kpi / 100.0
                                                    
                                                    # Общие заказы (переименовано из "Общие продажи")
                                                    if sales_growth is not None:
                                                        st.metric("💰 Общие заказы", f"{total_sales:,.0f} шт", delta=f"{sales_growth:+.1f}%")
                                                    else:
                                                        st.metric("💰 Общие заказы", f"{total_sales:,.0f} шт")
                                                    
                                                    # Продажи с учетом процента выкупа
                                                    total_sold_kpi = total_sales * buyout_k_kpi
                                                    st.metric("💵 Продажи (с учетом выкупа)", f"{total_sold_kpi:,.0f} шт", 
                                                             help=f"Общие заказы ({total_sales:,.0f} шт) × процент выкупа ({buyout_pct_kpi}%)")
                                                    st.metric("📈 Средние продажи/день", f"{avg_sales_per_day:.1f} шт")
                                                
                                                with kpi_col2:
                                                    st.metric("💵 Выручка", f"{revenue:,.0f} ₽" if revenue > 0 else "—")
                                                
                                                with kpi_col3:
                                                    st.metric("⬆️ Макс. продажи/день", f"{max_sales:.1f} шт")
                                                    st.metric("⬇️ Мин. продажи/день", f"{min_sales:.1f} шт")
                                                
                                                with kpi_col4:
                                                    pass  # Оставляем пустым для симметрии
                                
                                # Настройки плана на следующий год (всегда видимый)
                                st.markdown("#### 🔮 План на следующий год")
                                growth_percent = st.number_input(
                                    "Процент роста на тренд, %:",
                                    min_value=-50.0,
                                    max_value=200.0,
                                    value=10.0,
                                    step=1.0,
                                    key=f"growth_percent_{selected_combo_key}",
                                    help="Процент роста относительно текущего тренда (может быть отрицательным)"
                                )
                                show_forecast = True  # Всегда показываем прогноз
                                # Получаем все загруженные отчеты для сравнения
                                all_reports = st.session_state.get('combination_reports', {})
                                
                                if len(all_reports) > 0:
                                    # Определяем, какие данные использовать
                                    if view_mode == "📦 Отдельный товар" and selected_sku_for_plan:
                                        # Для отдельного товара загружаем его отчет
                                        individual_report_key = f"report_{selected_sku_for_plan}"
                                        individual_report_data = None
                                        
                                        # Ищем отчет для этого товара в папке Tovar
                                        found_reports, _ = find_reports_with_missing((selected_sku_for_plan,), "Tovar")
                                        if found_reports and selected_sku_for_plan in found_reports:
                                            individual_report_data = found_reports[selected_sku_for_plan]['data'].copy()
                                        
                                        if individual_report_data is not None and not individual_report_data.empty:
                                            # Используем данные отдельного товара
                                            combined_df = individual_report_data.copy()
                                            combined_df['Комбинация'] = f"Товар {selected_sku_for_plan}"
                                        else:
                                            st.warning(f"⚠️ Не найден отчет для товара {selected_sku_for_plan} в папке Tovar")
                                            combined_df = pd.DataFrame()
                                    else:
                                        # Для комбинации загружаем отчеты для каждого товара отдельно
                                        # Это нужно для расчета среднего по дням только для товаров с продажами
                                        individual_reports = {}
                                        
                                        # Загружаем отчеты для всех товаров комбинации
                                        if combo_skus_list:
                                            found_reports, _ = find_reports_with_missing(tuple(combo_skus_list), "Tovar")
                                            for sku, report_info in found_reports.items():
                                                if 'data' in report_info:
                                                    individual_reports[sku] = report_info['data'].copy()
                                        
                                        if individual_reports:
                                            # Создаем объединенный DataFrame с указанием артикула
                                            all_reports_data = []
                                            for sku, report_data in individual_reports.items():
                                                data = report_data.copy()
                                                data['Артикул'] = sku
                                                all_reports_data.append(data)
                                            
                                            combined_df = pd.concat(all_reports_data, ignore_index=True)
                                        else:
                                            # Если нет индивидуальных отчетов, используем агрегированные данные
                                            comparison_data = []
                                            
                                            for report_key, report_info in all_reports.items():
                                                if report_info['combination'] == selected_combo_key:
                                                    data = report_info['data'].copy()
                                                    data['Комбинация'] = report_info['combination']
                                                    comparison_data.append(data)
                                            
                                            if comparison_data:
                                                combined_df = pd.concat(comparison_data, ignore_index=True)
                                            else:
                                                combined_df = pd.DataFrame()
                                    
                                    # Если нет данных, показываем сообщение
                                    if combined_df.empty:
                                        st.info("📊 Нет данных для построения графика. Загрузите отчеты для комбинации или выберите товар с доступными данными.")
                                    
                                    if not combined_df.empty:
                                        # Фильтруем данные по выбранному промежутку времени
                                        if date_from and date_to:
                                            date_from_ts = pd.to_datetime(date_from)
                                            date_to_ts = pd.to_datetime(date_to)
                                            combined_df = combined_df[
                                                (combined_df['Дата'] >= date_from_ts) & 
                                                (combined_df['Дата'] <= date_to_ts)
                                            ].copy()
                                        
                                        if combined_df.empty:
                                            st.warning("⚠️ Нет данных в выбранном периоде")
                                        else:
                                            # Находим общий период дат
                                            all_dates = combined_df['Дата'].unique()
                                            all_dates = sorted(all_dates)
                                            
                                            # Создаем полный диапазон дат
                                            if len(all_dates) > 1:
                                                date_range = pd.date_range(start=all_dates[0], end=all_dates[-1], freq='D')
                                            else:
                                                date_range = pd.date_range(start=all_dates[0], periods=30, freq='D')
                                            
                                            # Если включен прогноз на следующий год, расширяем диапазон дат
                                            forecast_date_range = None
                                            if show_forecast and len(all_dates) > 0:
                                                last_date = all_dates[-1]
                                                if isinstance(last_date, pd.Timestamp):
                                                    forecast_start = last_date + pd.Timedelta(days=1)
                                                    forecast_end = forecast_start + pd.DateOffset(years=1)
                                                    forecast_date_range = pd.date_range(start=forecast_start, end=forecast_end, freq='D')
                                            
                                            # Проверяем, есть ли данные с артикулами (индивидуальные отчеты)
                                            has_individual_reports = 'Артикул' in combined_df.columns
                                            
                                            # Получаем combo_products_df для расчета базовых цен
                                            combo_products_df = None
                                            if combo_report_key in st.session_state.get('combination_reports', {}):
                                                if 'combo_products_df' in st.session_state['combination_reports'][combo_report_key]:
                                                    combo_products_df = st.session_state['combination_reports'][combo_report_key]['combo_products_df']
                                            
                                            # Строим график с тремя вариантами
                                            fig = go.Figure()
                                            
                                            # Для каждой комбинации рассчитываем статистику
                                            for combo_name in combined_df['Комбинация'].unique() if 'Комбинация' in combined_df.columns else ['Комбинация']:
                                                if has_individual_reports:
                                                    # Работаем с индивидуальными отчетами товаров
                                                    combo_data = combined_df.copy()
                                                else:
                                                    combo_data = combined_df[combined_df['Комбинация'] == combo_name].copy() if 'Комбинация' in combined_df.columns else combined_df.copy()
                                                
                                                # Сортируем по дате
                                                combo_data = combo_data.sort_values('Дата')
                                                
                                                # Рассчитываем планы для каждого дня отдельно
                                                # Для каждого дня считаем среднее только по товарам с продажами > 0 в этот день
                                                
                                                # Рассчитываем планы для каждого дня на основе исторических данных
                                                low_plan_values = []
                                                mid_plan_values = []
                                                high_plan_values = []
                                                avg_check_values = []  # Средний чек для каждого дня
                                                actual_sales_by_date = []  # Фактические продажи по дням
                                                actual_dates_list = []  # Даты с фактическими данными
                                                
                                                # Таблица детализации по дням: дата, продажи каждого товара, среднее для каждого плана
                                                daily_plan_details = []  # Список словарей с данными по каждому дню
                                                
                                                # Параметр для расчета скользящего среднего (количество дней)
                                                # Собираем все дни с продажами для определения window_size
                                                all_days_with_sales = []
                                                for date in date_range:
                                                    if has_individual_reports:
                                                        # Для каждого дня берем только товары с продажами > 0
                                                        day_data = combo_data[
                                                            (combo_data['Дата'] == date) & 
                                                            (combo_data['Продажи'] > 0)
                                                        ]
                                                    else:
                                                        day_data = combo_data[
                                                            (combo_data['Дата'] == date) & 
                                                            (combo_data['Продажи'] > 0)
                                                        ]
                                                    
                                                    if len(day_data) > 0:
                                                        all_days_with_sales.append(date)
                                                
                                                window_size = min(30, len(all_days_with_sales)) if all_days_with_sales else 30
                                                
                                                # Собираем исторические данные для расчета тренда
                                                historical_daily_means = []  # Средние продажи по дням
                                                
                                                for idx, current_date in enumerate(date_range):
                                                    if has_individual_reports:
                                                        # Для каждого дня берем только товары с продажами > 0 в этот день
                                                        day_avg_check_no_spp = None
                                                        day_data = combo_data[
                                                            (combo_data['Дата'] == current_date) & 
                                                            (combo_data['Продажи'] > 0)
                                                        ]
                                                        
                                                        if len(day_data) > 0:
                                                            # Считаем среднее продаж только по товарам с продажами в этот день
                                                            day_sales_mean = day_data['Продажи'].mean()
                                                            historical_daily_means.append(day_sales_mean)
                                                            
                                                            # Средний чек по дню (с СПП и без СПП)
                                                            day_avg_check = None
                                                            day_avg_check_no_spp = None
                                                            price_columns_spp = ["Цена с СПП, ₽", "Цена с СПП", "Средняя цена"]
                                                            price_columns_no_spp = ["Средняя цена без СПП", "Базовая цена, ₽", "Базовая цена"]
                                                            for price_col in price_columns_spp:
                                                                if price_col in day_data.columns:
                                                                    price_values = day_data[price_col].dropna()
                                                                    price_values = price_values[price_values > 0]
                                                                    if len(price_values) > 0:
                                                                        day_avg_check = price_values.mean()
                                                                        break
                                                            for price_col in price_columns_no_spp:
                                                                if price_col in day_data.columns:
                                                                    price_values = day_data[price_col].dropna()
                                                                    price_values = price_values[price_values > 0]
                                                                    if len(price_values) > 0:
                                                                        day_avg_check_no_spp = price_values.mean()
                                                                        break
                                                            
                                                            actual_sales_by_date.append(day_sales_mean)
                                                            actual_dates_list.append(current_date)
                                                            avg_check_values.append(day_avg_check)
                                                        else:
                                                            # Для дней без продаж берем данные за этот день из combo_data (Tovar)
                                                            day_all_data = combo_data[combo_data['Дата'] == current_date]
                                                            day_avg_check = None
                                                            day_avg_check_no_spp = None
                                                            if len(day_all_data) > 0:
                                                                price_columns_spp = ["Цена с СПП, ₽", "Цена с СПП", "Средняя цена"]
                                                                price_columns_no_spp = ["Средняя цена без СПП", "Базовая цена, ₽", "Базовая цена"]
                                                                for price_col in price_columns_spp:
                                                                    if price_col in day_all_data.columns:
                                                                        price_values = day_all_data[price_col].dropna()
                                                                        price_values = price_values[price_values > 0]
                                                                        if len(price_values) > 0:
                                                                            day_avg_check = price_values.mean()
                                                                            break
                                                                for price_col in price_columns_no_spp:
                                                                    if price_col in day_all_data.columns:
                                                                        price_values = day_all_data[price_col].dropna()
                                                                        price_values = price_values[price_values > 0]
                                                                        if len(price_values) > 0:
                                                                            day_avg_check_no_spp = price_values.mean()
                                                                            break
                                                            avg_check_values.append(day_avg_check)
                                                    else:
                                                        # Для агрегированных данных
                                                        day_data = combo_data[
                                                            (combo_data['Дата'] == current_date) & 
                                                            (combo_data['Продажи'] > 0)
                                                        ]
                                                        
                                                        if len(day_data) > 0:
                                                            day_sales_mean = day_data['Продажи'].mean()
                                                            historical_daily_means.append(day_sales_mean)
                                                            
                                                            # Средний чек = средняя базовая цена из данных Tovar за этот день
                                                            day_avg_check = None
                                                            price_columns = ["Цена с СПП, ₽", "Цена с СПП", "Базовая цена, ₽", "Базовая цена", "Средняя цена"]
                                                            for price_col in price_columns:
                                                                if price_col in day_data.columns:
                                                                    price_values = day_data[price_col].dropna()
                                                                    price_values = price_values[price_values > 0]
                                                                    if len(price_values) > 0:
                                                                        day_avg_check = price_values.mean()
                                                                        break
                                                            
                                                            actual_sales_by_date.append(day_sales_mean)
                                                            actual_dates_list.append(current_date)
                                                            avg_check_values.append(day_avg_check)
                                                        else:
                                                            # Для дней без продаж берем данные за этот день из combo_data (Tovar)
                                                            day_all_data = combo_data[combo_data['Дата'] == current_date]
                                                            day_avg_check = None
                                                            if len(day_all_data) > 0:
                                                                price_columns = ["Цена с СПП, ₽", "Цена с СПП", "Базовая цена, ₽", "Базовая цена", "Средняя цена"]
                                                                for price_col in price_columns:
                                                                    if price_col in day_all_data.columns:
                                                                        price_values = day_all_data[price_col].dropna()
                                                                        price_values = price_values[price_values > 0]
                                                                        if len(price_values) > 0:
                                                                            day_avg_check = price_values.mean()
                                                                            break
                                                            avg_check_values.append(day_avg_check)
                                                    
                                                    # Рассчитываем планы для текущего дня на основе ранжирования товаров
                                                    if len(day_data) > 0 and has_individual_reports:
                                                        # Ранжируем товары по продажам в этот день
                                                        day_data_sorted = day_data.sort_values('Продажи', ascending=False)
                                                        
                                                        # Распределяем товары по планам примерно равными долями (по третям)
                                                        # Высокий план = лидеры (топ 33% товаров)
                                                        # Средний план = товары в центре (средние 33%)
                                                        # Низкий план = товары внизу (нижние 34%)
                                                        
                                                        total_products = len(day_data_sorted)
                                                        if total_products > 0:
                                                            # Высокий план - среднее топ 33% (или минимум 1 товар)
                                                            top_count = max(1, int(total_products / 3))
                                                            high_plan = day_data_sorted.head(top_count)['Продажи'].mean()
                                                            
                                                            # Средний план - среднее центральных 33%
                                                            mid_start = top_count
                                                            mid_end = mid_start + max(1, int(total_products / 3))
                                                            if mid_end > mid_start and mid_end <= total_products:
                                                                mid_plan = day_data_sorted.iloc[mid_start:mid_end]['Продажи'].mean()
                                                            else:
                                                                mid_plan = day_data_sorted.iloc[mid_start:]['Продажи'].mean() if mid_start < total_products else day_data_sorted['Продажи'].mean()
                                                            
                                                            # Низкий план - среднее нижних 34% (остаток)
                                                            low_start = mid_end if mid_end <= total_products else mid_start
                                                            low_plan = day_data_sorted.iloc[low_start:]['Продажи'].mean() if low_start < total_products else 0
                                                            
                                                            # Собираем данные для таблицы: продажи каждого товара
                                                            day_items_sales = {}
                                                            day_items_prices = {}  # Цены товаров для расчета планов по цене
                                                            
                                                            for item_idx, (_, row) in enumerate(day_data_sorted.iterrows()):
                                                                sku = str(row.get('Артикул', '')) if 'Артикул' in row and pd.notna(row.get('Артикул')) else f"Товар {item_idx + 1}"
                                                                sales = row['Продажи']
                                                                day_items_sales[sku] = sales
                                                                
                                                                # Получаем цену товара напрямую из row (данные Tovar)
                                                                price_columns = ["Цена с СПП, ₽", "Цена с СПП", "Базовая цена, ₽", "Базовая цена", "Средняя цена"]
                                                                for col_name in price_columns:
                                                                    if col_name in row.index:
                                                                        price_val = row[col_name]
                                                                        if pd.notna(price_val) and price_val > 0:
                                                                            day_items_prices[sku] = float(price_val)
                                                                            break
                                                            
                                                            # Рассчитываем планы по цене (низкий, средний, высокий) на основе ранжирования товаров по цене
                                                            low_price_plan = None
                                                            mid_price_plan = None
                                                            high_price_plan = None
                                                            
                                                            if len(day_items_prices) > 0:
                                                                # Сортируем товары по цене (от высокой к низкой)
                                                                sorted_prices = sorted(day_items_prices.items(), key=lambda x: x[1], reverse=True)
                                                                total_price_items = len(sorted_prices)
                                                                
                                                                if total_price_items > 0:
                                                                    # Высокий план цены - средняя цена топ 33% товаров (с высокой ценой)
                                                                    top_price_count = max(1, int(total_price_items / 3))
                                                                    high_price_values = [price for _, price in sorted_prices[:top_price_count]]
                                                                    high_price_plan = np.mean(high_price_values) if high_price_values else None
                                                                    
                                                                    # Средний план цены - средняя цена центральных 33%
                                                                    mid_price_start = top_price_count
                                                                    mid_price_end = mid_price_start + max(1, int(total_price_items / 3))
                                                                    if mid_price_end > mid_price_start and mid_price_end <= total_price_items:
                                                                        mid_price_values = [price for _, price in sorted_prices[mid_price_start:mid_price_end]]
                                                                    else:
                                                                        mid_price_values = [price for _, price in sorted_prices[mid_price_start:]]
                                                                    mid_price_plan = np.mean(mid_price_values) if mid_price_values else None
                                                                    
                                                                    # Низкий план цены - средняя цена нижних 34% (с низкой ценой)
                                                                    low_price_start = mid_price_end if mid_price_end <= total_price_items else mid_price_start
                                                                    low_price_values = [price for _, price in sorted_prices[low_price_start:]]
                                                                    low_price_plan = np.mean(low_price_values) if low_price_values else None
                                                            
                                                            # Если не удалось рассчитать планы по цене, используем общую среднюю цену
                                                            if low_price_plan is None or mid_price_plan is None or high_price_plan is None:
                                                                # Используем day_avg_check (средняя цена из данных Tovar за день)
                                                                avg_price_for_day = day_avg_check
                                                                
                                                                # Если нет, используем среднее из day_items_prices
                                                                if avg_price_for_day is None and len(day_items_prices) > 0:
                                                                    avg_price_for_day = np.mean(list(day_items_prices.values()))
                                                                
                                                                # Устанавливаем значения для всех планов
                                                                if avg_price_for_day is not None:
                                                                    if low_price_plan is None:
                                                                        low_price_plan = avg_price_for_day
                                                                    if mid_price_plan is None:
                                                                        mid_price_plan = avg_price_for_day
                                                                    if high_price_plan is None:
                                                                        high_price_plan = avg_price_for_day
                                                            
                                                            # Добавляем данные дня в таблицу
                                                            daily_plan_details.append({
                                                                'Дата': current_date,
                                                                'Низкий план (среднее)': low_plan,
                                                                'Средний план (среднее)': mid_plan,
                                                                'Высокий план (среднее)': high_plan,
                                                                'Низкий план цены': low_price_plan,
                                                                'Средний план цены': mid_price_plan,
                                                                'Высокий план цены': high_price_plan,
                                                                'Средняя цена': day_avg_check if day_avg_check is not None else None,
                                                                'Средняя цена без СПП': day_avg_check_no_spp if day_avg_check_no_spp is not None else None,
                                                                'Товары': day_items_sales
                                                            })
                                                        else:
                                                            low_plan = 0
                                                            mid_plan = 0
                                                            high_plan = 0
                                                            # Для дней без продаж используем общую среднюю цену для всех планов
                                                            avg_price_for_day = day_avg_check if day_avg_check is not None else None
                                                            daily_plan_details.append({
                                                                'Дата': current_date,
                                                                'Низкий план (среднее)': 0,
                                                                'Средний план (среднее)': 0,
                                                                'Высокий план (среднее)': 0,
                                                                'Низкий план цены': avg_price_for_day,
                                                                'Средний план цены': avg_price_for_day,
                                                                'Высокий план цены': avg_price_for_day,
                                                            'Средняя цена': day_avg_check if day_avg_check is not None else None,
                                                            'Средняя цена без СПП': day_avg_check_no_spp if day_avg_check_no_spp is not None else None,
                                                                'Товары': {}
                                                            })
                                                    elif len(historical_daily_means) > 0:
                                                        # Если нет индивидуальных данных, используем исторические средние
                                                        if len(historical_daily_means) >= window_size:
                                                            recent_data = historical_daily_means[-window_size:]
                                                        else:
                                                            recent_data = historical_daily_means
                                                        
                                                        # Для агрегированных данных используем статистику
                                                        sales_mean = np.mean(recent_data)
                                                        sales_std = np.std(recent_data) if len(recent_data) > 1 else 0
                                                        
                                                        low_plan = max(0, sales_mean - sales_std)
                                                        mid_plan = sales_mean
                                                        high_plan = sales_mean + sales_std
                                                        
                                                        # Для агрегированных данных используем общую среднюю цену для всех планов
                                                        avg_price_for_day = day_avg_check if day_avg_check is not None else None
                                                        avg_price_for_day_no_spp = day_avg_check_no_spp if day_avg_check_no_spp is not None else None
                                                        
                                                        # Если day_avg_check None, пробуем получить из combo_products_df
                                                        if avg_price_for_day is None and combo_products_df is not None and len(combo_products_df) > 0:
                                                            price_columns = ["Базовая цена", "базовая цена", "Базовая цена, ₽", "Средняя цена без СПП", "Средняя цена", "Цена", "цена"]
                                                            for col_name in price_columns:
                                                                if col_name in combo_products_df.columns:
                                                                    avg_price_for_day = combo_products_df[col_name].mean()
                                                                    if pd.notna(avg_price_for_day) and avg_price_for_day > 0:
                                                                        break
                                                            if "Средняя цена без СПП" in combo_products_df.columns:
                                                                avg_price_for_day_no_spp = combo_products_df["Средняя цена без СПП"].mean()
                                                        
                                                        avg_price_for_day_no_spp = None
                                                        if combo_products_df is not None and len(combo_products_df) > 0:
                                                            if "Средняя цена без СПП" in combo_products_df.columns:
                                                                avg_price_for_day_no_spp = combo_products_df["Средняя цена без СПП"].mean()
                                                        
                                                        # Добавляем данные дня в таблицу (для агрегированных данных)
                                                        daily_plan_details.append({
                                                            'Дата': current_date,
                                                            'Низкий план (среднее)': low_plan,
                                                            'Средний план (среднее)': mid_plan,
                                                            'Высокий план (среднее)': high_plan,
                                                            'Низкий план цены': avg_price_for_day,
                                                            'Средний план цены': avg_price_for_day,
                                                            'Высокий план цены': avg_price_for_day,
                                                            'Средняя цена': day_avg_check if day_avg_check is not None else avg_price_for_day,
                                                            'Средняя цена без СПП': day_avg_check_no_spp if day_avg_check_no_spp is not None else avg_price_for_day_no_spp,
                                                            'Товары': {}  # Нет данных по отдельным товарам
                                                        })
                                                    else:
                                                        # Если нет исторических данных
                                                        low_plan = 0
                                                        mid_plan = 0
                                                        high_plan = 0
                                                        
                                                        # Для дней без исторических данных используем общую среднюю цену для всех планов
                                                        avg_price_for_day = day_avg_check if day_avg_check is not None else None
                                                        avg_price_for_day_no_spp = (
                                                            day_avg_check_no_spp
                                                            if day_avg_check_no_spp is not None
                                                            else avg_price_for_day
                                                        )
                                                        
                                                        # Если day_avg_check None, пробуем получить из combo_products_df
                                                        if avg_price_for_day is None and combo_products_df is not None and len(combo_products_df) > 0:
                                                            price_columns = ["Базовая цена", "базовая цена", "Базовая цена, ₽", "Средняя цена без СПП", "Средняя цена", "Цена", "цена"]
                                                            for col_name in price_columns:
                                                                if col_name in combo_products_df.columns:
                                                                    avg_price_for_day = combo_products_df[col_name].mean()
                                                                    if pd.notna(avg_price_for_day) and avg_price_for_day > 0:
                                                                        break
                                                        
                                                        daily_plan_details.append({
                                                            'Дата': current_date,
                                                            'Низкий план (среднее)': 0,
                                                            'Средний план (среднее)': 0,
                                                            'Высокий план (среднее)': 0,
                                                            'Низкий план цены': avg_price_for_day,
                                                            'Средний план цены': avg_price_for_day,
                                                            'Высокий план цены': avg_price_for_day,
                                                            'Средняя цена': day_avg_check if day_avg_check is not None else avg_price_for_day,
                                                            'Средняя цена без СПП': day_avg_check_no_spp if day_avg_check_no_spp is not None else avg_price_for_day_no_spp,
                                                            'Товары': {}
                                                        })
                                                    
                                                    low_plan_values.append(low_plan)
                                                    mid_plan_values.append(mid_plan)
                                                    high_plan_values.append(high_plan)
                                                
                                                # Сохраняем планы для прогноза (нужно для дублирования на следующий год)
                                                historical_low_plans = []
                                                historical_mid_plans = []
                                                historical_high_plans = []
                                                
                                                # Пересчитываем планы для всех дней, чтобы сохранить их для прогноза
                                                for idx, current_date in enumerate(date_range):
                                                    if has_individual_reports:
                                                        day_data = combo_data[
                                                            (combo_data['Дата'] == current_date) & 
                                                            (combo_data['Продажи'] > 0)
                                                        ]
                                                        
                                                        if len(day_data) > 0:
                                                            day_data_sorted = day_data.sort_values('Продажи', ascending=False)
                                                            total_products = len(day_data_sorted)
                                                            if total_products > 0:
                                                                top_count = max(1, int(total_products * 0.25))
                                                                high_plan_val = day_data_sorted.head(top_count)['Продажи'].mean()
                                                                
                                                                mid_start = max(0, int(total_products * 0.25))
                                                                mid_end = min(total_products, int(total_products * 0.75))
                                                                if mid_end > mid_start:
                                                                    mid_plan_val = day_data_sorted.iloc[mid_start:mid_end]['Продажи'].mean()
                                                                else:
                                                                    mid_plan_val = day_data_sorted['Продажи'].mean()
                                                                
                                                                bottom_count = max(1, int(total_products * 0.25))
                                                                low_plan_val = day_data_sorted.tail(bottom_count)['Продажи'].mean()
                                                                
                                                                historical_low_plans.append(low_plan_val)
                                                                historical_mid_plans.append(mid_plan_val)
                                                                historical_high_plans.append(high_plan_val)
                                                            else:
                                                                historical_low_plans.append(0)
                                                                historical_mid_plans.append(0)
                                                                historical_high_plans.append(0)
                                                        else:
                                                            historical_low_plans.append(0)
                                                            historical_mid_plans.append(0)
                                                            historical_high_plans.append(0)
                                                    else:
                                                        # Для агрегированных данных используем уже рассчитанные планы
                                                        if idx < len(low_plan_values):
                                                            historical_low_plans.append(low_plan_values[idx])
                                                            historical_mid_plans.append(mid_plan_values[idx])
                                                            historical_high_plans.append(high_plan_values[idx])
                                                        else:
                                                            historical_low_plans.append(0)
                                                            historical_mid_plans.append(0)
                                                            historical_high_plans.append(0)
                                                
                                                # Добавляем линии плана (динамические по дням)
                                                fig.add_trace(go.Scatter(
                                                    x=date_range,
                                                    y=low_plan_values,
                                                    mode='lines',
                                                    name=f'{combo_name} - Низкий план',
                                                    line=dict(color='red', width=2),
                                                    hovertemplate='Дата: %{x|%d.%m.%Y}<br>Низкий план: %{y:.1f}<extra></extra>'
                                                ))
                                                
                                                fig.add_trace(go.Scatter(
                                                    x=date_range,
                                                    y=mid_plan_values,
                                                    mode='lines',
                                                    name=f'{combo_name} - Средний план',
                                                    line=dict(color='orange', width=2),
                                                    hovertemplate='Дата: %{x|%d.%m.%Y}<br>Средний план: %{y:.1f}<extra></extra>'
                                                ))
                                                
                                                fig.add_trace(go.Scatter(
                                                    x=date_range,
                                                    y=high_plan_values,
                                                    mode='lines',
                                                    name=f'{combo_name} - Высокий план',
                                                    line=dict(color='green', width=2),
                                                    hovertemplate='Дата: %{x|%d.%m.%Y}<br>Высокий план: %{y:.1f}<extra></extra>'
                                                ))
                                                
                                                # Добавляем среднюю цену на график (вторая ось Y)
                                                if avg_check_values and any(v is not None and pd.notna(v) for v in avg_check_values):
                                                    # Фильтруем значения для дат, где есть данные
                                                    avg_check_dates = []
                                                    avg_check_prices = []
                                                    for i, date_val in enumerate(date_range):
                                                        if i < len(avg_check_values) and avg_check_values[i] is not None and pd.notna(avg_check_values[i]):
                                                            avg_check_dates.append(date_val)
                                                            avg_check_prices.append(avg_check_values[i])
                                                    
                                                    if len(avg_check_prices) > 0:
                                                        fig.add_trace(go.Scatter(
                                                            x=avg_check_dates,
                                                            y=avg_check_prices,
                                                            mode='lines+markers',
                                                            name='Средняя цена, ₽',
                                                            line=dict(color='purple', width=2),
                                                            yaxis='y2',
                                                            hovertemplate='Дата: %{x|%d.%m.%Y}<br>Средняя цена: %{y:.2f} ₽<extra></extra>'
                                                        ))
                                                
                                                # Добавляем фактические данные (если есть)
                                                if len(actual_dates_list) > 0:
                                                    fig.add_trace(go.Scatter(
                                                        x=actual_dates_list,
                                                        y=actual_sales_by_date,
                                                        mode='lines+markers',
                                                        name=f'{combo_name} - Факт',
                                                        line=dict(color='blue', width=2),
                                                        marker=dict(size=6),
                                                        hovertemplate='Дата: %{x|%d.%m.%Y}<br>Продажи (факт): %{y:.1f}<extra></extra>',
                                                        connectgaps=False,  # Не соединять пропуски
                                                        yaxis='y'  # Основная ось Y
                                                    ))
                                                
                                                # Прогноз на следующий год будет в отдельном графике (см. ниже)
                                            
                                            # Настройка графика
                                            layout_updates = {
                                                'title': 'План продаж: Низкий, Средний, Высокий варианты',
                                                'xaxis_title': 'Дата',
                                                'yaxis_title': 'Продажи, шт',
                                                'hovermode': 'x unified',
                                                'height': 600,
                                                'legend': dict(
                                                    orientation="v",
                                                    yanchor="top",
                                                    y=1,
                                                    xanchor="left",
                                                    x=1.01
                                                )
                                            }
                                            
                                            # Добавляем вторую ось Y для средней цены, если она есть на графике
                                            if avg_check_values and any(v is not None and pd.notna(v) for v in avg_check_values):
                                                layout_updates['yaxis2'] = dict(
                                                    title='Средняя цена, ₽',
                                                    overlaying='y',
                                                    side='right'
                                                )
                                            
                                            fig.update_layout(**layout_updates)
                                            
                                            st.plotly_chart(fig, use_container_width=True, key=f"sales_plan_chart_{selected_combo_key}")
                                            
                                            # График 1: План на загруженный период (без роста, сухие данные)
                                            if show_forecast and date_from and date_to and len(historical_daily_means) > 0:
                                                st.markdown("#### 🔮 План на загруженный период")
                                                
                                                # Создаем диапазон дат для загруженного периода
                                                loaded_period_date_range = pd.date_range(start=date_from, end=date_to, freq='D')
                                                
                                                # Создаем график для загруженного периода (без роста)
                                                fig_loaded_period = go.Figure()
                                                
                                                # Берем планы для загруженного периода без роста (сухие данные)
                                                loaded_low_values = []
                                                loaded_mid_values = []
                                                loaded_high_values = []
                                                loaded_avg_check_values = []
                                                
                                                # Для каждого дня в загруженном периоде берем соответствующий день из date_range
                                                for i, loaded_date in enumerate(loaded_period_date_range):
                                                    # Находим индекс в date_range, который соответствует этому дню
                                                    # Если загруженный период короче date_range, берем соответствующий день
                                                    # Если длиннее, циклически повторяем
                                                    date_idx = i % len(low_plan_values) if len(low_plan_values) > 0 else 0
                                                    
                                                    # Берем планы без роста (сухие данные)
                                                    loaded_low = low_plan_values[date_idx] if date_idx < len(low_plan_values) else (low_plan_values[-1] if low_plan_values else 0)
                                                    loaded_mid = mid_plan_values[date_idx] if date_idx < len(mid_plan_values) else (mid_plan_values[-1] if mid_plan_values else 0)
                                                    loaded_high = high_plan_values[date_idx] if date_idx < len(high_plan_values) else (high_plan_values[-1] if high_plan_values else 0)
                                                    
                                                    loaded_low_values.append(loaded_low)
                                                    loaded_mid_values.append(loaded_mid)
                                                    loaded_high_values.append(loaded_high)
                                                    
                                                    # Средний чек
                                                    if date_idx < len(avg_check_values) and avg_check_values[date_idx] is not None:
                                                        loaded_avg_check_values.append(avg_check_values[date_idx])
                                                    else:
                                                        loaded_avg_check_values.append(None)
                                                
                                                # Добавляем линии плана на загруженный период (без роста)
                                                fig_loaded_period.add_trace(go.Scatter(
                                                    x=loaded_period_date_range,
                                                    y=loaded_low_values,
                                                    mode='lines',
                                                    name=f'{combo_name} - Низкий план',
                                                    line=dict(color='red', width=2),
                                                    hovertemplate='Дата: %{x|%d.%m.%Y}<br>Низкий план: %{y:.1f}<extra></extra>'
                                                ))
                                                
                                                fig_loaded_period.add_trace(go.Scatter(
                                                    x=loaded_period_date_range,
                                                    y=loaded_mid_values,
                                                    mode='lines',
                                                    name=f'{combo_name} - Средний план',
                                                    line=dict(color='orange', width=2),
                                                    hovertemplate='Дата: %{x|%d.%m.%Y}<br>Средний план: %{y:.1f}<extra></extra>'
                                                ))
                                                
                                                fig_loaded_period.add_trace(go.Scatter(
                                                    x=loaded_period_date_range,
                                                    y=loaded_high_values,
                                                    mode='lines',
                                                    name=f'{combo_name} - Высокий план',
                                                    line=dict(color='green', width=2),
                                                    hovertemplate='Дата: %{x|%d.%m.%Y}<br>Высокий план: %{y:.1f}<extra></extra>'
                                                ))
                                                
                                                # Добавляем среднюю цену, если есть
                                                if loaded_avg_check_values and any(v is not None and pd.notna(v) for v in loaded_avg_check_values):
                                                    loaded_avg_check_dates = []
                                                    loaded_avg_check_prices = []
                                                    for i, date_val in enumerate(loaded_period_date_range):
                                                        if i < len(loaded_avg_check_values) and loaded_avg_check_values[i] is not None and pd.notna(loaded_avg_check_values[i]):
                                                            loaded_avg_check_dates.append(date_val)
                                                            loaded_avg_check_prices.append(loaded_avg_check_values[i])
                                                    
                                                    if len(loaded_avg_check_prices) > 0:
                                                        fig_loaded_period.add_trace(go.Scatter(
                                                            x=loaded_avg_check_dates,
                                                            y=loaded_avg_check_prices,
                                                            mode='lines+markers',
                                                            name='Средняя цена, ₽',
                                                            line=dict(color='purple', width=2),
                                                            yaxis='y2',
                                                            hovertemplate='Дата: %{x|%d.%m.%Y}<br>Средняя цена: %{y:.2f} ₽<extra></extra>'
                                                        ))
                                                
                                                # Настройка графика загруженного периода
                                                date_from_str = date_from.strftime("%d.%m.%Y")
                                                date_to_str = date_to.strftime("%d.%m.%Y")
                                                loaded_period_layout = {
                                                    'title': f'План на загруженный период ({date_from_str} - {date_to_str})',
                                                    'xaxis_title': 'Дата',
                                                    'yaxis_title': 'Продажи, шт',
                                                    'hovermode': 'x unified',
                                                    'height': 600,
                                                    'legend': dict(
                                                        orientation="v",
                                                        yanchor="top",
                                                        y=1,
                                                        xanchor="left",
                                                        x=1.01
                                                    )
                                                }
                                                
                                                # Добавляем вторую ось Y для средней цены, если она есть
                                                if loaded_avg_check_values and any(v is not None and pd.notna(v) for v in loaded_avg_check_values):
                                                    loaded_period_layout['yaxis2'] = dict(
                                                        title='Средняя цена, ₽',
                                                        overlaying='y',
                                                        side='right'
                                                    )
                                                
                                                fig_loaded_period.update_layout(**loaded_period_layout)
                                                
                                                st.plotly_chart(fig_loaded_period, use_container_width=True, key=f"loaded_period_chart_{selected_combo_key}")
                                            
                                            # График 2: План на следующий год (с ростом тренда)
                                            if show_forecast and forecast_date_range is not None and len(low_plan_values) > 0:
                                                st.markdown("#### 🔮 План на следующий год")
                                                
                                                # Создаем отдельный график для прогноза на следующий год с ростом
                                                fig_forecast = go.Figure()
                                                
                                                # Рассчитываем прогнозные значения с учетом процента роста
                                                growth_factor = 1 + (growth_percent / 100.0)
                                                
                                                # Дублируем данные предыдущего года день за днем с учетом роста
                                                forecast_low_values = []
                                                forecast_mid_values = []
                                                forecast_high_values = []
                                                forecast_avg_check_values = []
                                                
                                                # Получаем средние чеки предыдущего года
                                                previous_year_avg_checks = [v for v in avg_check_values if v is not None]
                                                
                                                # Для каждого дня в прогнозе берем соответствующий день предыдущего года
                                                for i, forecast_date in enumerate(forecast_date_range):
                                                    # Используем индекс по порядку дней (циклически повторяем данные предыдущего года)
                                                    prev_year_idx = i % len(low_plan_values) if len(low_plan_values) > 0 else 0
                                                    
                                                    # Берем планы из предыдущего года
                                                    prev_year_low = low_plan_values[prev_year_idx] if prev_year_idx < len(low_plan_values) else (low_plan_values[-1] if low_plan_values else 0)
                                                    prev_year_mid = mid_plan_values[prev_year_idx] if prev_year_idx < len(mid_plan_values) else (mid_plan_values[-1] if mid_plan_values else 0)
                                                    prev_year_high = high_plan_values[prev_year_idx] if prev_year_idx < len(high_plan_values) else (high_plan_values[-1] if high_plan_values else 0)
                                                    
                                                    # Применяем рост тренда к каждому плану
                                                    forecast_low = max(0, prev_year_low * growth_factor)
                                                    forecast_mid = max(0, prev_year_mid * growth_factor)
                                                    forecast_high = max(0, prev_year_high * growth_factor)
                                                    
                                                    forecast_low_values.append(forecast_low)
                                                    forecast_mid_values.append(forecast_mid)
                                                    forecast_high_values.append(forecast_high)
                                                    
                                                    # Средний чек для соответствующего дня предыдущего года
                                                    check_idx = i % len(previous_year_avg_checks) if len(previous_year_avg_checks) > 0 else 0
                                                    if check_idx < len(previous_year_avg_checks):
                                                        prev_year_avg_check = previous_year_avg_checks[check_idx]
                                                    else:
                                                        prev_year_avg_check = previous_year_avg_checks[-1] if previous_year_avg_checks else None
                                                    
                                                    forecast_avg_check_values.append(prev_year_avg_check)
                                                
                                                # Добавляем линии плана на следующий год (с ростом)
                                                fig_forecast.add_trace(go.Scatter(
                                                    x=forecast_date_range,
                                                    y=forecast_low_values,
                                                    mode='lines',
                                                    name=f'{combo_name} - Низкий план',
                                                    line=dict(color='red', width=2),
                                                    hovertemplate='Дата: %{x|%d.%m.%Y}<br>Низкий план: %{y:.0f}<extra></extra>'
                                                ))
                                                
                                                fig_forecast.add_trace(go.Scatter(
                                                    x=forecast_date_range,
                                                    y=forecast_mid_values,
                                                    mode='lines',
                                                    name=f'{combo_name} - Средний план',
                                                    line=dict(color='orange', width=2),
                                                    hovertemplate='Дата: %{x|%d.%m.%Y}<br>Средний план: %{y:.0f}<extra></extra>'
                                                ))
                                                
                                                fig_forecast.add_trace(go.Scatter(
                                                    x=forecast_date_range,
                                                    y=forecast_high_values,
                                                    mode='lines',
                                                    name=f'{combo_name} - Высокий план',
                                                    line=dict(color='green', width=2),
                                                    hovertemplate='Дата: %{x|%d.%m.%Y}<br>Высокий план: %{y:.0f}<extra></extra>'
                                                ))
                                                
                                                # Добавляем среднюю цену, если есть
                                                if forecast_avg_check_values and any(v is not None and pd.notna(v) for v in forecast_avg_check_values):
                                                    forecast_avg_check_dates = []
                                                    forecast_avg_check_prices = []
                                                    for i, date_val in enumerate(forecast_date_range):
                                                        if i < len(forecast_avg_check_values) and forecast_avg_check_values[i] is not None and pd.notna(forecast_avg_check_values[i]):
                                                            forecast_avg_check_dates.append(date_val)
                                                            forecast_avg_check_prices.append(forecast_avg_check_values[i])
                                                    
                                                    if len(forecast_avg_check_prices) > 0:
                                                        fig_forecast.add_trace(go.Scatter(
                                                            x=forecast_avg_check_dates,
                                                            y=forecast_avg_check_prices,
                                                            mode='lines+markers',
                                                            name='Средняя цена, ₽',
                                                            line=dict(color='purple', width=2),
                                                            yaxis='y2',
                                                            hovertemplate='Дата: %{x|%d.%m.%Y}<br>Средняя цена: %{y:.2f} ₽<extra></extra>'
                                                        ))
                                                
                                                # Настройка графика прогноза на следующий год
                                                forecast_layout = {
                                                    'title': f'План продаж на следующий год (рост {growth_percent:.1f}%)',
                                                    'xaxis_title': 'Дата',
                                                    'yaxis_title': 'Продажи, шт',
                                                    'hovermode': 'x unified',
                                                    'height': 600,
                                                    'legend': dict(
                                                        orientation="v",
                                                        yanchor="top",
                                                        y=1,
                                                        xanchor="left",
                                                        x=1.01
                                                    )
                                                }
                                                
                                                # Добавляем вторую ось Y для средней цены, если она есть
                                                if forecast_avg_check_values and any(v is not None and pd.notna(v) for v in forecast_avg_check_values):
                                                    forecast_layout['yaxis2'] = dict(
                                                        title='Средняя цена, ₽',
                                                        overlaying='y',
                                                        side='right'
                                                    )
                                                
                                                fig_forecast.update_layout(**forecast_layout)
                                                
                                                st.plotly_chart(fig_forecast, use_container_width=True, key=f"forecast_chart_{selected_combo_key}")
                                            
                                            # Таблица детализации по дням
                                            if len(daily_plan_details) > 0:
                                                st.markdown("---")
                                                st.markdown("#### 📋 Детализация планов по дням")
                                                
                                                # Галочка для отображения таблицы с учетом тренда
                                                show_table_with_trend = st.checkbox(
                                                    "Показать таблицу с учетом роста тренда",
                                                    value=False,
                                                    key=f"show_table_trend_{selected_combo_key}",
                                                    help="Если включено, таблица будет включать данные следующего года с учетом роста тренда"
                                                )
                                                
                                                # Формируем DataFrame для таблицы
                                                table_data = []
                                                all_skus = set()
                                                
                                                # Выбираем данные для таблицы (с трендом или без)
                                                if show_table_with_trend:
                                                    # Получаем combined_plan_details из session_state (он всегда должен быть там сохранен)
                                                    plan_table_key = f'plan_details_table_{selected_combo_key}'
                                                    if plan_table_key in st.session_state and len(st.session_state[plan_table_key]) > 0:
                                                        table_source = st.session_state[plan_table_key]
                                                    else:
                                                        # Если нет в session_state, используем daily_plan_details
                                                        table_source = daily_plan_details
                                                else:
                                                    table_source = daily_plan_details
                                                
                                                # Собираем все уникальные артикулы
                                                for day_detail in table_source:
                                                    all_skus.update(day_detail.get('Товары', {}).keys())
                                                
                                                # Сортируем артикулы для стабильного порядка
                                                sorted_skus = sorted(list(all_skus))
                                                
                                                # Формируем строки таблицы
                                                for day_detail in table_source:
                                                    # Получаем цены по планам
                                                    low_price_plan = day_detail.get('Низкий план цены')
                                                    mid_price_plan = day_detail.get('Средний план цены')
                                                    high_price_plan = day_detail.get('Высокий план цены')
                                                    
                                                    # Используем fallback на 'Средняя цена', если планы по цене None
                                                    if low_price_plan is None:
                                                        low_price_plan = day_detail.get('Средняя цена')
                                                    if mid_price_plan is None:
                                                        mid_price_plan = day_detail.get('Средняя цена')
                                                    if high_price_plan is None:
                                                        high_price_plan = day_detail.get('Средняя цена')
                                                    
                                                    row = {
                                                        'Дата': day_detail['Дата'].strftime('%d.%m.%Y') if hasattr(day_detail['Дата'], 'strftime') else str(day_detail['Дата']),
                                                        'Низкий план (среднее)': f"{day_detail['Низкий план (среднее)']:.1f}",
                                                        'Низкий план (средняя цена), ₽': f"{low_price_plan:.2f}" if low_price_plan is not None and pd.notna(low_price_plan) else "—",
                                                        'Средний план (среднее)': f"{day_detail['Средний план (среднее)']:.1f}",
                                                        'Средний план (средняя цена), ₽': f"{mid_price_plan:.2f}" if mid_price_plan is not None and pd.notna(mid_price_plan) else "—",
                                                        'Высокий план (среднее)': f"{day_detail['Высокий план (среднее)']:.1f}",
                                                        'Высокий план (средняя цена), ₽': f"{high_price_plan:.2f}" if high_price_plan is not None and pd.notna(high_price_plan) else "—"
                                                    }
                                                    
                                                    # Добавляем продажи каждого товара
                                                    for sku in sorted_skus:
                                                        sales = day_detail.get('Товары', {}).get(sku, 0)
                                                        row[sku] = f"{sales:.1f}" if sales > 0 else "0"
                                                    
                                                    table_data.append(row)
                                                
                                                # Создаем DataFrame
                                                plan_details_df = pd.DataFrame(table_data)
                                                
                                                # Отображаем таблицу (только для загруженного периода, без роста)
                                                st.dataframe(plan_details_df, use_container_width=True, hide_index=True)
                                                
                                                # График цены (низкий, средний, высокий план)
                                                if len(daily_plan_details) > 0:
                                                    st.markdown("#### 💰 График средней цены по планам")
                                                    
                                                    # Собираем данные для графика цены
                                                    price_dates = []
                                                    price_low_values = []
                                                    price_mid_values = []
                                                    price_high_values = []
                                                    
                                                    for day_detail in daily_plan_details:
                                                        price_dates.append(day_detail['Дата'])
                                                        low_price = day_detail.get('Низкий план цены')
                                                        mid_price = day_detail.get('Средний план цены')
                                                        high_price = day_detail.get('Высокий план цены')
                                                        
                                                        # Используем fallback на 'Средняя цена', если планы по цене None
                                                        if low_price is None:
                                                            low_price = day_detail.get('Средняя цена')
                                                        if mid_price is None:
                                                            mid_price = day_detail.get('Средняя цена')
                                                        if high_price is None:
                                                            high_price = day_detail.get('Средняя цена')
                                                        
                                                        price_low_values.append(low_price if low_price is not None and pd.notna(low_price) else None)
                                                        price_mid_values.append(mid_price if mid_price is not None and pd.notna(mid_price) else None)
                                                        price_high_values.append(high_price if high_price is not None and pd.notna(high_price) else None)
                                                    
                                                    # Создаем график цены
                                                    fig_price = go.Figure()
                                                    
                                                    # Фильтруем значения для отображения (убираем None)
                                                    price_low_filtered = [(d, v) for d, v in zip(price_dates, price_low_values) if v is not None]
                                                    price_mid_filtered = [(d, v) for d, v in zip(price_dates, price_mid_values) if v is not None]
                                                    price_high_filtered = [(d, v) for d, v in zip(price_dates, price_high_values) if v is not None]
                                                    
                                                    if price_low_filtered:
                                                        dates_low, values_low = zip(*price_low_filtered)
                                                        fig_price.add_trace(go.Scatter(
                                                            x=list(dates_low),
                                                            y=list(values_low),
                                                            mode='lines',
                                                            name='Низкий план цены',
                                                            line=dict(color='red', width=2),
                                                            hovertemplate='Дата: %{x|%d.%m.%Y}<br>Низкий план цены: %{y:.2f} ₽<extra></extra>'
                                                        ))
                                                    
                                                    if price_mid_filtered:
                                                        dates_mid, values_mid = zip(*price_mid_filtered)
                                                        fig_price.add_trace(go.Scatter(
                                                            x=list(dates_mid),
                                                            y=list(values_mid),
                                                            mode='lines',
                                                            name='Средний план цены',
                                                            line=dict(color='orange', width=2),
                                                            hovertemplate='Дата: %{x|%d.%m.%Y}<br>Средний план цены: %{y:.2f} ₽<extra></extra>'
                                                        ))
                                                    
                                                    if price_high_filtered:
                                                        dates_high, values_high = zip(*price_high_filtered)
                                                        fig_price.add_trace(go.Scatter(
                                                            x=list(dates_high),
                                                            y=list(values_high),
                                                            mode='lines',
                                                            name='Высокий план цены',
                                                            line=dict(color='green', width=2),
                                                            hovertemplate='Дата: %{x|%d.%m.%Y}<br>Высокий план цены: %{y:.2f} ₽<extra></extra>'
                                                        ))
                                                    
                                                    # Настройка графика цены
                                                    price_layout = {
                                                        'title': 'Средняя цена по планам (низкий, средний, высокий)',
                                                        'xaxis_title': 'Дата',
                                                        'yaxis_title': 'Цена, ₽',
                                                        'hovermode': 'x unified',
                                                        'height': 600,
                                                        'legend': dict(
                                                            orientation="v",
                                                            yanchor="top",
                                                            y=1,
                                                            xanchor="left",
                                                            x=1.01
                                                        )
                                                    }
                                                    
                                                    fig_price.update_layout(**price_layout)
                                                    
                                                    st.plotly_chart(fig_price, use_container_width=True, key=f"price_chart_{selected_combo_key}")
                                                
                                                # Создаем таблицу планов для 2026 года с учетом роста тренда
                                                forecast_plan_details = []
                                                
                                                # Определяем forecast_date_range, если он еще не определен
                                                if 'forecast_date_range' not in locals() or forecast_date_range is None:
                                                    if len(date_range) > 0:
                                                        last_date = date_range[-1]
                                                        if isinstance(last_date, pd.Timestamp):
                                                            forecast_start = last_date + pd.Timedelta(days=1)
                                                            forecast_end = forecast_start + pd.DateOffset(years=1)
                                                            forecast_date_range = pd.date_range(start=forecast_start, end=forecast_end, freq='D')
                                                
                                                # Проверяем, есть ли данные для прогноза
                                                if show_forecast and forecast_date_range is not None and len(daily_plan_details) > 0:
                                                    # Получаем процент роста
                                                    growth_factor = 1 + (growth_percent / 100.0)
                                                    
                                                    # Создаем таблицу планов для 2026 года, дублируя структуру текущего года
                                                    for i, forecast_date in enumerate(forecast_date_range):
                                                        # Используем индекс по порядку дней (циклически повторяем данные предыдущего года)
                                                        prev_year_idx = i % len(daily_plan_details) if len(daily_plan_details) > 0 else 0
                                                        
                                                        if prev_year_idx < len(daily_plan_details):
                                                            prev_day_detail = daily_plan_details[prev_year_idx]
                                                            
                                                            # Применяем рост тренда к планам
                                                            forecast_low_plan = max(0, prev_day_detail['Низкий план (среднее)'] * growth_factor)
                                                            forecast_mid_plan = max(0, prev_day_detail['Средний план (среднее)'] * growth_factor)
                                                            forecast_high_plan = max(0, prev_day_detail['Высокий план (среднее)'] * growth_factor)
                                                            
                                                            # Применяем рост к продажам каждого товара
                                                            forecast_items = {}
                                                            for sku, sales in prev_day_detail['Товары'].items():
                                                                forecast_items[sku] = max(0, sales * growth_factor)
                                                            
                                                            # Получаем цены из исходного дня (цены не меняются при росте)
                                                            prev_low_price = prev_day_detail.get('Низкий план цены')
                                                            prev_mid_price = prev_day_detail.get('Средний план цены')
                                                            prev_high_price = prev_day_detail.get('Высокий план цены')
                                                            prev_avg_price = prev_day_detail.get('Средняя цена')
                                                            
                                                            # Добавляем день в таблицу прогноза
                                                            forecast_plan_details.append({
                                                                'Дата': forecast_date,
                                                                'Низкий план (среднее)': forecast_low_plan,
                                                                'Средний план (среднее)': forecast_mid_plan,
                                                                'Высокий план (среднее)': forecast_high_plan,
                                                                'Низкий план цены': prev_low_price,
                                                                'Средний план цены': prev_mid_price,
                                                                'Высокий план цены': prev_high_price,
                                                                'Средняя цена': prev_avg_price,
                                                                'Товары': forecast_items
                                                            })
                                                
                                                # Объединяем таблицы текущего года и прогноза на 2026 год
                                                combined_plan_details = daily_plan_details.copy()
                                                combined_plan_details.extend(forecast_plan_details)
                                                
                                                # Сохраняем объединенную таблицу в session_state для использования во вкладке "Расчет заказа" и в таблице детализации
                                                st.session_state[f'plan_details_table_{selected_combo_key}'] = combined_plan_details
                                            else:
                                                # Если нет прогноза, используем только daily_plan_details, но все равно сохраняем в session_state
                                                combined_plan_details = daily_plan_details.copy()
                                                st.session_state[f'plan_details_table_{selected_combo_key}'] = combined_plan_details
                                            
                                            # Общий KPI после графиков
                                            st.markdown("---")
                                            st.markdown("#### 📊 Общие KPI")
                                            
                                            # Рассчитываем общие KPI на основе всех данных
                                            if len(actual_sales_by_date) > 0:
                                                total_sales_all = sum(actual_sales_by_date)
                                                avg_sales_per_day_all = np.mean(actual_sales_by_date)
                                                days_with_sales_all = len(actual_sales_by_date)
                                                total_days_all = len(date_range)
                                                
                                                # Средний чек из базовой цены
                                                avg_check_all = base_price if base_price else 0
                                                
                                                # Выручка
                                                revenue_all = total_sales_all * avg_check_all if avg_check_all > 0 else 0
                                                
                                                # Максимальные и минимальные продажи (среднее по товарам в день)
                                                max_sales_all = max(actual_sales_by_date) if actual_sales_by_date else 0
                                                min_sales_all = min(actual_sales_by_date) if actual_sales_by_date else 0
                                                
                                                # Планы (средние значения)
                                                avg_low_plan = np.mean([v for v in low_plan_values if v > 0]) if any(v > 0 for v in low_plan_values) else 0
                                                avg_mid_plan = np.mean([v for v in mid_plan_values if v > 0]) if any(v > 0 for v in mid_plan_values) else 0
                                                avg_high_plan = np.mean([v for v in high_plan_values if v > 0]) if any(v > 0 for v in high_plan_values) else 0
                                                
                                                # Рассчитываем рост/падение в процентах для общих KPI
                                                # Сравниваем первую и вторую половину периода
                                                if len(actual_sales_by_date) > 1:
                                                    mid_point = len(actual_sales_by_date) // 2
                                                    first_half_sales = actual_sales_by_date[:mid_point]
                                                    second_half_sales = actual_sales_by_date[mid_point:]
                                                    
                                                    first_half_avg = np.mean(first_half_sales) if len(first_half_sales) > 0 else 0
                                                    second_half_avg = np.mean(second_half_sales) if len(second_half_sales) > 0 else 0
                                                    
                                                    sales_growth_all = None
                                                    if first_half_avg > 0:
                                                        sales_growth_all = ((second_half_avg - first_half_avg) / first_half_avg) * 100
                                                    
                                                    # Средний чек для первой и второй половины
                                                    first_half_checks = [avg_check_values[i] for i in range(len(avg_check_values)) if i < mid_point and avg_check_values[i] is not None]
                                                    second_half_checks = [avg_check_values[i] for i in range(len(avg_check_values)) if i >= mid_point and avg_check_values[i] is not None]
                                                    
                                                    first_half_avg_check = np.mean(first_half_checks) if len(first_half_checks) > 0 else avg_check_all
                                                    second_half_avg_check = np.mean(second_half_checks) if len(second_half_checks) > 0 else avg_check_all
                                                    
                                                    avg_check_growth_all = None
                                                    if first_half_avg_check > 0:
                                                        avg_check_growth_all = ((second_half_avg_check - first_half_avg_check) / first_half_avg_check) * 100
                                                else:
                                                    sales_growth_all = None
                                                    avg_check_growth_all = None
                                                
                                                # Отображаем общие KPI
                                                kpi_all_col1, kpi_all_col2, kpi_all_col3, kpi_all_col4 = st.columns(4)
                                                
                                                with kpi_all_col1:
                                                    if sales_growth_all is not None:
                                                        st.metric("💰 Общие продажи", f"{total_sales_all:,.0f} шт", delta=f"{sales_growth_all:+.1f}%")
                                                    else:
                                                        st.metric("💰 Общие продажи", f"{total_sales_all:,.0f} шт")
                                                    st.metric("📈 Средние продажи/день", f"{avg_sales_per_day_all:.1f} шт")
                                                
                                                with kpi_all_col2:
                                                    st.metric("💵 Общая выручка", f"{revenue_all:,.0f} ₽" if revenue_all > 0 else "—")
                                                
                                                with kpi_all_col3:
                                                    st.metric("⬆️ Макс. продажи/день", f"{max_sales_all:.1f} шт")
                                                    st.metric("⬇️ Мин. продажи/день", f"{min_sales_all:.1f} шт")
                                                    st.metric("📊 Средний низкий план", f"{avg_low_plan:.1f} шт")
                                                
                                                with kpi_all_col4:
                                                    st.metric("📊 Средний план", f"{avg_mid_plan:.1f} шт")
                                                    st.metric("📊 Средний высокий план", f"{avg_high_plan:.1f} шт")
                                            else:
                                                # Если нет данных о продажах, пропускаем эту комбинацию
                                                pass
                                            
                                            # ================= ЮНИТ-ЭКОНОМИКА В ПЛАНЕ ПРОДАЖ =================
                                            st.markdown("---")
                                            st.markdown("#### 💰 Юнит-экономика и расчёт прибыли")
                                            
                                            # Загрузка настроек
                                            def load_ue_plan_settings():
                                                try:
                                                    if os.path.exists("ue_settings.json"):
                                                        with open("ue_settings.json", 'r', encoding='utf-8') as f:
                                                            return json.load(f)
                                                except:
                                                    pass
                                                return {}
                                            
                                            def save_ue_plan_settings(settings):
                                                try:
                                                    with open("ue_settings.json", 'w', encoding='utf-8') as f:
                                                        json.dump(settings, f, ensure_ascii=False, indent=2)
                                                    return True
                                                except:
                                                    return False
                                            
                                            ue_plan_settings = load_ue_plan_settings()
                                            plan_ue_key = f"{selected_combo_key}_plan"
                                            combo_ue_plan = ue_plan_settings.get(plan_ue_key, ue_plan_settings.get(selected_combo_key, {}))
                                            
                                            with st.expander("⚙️ Настройки юнит-экономики", expanded=True):
                                                ue_ps1, ue_ps2 = st.columns([3, 1])
                                                with ue_ps2:
                                                    if st.button("💾 Сохранить", key=f"ue_save_plan_{selected_combo_key}", use_container_width=True):
                                                        new_ue_plan = {
                                                            'cost_price': st.session_state.get(f'ue_cost_p_{selected_combo_key}', 500.0),
                                                            'commission': st.session_state.get(f'ue_comm_p_{selected_combo_key}', 15.0),
                                                            'logistics': st.session_state.get(f'ue_log_p_{selected_combo_key}', 100.0),
                                                            'advertising': st.session_state.get(f'ue_adv_p_{selected_combo_key}', 5.0),
                                                            'spp': st.session_state.get(f'ue_spp_p_{selected_combo_key}', 25.0),
                                                            'buyout': st.session_state.get(f'ue_buy_p_{selected_combo_key}', 80.0),
                                                            'tax': st.session_state.get(f'ue_tax_p_{selected_combo_key}', 7.0),
                                                            'saved_at': datetime.now().strftime('%Y-%m-%d %H:%M')
                                                        }
                                                        ue_plan_settings[plan_ue_key] = new_ue_plan
                                                        if save_ue_plan_settings(ue_plan_settings):
                                                            st.success("✅ Сохранено!")
                                                with ue_ps1:
                                                    if combo_ue_plan.get('saved_at'):
                                                        st.caption(f"📅 Сохранено: {combo_ue_plan.get('saved_at')}")
                                                
                                                ue_pc1, ue_pc2, ue_pc3 = st.columns(3)
                                                
                                                with ue_pc1:
                                                    ue_cost_p = st.number_input("Себестоимость, ₽", min_value=0.0, value=combo_ue_plan.get('cost_price', 500.0), step=10.0, key=f"ue_cost_p_{selected_combo_key}")
                                                    ue_comm_p = st.number_input("Комиссия WB, %", min_value=0.0, max_value=100.0, value=combo_ue_plan.get('commission', 15.0), step=0.5, key=f"ue_comm_p_{selected_combo_key}")
                                                
                                                with ue_pc2:
                                                    ue_log_p = st.number_input("Логистика, ₽", min_value=0.0, value=combo_ue_plan.get('logistics', 100.0), step=10.0, key=f"ue_log_p_{selected_combo_key}")
                                                    ue_adv_p = st.number_input("Реклама, %", min_value=0.0, max_value=100.0, value=combo_ue_plan.get('advertising', 5.0), step=0.5, key=f"ue_adv_p_{selected_combo_key}")
                                                
                                                with ue_pc3:
                                                    ue_spp_p = st.number_input("СПП, %", min_value=0.0, max_value=100.0, value=combo_ue_plan.get('spp', 25.0), step=0.5, key=f"ue_spp_p_{selected_combo_key}")
                                                    ue_buy_p = st.number_input("% выкупа", min_value=1.0, max_value=100.0, value=combo_ue_plan.get('buyout', 80.0), step=1.0, key=f"ue_buy_p_{selected_combo_key}")
                                                    ue_tax_p = st.number_input("Налог, %", min_value=0.0, max_value=100.0, value=combo_ue_plan.get('tax', 7.0), step=0.5, key=f"ue_tax_p_{selected_combo_key}")
                                            
                                            # Детализация на 1 единицу
                                            with st.expander("🔍 Детализация расчёта (на 1 единицу)", expanded=False):
                                                # Информация о периоде
                                                if len(daily_plan_details) > 0:
                                                    first_date = daily_plan_details[0].get('Дата', '')
                                                    last_date = daily_plan_details[-1].get('Дата', '')
                                                    if hasattr(first_date, 'strftime'):
                                                        first_date = first_date.strftime('%d.%m.%Y')
                                                    if hasattr(last_date, 'strftime'):
                                                        last_date = last_date.strftime('%d.%m.%Y')
                                                    st.info(f"📅 Период плана: {first_date} - {last_date} | 🗺️ План продаж")
                                                
                                                avg_price_plan_spp = base_price if base_price and base_price > 0 else 1000
                                                spp_f_p = (1 - ue_spp_p / 100) if ue_spp_p < 100 else 1
                                                avg_price_plan_no_spp = avg_price_plan_spp / spp_f_p
                                                
                                                ue_ex_p = calculate_unit_economics(
                                                    cost_price=ue_cost_p, retail_price=avg_price_plan_no_spp,
                                                    commission_rate=ue_comm_p, logistics_cost=ue_log_p,
                                                    advertising_percent=ue_adv_p, buyout_percent=ue_buy_p, tax_rate=ue_tax_p
                                                )
                                                
                                                dcp1, dcp2 = st.columns(2)
                                                with dcp1:
                                                    st.markdown("**📥 Доходы:**")
                                                    st.write(f"🏷️ Цена с СПП ({ue_spp_p}%): **{avg_price_plan_spp:,.0f} ₽**")
                                                    st.write(f"💰 Цена без СПП: **{avg_price_plan_no_spp:,.0f} ₽**")
                                                    st.markdown("**📤 Расходы:**")
                                                    st.write(f"📦 Себестоимость: **{ue_cost_p:,.0f} ₽**")
                                                    st.write(f"🏢 Комиссия: **{ue_ex_p['Комиссия, руб']:,.0f} ₽**")
                                                    st.write(f"🚚 Логистика: **{ue_ex_p['Логистика с учетом выкупа']:,.0f} ₽**")
                                                    st.write(f"📢 Реклама: **{ue_ex_p['Реклама, руб']:,.0f} ₽**")
                                                    st.write(f"🏛️ Налог: **{ue_ex_p['Налог, руб']:,.0f} ₽**")
                                                with dcp2:
                                                    st.markdown("**📊 Результат:**")
                                                    tot_exp_p = ue_cost_p + ue_ex_p['Комиссия, руб'] + ue_ex_p['Логистика с учетом выкупа'] + ue_ex_p['Реклама, руб'] + ue_ex_p['Налог, руб']
                                                    st.write(f"💸 Всего расходов: **{tot_exp_p:,.0f} ₽**")
                                                    st.write(f"📈 Выручка с ед.: **{ue_ex_p['Выручка с ед.']:,.0f} ₽**")
                                                    pcp = "green" if ue_ex_p['Прибыль с ед.'] > 0 else "red"
                                                    st.markdown(f"💵 **Прибыль: <span style='color:{pcp};font-size:1.2em;'>{ue_ex_p['Прибыль с ед.']:,.0f} ₽</span>**", unsafe_allow_html=True)
                                                    mcp = "green" if ue_ex_p['Маржинальность, %'] > 0 else "red"
                                                    st.markdown(f"📉 Маржа: <span style='color:{mcp};'>{ue_ex_p['Маржинальность, %']:.1f}%</span>", unsafe_allow_html=True)
                                                    rcp = "green" if ue_ex_p['Рентабельность, %'] > 0 else "red"
                                                    st.markdown(f"📊 Рентабельность: <span style='color:{rcp};'>{ue_ex_p['Рентабельность, %']:.1f}%</span>", unsafe_allow_html=True)
                                            
                                            # Расчёт прибыли по планам
                                            if len(daily_plan_details) > 0:
                                                st.markdown("##### 📊 Прибыль по планам")
                                                
                                                tot_profit_low_p = 0
                                                tot_profit_mid_p = 0
                                                tot_profit_high_p = 0
                                                tot_sales_low_p = 0
                                                tot_sales_mid_p = 0
                                                tot_sales_high_p = 0
                                                
                                                for day_d in daily_plan_details:
                                                    s_low = day_d.get('Низкий план (среднее)', 0)
                                                    s_mid = day_d.get('Средний план (среднее)', 0)
                                                    s_high = day_d.get('Высокий план (среднее)', 0)
                                                    
                                                    p_low_spp = day_d.get('Низкий план цены') or day_d.get('Средняя цена') or avg_price_plan_spp
                                                    p_mid_spp = day_d.get('Средний план цены') or day_d.get('Средняя цена') or avg_price_plan_spp
                                                    p_high_spp = day_d.get('Высокий план цены') or day_d.get('Средняя цена') or avg_price_plan_spp
                                                    
                                                    p_low = p_low_spp / spp_f_p if p_low_spp else avg_price_plan_no_spp
                                                    p_mid = p_mid_spp / spp_f_p if p_mid_spp else avg_price_plan_no_spp
                                                    p_high = p_high_spp / spp_f_p if p_high_spp else avg_price_plan_no_spp
                                                    
                                                    pr_low = calculate_daily_profit(
                                                        s_low, p_low, ue_cost_p, ue_comm_p,
                                                        ue_log_p, ue_adv_p, ue_buy_p, tax_rate=ue_tax_p
                                                    )
                                                    pr_mid = calculate_daily_profit(
                                                        s_mid, p_mid, ue_cost_p, ue_comm_p,
                                                        ue_log_p, ue_adv_p, ue_buy_p, tax_rate=ue_tax_p
                                                    )
                                                    pr_high = calculate_daily_profit(
                                                        s_high, p_high, ue_cost_p, ue_comm_p,
                                                        ue_log_p, ue_adv_p, ue_buy_p, tax_rate=ue_tax_p
                                                    )
                                                    
                                                    tot_profit_low_p += pr_low['Общая прибыль']
                                                    tot_profit_mid_p += pr_mid['Общая прибыль']
                                                    tot_profit_high_p += pr_high['Общая прибыль']
                                                    tot_sales_low_p += s_low
                                                    tot_sales_mid_p += s_mid
                                                    tot_sales_high_p += s_high
                                                
                                                pkp1, pkp2, pkp3 = st.columns(3)
                                                with pkp1:
                                                    pcd_low = "normal" if tot_profit_low_p >= 0 else "inverse"
                                                    st.metric("📉 Низкий план", f"{tot_profit_low_p:,.0f} ₽", delta=f"{tot_sales_low_p:.0f} продаж", delta_color=pcd_low)
                                                with pkp2:
                                                    pcd_mid = "normal" if tot_profit_mid_p >= 0 else "inverse"
                                                    st.metric("📊 Средний план", f"{tot_profit_mid_p:,.0f} ₽", delta=f"{tot_sales_mid_p:.0f} продаж", delta_color=pcd_mid)
                                                with pkp3:
                                                    pcd_high = "normal" if tot_profit_high_p >= 0 else "inverse"
                                                    st.metric("📈 Высокий план", f"{tot_profit_high_p:,.0f} ₽", delta=f"{tot_sales_high_p:.0f} продаж", delta_color=pcd_high)
                                                
                                                st.info(f"📅 Период: {len(daily_plan_details)} дней | 💵 Прибыль с ед.: {ue_ex_p['Прибыль с ед.']:,.0f} ₽")
                                
                                # Кнопка для удаления отчета
                                if st.button(f"🗑️ Удалить отчет для '{selected_combo_key[:30]}...'", key=f"delete_report_{selected_combo_key}"):
                                    if combo_report_key in st.session_state['combination_reports']:
                                        del st.session_state['combination_reports'][combo_report_key]
                                    if auto_load_done_key in st.session_state:
                                        del st.session_state[auto_load_done_key]
                                    st.rerun()
                            
                            # ================= ВКЛАДКА "СИТУАЦИЯ" =================
                            with plan_subtab2:
                                st.markdown("### 📈 Текущая ситуация")
                                st.markdown("Анализ выполнения плана продаж на текущий момент")
                                
                                # Проверяем наличие данных плана
                                plan_details_key = f'plan_details_table_{selected_combo_key}'
                                plan_details_data = st.session_state.get(plan_details_key, [])
                                
                                if not plan_details_data:
                                    st.warning("⚠️ Сначала сформируйте план продаж во вкладке '📊 План'")
                                else:
                                    # Генерируем симулированные данные (в будущем - загрузка по API)
                                    import random
                                    
                                    # Период анализа: 1 сентября - 17 декабря 2025
                                    start_situation = datetime(2025, 9, 1)
                                    end_situation = datetime(2025, 12, 17)
                                    
                                    # Создаём датафрейм с фактическими данными (симуляция)
                                    situation_dates = pd.date_range(start=start_situation, end=end_situation, freq='D')
                                    
                                    # Получаем плановые данные за этот период
                                    plan_by_date = {}
                                    for day_detail in plan_details_data:
                                        day_date = day_detail.get('Дата')
                                        if day_date:
                                            if isinstance(day_date, str):
                                                day_date = pd.Timestamp(day_date)
                                            plan_by_date[day_date.date() if hasattr(day_date, 'date') else day_date] = day_detail
                                    
                                    # Базовая цена для симуляции
                                    base_price_sim = base_price if base_price and base_price > 0 else 1000
                                    
                                    # Генерируем фактические данные
                                    fact_data = []
                                    random.seed(42)  # Для воспроизводимости
                                    
                                    for date in situation_dates:
                                        date_only = date.date()
                                        
                                        # Получаем план на этот день
                                        plan_day = plan_by_date.get(date_only, {})
                                        plan_low = plan_day.get('Низкий план (среднее)', 5)
                                        plan_mid = plan_day.get('Средний план (среднее)', 10)
                                        plan_high = plan_day.get('Высокий план (среднее)', 15)
                                        
                                        # Симуляция факта: отклонение от среднего плана ±30%
                                        deviation = random.uniform(0.7, 1.3)
                                        fact_orders = max(0, int(plan_mid * deviation))
                                        
                                        # Продажи = заказы * процент выкупа (75-85%)
                                        buyout_rate = random.uniform(0.75, 0.85)
                                        fact_sales = int(fact_orders * buyout_rate)
                                        
                                        # Цена: отклонение ±10% от базовой
                                        price_deviation = random.uniform(0.9, 1.1)
                                        fact_price = base_price_sim * price_deviation
                                        
                                        fact_data.append({
                                            'Дата': date,
                                            'Заказы (факт)': fact_orders,
                                            'Продажи (факт)': fact_sales,
                                            'Цена (факт)': fact_price,
                                            'План (низкий)': plan_low,
                                            'План (средний)': plan_mid,
                                            'План (высокий)': plan_high
                                        })
                                    
                                    fact_df = pd.DataFrame(fact_data)
                                    
                                    # Расчёт KPI
                                    total_fact_orders = fact_df['Заказы (факт)'].sum()
                                    total_fact_sales = fact_df['Продажи (факт)'].sum()
                                    total_plan_low = fact_df['План (низкий)'].sum()
                                    total_plan_mid = fact_df['План (средний)'].sum()
                                    total_plan_high = fact_df['План (высокий)'].sum()
                                    avg_fact_price = fact_df['Цена (факт)'].mean()
                                    total_revenue = (fact_df['Цена (факт)'] * fact_df['Продажи (факт)']).sum()
                                    
                                    # Процент выполнения плана
                                    pct_vs_low = (total_fact_orders / total_plan_low * 100) if total_plan_low > 0 else 0
                                    pct_vs_mid = (total_fact_orders / total_plan_mid * 100) if total_plan_mid > 0 else 0
                                    pct_vs_high = (total_fact_orders / total_plan_high * 100) if total_plan_high > 0 else 0
                                    
                                    # Период
                                    days_passed = len(fact_df)
                                    
                                    # Расчёт прибыли (используем настройки юнит-экономики если есть)
                                    # Загружаем настройки UE
                                    def load_ue_situation():
                                        try:
                                            if os.path.exists("ue_settings.json"):
                                                with open("ue_settings.json", 'r', encoding='utf-8') as f:
                                                    return json.load(f)
                                        except:
                                            pass
                                        return {}
                                    
                                    ue_sit_settings = load_ue_situation()
                                    ue_sit = ue_sit_settings.get(f"{selected_combo_key}_plan", ue_sit_settings.get(selected_combo_key, {}))
                                    
                                    ue_cost_sit = ue_sit.get('cost_price', 500)
                                    ue_comm_sit = ue_sit.get('commission', 15)
                                    ue_log_sit = ue_sit.get('logistics', 100)
                                    ue_adv_sit = ue_sit.get('advertising', 5)
                                    ue_spp_sit = ue_sit.get('spp', 25)
                                    ue_buy_sit = ue_sit.get('buyout', 80)
                                    ue_tax_sit = ue_sit.get('tax', 7)
                                    
                                    # Пересчёт цены без СПП
                                    spp_f_sit = (1 - ue_spp_sit / 100) if ue_spp_sit < 100 else 1
                                    avg_price_no_spp_sit = avg_fact_price / spp_f_sit
                                    
                                    # Прибыль на единицу
                                    ue_profit_sit = calculate_unit_economics(
                                        cost_price=ue_cost_sit, retail_price=avg_price_no_spp_sit,
                                        commission_rate=ue_comm_sit, logistics_cost=ue_log_sit,
                                        advertising_percent=ue_adv_sit, buyout_percent=ue_buy_sit, tax_rate=ue_tax_sit
                                    )
                                    profit_per_unit = ue_profit_sit['Прибыль с ед.']
                                    
                                    # Текущая прибыль факт
                                    total_profit_fact = profit_per_unit * total_fact_sales
                                    
                                    # Плановая прибыль (средний план)
                                    total_profit_plan_mid = profit_per_unit * total_plan_mid
                                    total_profit_plan_low = profit_per_unit * total_plan_low
                                    total_profit_plan_high = profit_per_unit * total_plan_high
                                    
                                    # Средняя плановая цена (из plan_details)
                                    plan_prices = []
                                    for day_detail in plan_details_data:
                                        price = day_detail.get('Средний план цены') or day_detail.get('Средняя цена')
                                        if price and price > 0:
                                            plan_prices.append(price)
                                    avg_plan_price = np.mean(plan_prices) if plan_prices else base_price_sim
                                    
                                    st.markdown("---")
                                    st.subheader("📊 Выполнение плана и сравнение")
                                    
                                    # Таблица: Факт | Низкий | Средний | Высокий
                                    st.markdown("##### 📦 Заказы и выполнение")
                                    order_col1, order_col2, order_col3, order_col4 = st.columns(4)
                                    
                                    with order_col1:
                                        st.metric("📦 Факт", f"{total_fact_orders:,.0f} шт")
                                        st.metric("💰 Продаж (факт)", f"{total_fact_sales:,.0f} шт")
                                    
                                    with order_col2:
                                        delta_low = total_fact_orders - total_plan_low
                                        st.metric("📉 Низкий план", f"{total_plan_low:,.0f} шт")
                                        st.metric("📉 vs Низкий", f"{pct_vs_low:.1f}%", delta=f"{delta_low:+.0f} шт", delta_color="normal" if delta_low >= 0 else "inverse")
                                    
                                    with order_col3:
                                        delta_mid = total_fact_orders - total_plan_mid
                                        st.metric("📊 Средний план", f"{total_plan_mid:,.0f} шт")
                                        st.metric("📊 vs Средний", f"{pct_vs_mid:.1f}%", delta=f"{delta_mid:+.0f} шт", delta_color="normal" if delta_mid >= 0 else "inverse")
                                    
                                    with order_col4:
                                        delta_high = total_fact_orders - total_plan_high
                                        st.metric("📈 Высокий план", f"{total_plan_high:,.0f} шт")
                                        st.metric("📈 vs Высокий", f"{pct_vs_high:.1f}%", delta=f"{delta_high:+.0f} шт", delta_color="normal" if delta_high >= 0 else "inverse")
                                    
                                    # Прибыль
                                    st.markdown("##### 💰 Прибыль")
                                    profit_col1, profit_col2, profit_col3, profit_col4 = st.columns(4)
                                    
                                    with profit_col1:
                                        st.metric("💰 Прибыль (факт)", f"{total_profit_fact:,.0f} ₽")
                                        st.metric("💵 На единицу", f"{profit_per_unit:,.0f} ₽")
                                    
                                    with profit_col2:
                                        diff_profit_low = total_profit_fact - total_profit_plan_low
                                        st.metric("📉 Прибыль (низ.)", f"{total_profit_plan_low:,.0f} ₽")
                                        st.metric("📉 Разница", f"{diff_profit_low:+,.0f} ₽", delta_color="normal" if diff_profit_low >= 0 else "inverse")
                                    
                                    with profit_col3:
                                        diff_profit_mid = total_profit_fact - total_profit_plan_mid
                                        st.metric("📊 Прибыль (сред.)", f"{total_profit_plan_mid:,.0f} ₽")
                                        st.metric("📊 Разница", f"{diff_profit_mid:+,.0f} ₽", delta_color="normal" if diff_profit_mid >= 0 else "inverse")
                                    
                                    with profit_col4:
                                        diff_profit_high = total_profit_fact - total_profit_plan_high
                                        st.metric("📈 Прибыль (выс.)", f"{total_profit_plan_high:,.0f} ₽")
                                        st.metric("📈 Разница", f"{diff_profit_high:+,.0f} ₽", delta_color="normal" if diff_profit_high >= 0 else "inverse")
                                    
                                    # Цена и выручка
                                    st.markdown("##### 🏷️ Цена и выручка")
                                    price_col1, price_col2, price_col3, price_col4 = st.columns(4)
                                    
                                    with price_col1:
                                        st.metric("💵 Выручка (факт)", f"{total_revenue:,.0f} ₽")
                                    
                                    with price_col2:
                                        st.metric("🏷️ Ср. цена (факт)", f"{avg_fact_price:,.0f} ₽")
                                    
                                    with price_col3:
                                        price_diff = avg_fact_price - avg_plan_price
                                        st.metric("🏷️ Ср. цена (план)", f"{avg_plan_price:,.0f} ₽", delta=f"{price_diff:+,.0f} ₽", delta_color="normal" if price_diff >= 0 else "off")
                                    
                                    with price_col4:
                                        avg_daily = total_fact_orders / days_passed if days_passed > 0 else 0
                                        st.metric("📅 Дней прошло", f"{days_passed}")
                                        st.metric("📈 Среднее/день", f"{avg_daily:.1f} шт")
                                    
                                    # Оценка ситуации
                                    st.markdown("---")
                                    st.subheader("🎯 Оценка ситуации")
                                    
                                    # Определяем к какому плану ближе текущая ситуация
                                    diff_to_low = abs(total_fact_orders - total_plan_low)
                                    diff_to_mid = abs(total_fact_orders - total_plan_mid)
                                    diff_to_high = abs(total_fact_orders - total_plan_high)
                                    
                                    # Определяем ближайший план
                                    if diff_to_low <= diff_to_mid and diff_to_low <= diff_to_high:
                                        closest_plan = "📉 Низкому плану"
                                        closest_plan_value = total_plan_low
                                        closest_pct = pct_vs_low
                                    elif diff_to_high <= diff_to_mid:
                                        closest_plan = "📈 Высокому плану"
                                        closest_plan_value = total_plan_high
                                        closest_pct = pct_vs_high
                                    else:
                                        closest_plan = "📊 Среднему плану"
                                        closest_plan_value = total_plan_mid
                                        closest_pct = pct_vs_mid
                                    
                                    # Определяем между какими планами находимся
                                    if total_fact_orders >= total_plan_high:
                                        position = "выше высокого плана 🚀"
                                        position_detail = f"Превышение высокого плана на {total_fact_orders - total_plan_high:,.0f} шт"
                                    elif total_fact_orders >= total_plan_mid:
                                        position = "между средним и высоким планом 📈"
                                        progress_to_high = (total_fact_orders - total_plan_mid) / (total_plan_high - total_plan_mid) * 100 if total_plan_high > total_plan_mid else 0
                                        position_detail = f"Прогресс к высокому плану: {progress_to_high:.0f}%"
                                    elif total_fact_orders >= total_plan_low:
                                        position = "между низким и средним планом 📊"
                                        progress_to_mid = (total_fact_orders - total_plan_low) / (total_plan_mid - total_plan_low) * 100 if total_plan_mid > total_plan_low else 0
                                        position_detail = f"Прогресс к среднему плану: {progress_to_mid:.0f}%"
                                    else:
                                        position = "ниже низкого плана ⚠️"
                                        position_detail = f"Отставание от низкого плана на {total_plan_low - total_fact_orders:,.0f} шт"
                                    
                                    # Основной статус
                                    if pct_vs_mid >= 100:
                                        st.success(f"✅ **Отлично!** План выполнен на {pct_vs_mid:.1f}%.")
                                    elif pct_vs_mid >= 90:
                                        st.info(f"ℹ️ **Хорошо.** План выполнен на {pct_vs_mid:.1f}%.")
                                    elif pct_vs_mid >= 75:
                                        st.warning(f"⚠️ **Внимание.** План выполнен на {pct_vs_mid:.1f}%.")
                                    else:
                                        st.error(f"❌ **Критично.** План выполнен только на {pct_vs_mid:.1f}%.")
                                    
                                    # Подробная оценка
                                    st.markdown("#### 📍 Позиция относительно планов")
                                    
                                    eval_col1, eval_col2 = st.columns(2)
                                    
                                    with eval_col1:
                                        st.markdown(f"**Текущее положение:** {position}")
                                        st.markdown(f"**Ближе всего к:** {closest_plan}")
                                        st.caption(position_detail)
                                    
                                    with eval_col2:
                                        # Прогресс-бар визуализация
                                        st.markdown("**Шкала выполнения:**")
                                        
                                        # Визуализация положения на шкале
                                        if total_plan_high > 0:
                                            scale_pct = min(100, total_fact_orders / total_plan_high * 100)
                                            low_mark = total_plan_low / total_plan_high * 100
                                            mid_mark = total_plan_mid / total_plan_high * 100
                                            
                                            st.progress(scale_pct / 100)
                                            st.caption(f"📉 Низкий: {low_mark:.0f}% | 📊 Средний: {mid_mark:.0f}% | 📈 Высокий: 100%")
                                    
                                    # Детальная статистика
                                    st.markdown("#### 📊 Детальный анализ")
                                    
                                    detail_col1, detail_col2, detail_col3 = st.columns(3)
                                    
                                    with detail_col1:
                                        st.markdown("**vs Низкий план:**")
                                        if pct_vs_low >= 100:
                                            st.markdown(f"✅ Выполнен на **{pct_vs_low:.1f}%**")
                                        else:
                                            st.markdown(f"⏳ Выполнен на **{pct_vs_low:.1f}%**")
                                        need_for_low = max(0, total_plan_low - total_fact_orders)
                                        if need_for_low > 0:
                                            st.caption(f"До выполнения: {need_for_low:,.0f} шт")
                                    
                                    with detail_col2:
                                        st.markdown("**vs Средний план:**")
                                        if pct_vs_mid >= 100:
                                            st.markdown(f"✅ Выполнен на **{pct_vs_mid:.1f}%**")
                                        else:
                                            st.markdown(f"⏳ Выполнен на **{pct_vs_mid:.1f}%**")
                                        need_for_mid = max(0, total_plan_mid - total_fact_orders)
                                        if need_for_mid > 0:
                                            st.caption(f"До выполнения: {need_for_mid:,.0f} шт")
                                    
                                    with detail_col3:
                                        st.markdown("**vs Высокий план:**")
                                        if pct_vs_high >= 100:
                                            st.markdown(f"✅ Выполнен на **{pct_vs_high:.1f}%**")
                                        else:
                                            st.markdown(f"⏳ Выполнен на **{pct_vs_high:.1f}%**")
                                        need_for_high = max(0, total_plan_high - total_fact_orders)
                                        if need_for_high > 0:
                                            st.caption(f"До выполнения: {need_for_high:,.0f} шт")
                                    
                                    # Сколько должно быть
                                    st.markdown("---")
                                    st.subheader("📋 Сколько должно быть по плану")
                                    
                                    plan_compare_col1, plan_compare_col2, plan_compare_col3 = st.columns(3)
                                    
                                    with plan_compare_col1:
                                        diff_low = total_fact_orders - total_plan_low
                                        st.metric("📉 Низкий план", f"{total_plan_low:,.0f} шт", delta=f"{diff_low:+.0f} шт", delta_color="normal" if diff_low >= 0 else "inverse")
                                    
                                    with plan_compare_col2:
                                        diff_mid = total_fact_orders - total_plan_mid
                                        st.metric("📊 Средний план", f"{total_plan_mid:,.0f} шт", delta=f"{diff_mid:+.0f} шт", delta_color="normal" if diff_mid >= 0 else "inverse")
                                    
                                    with plan_compare_col3:
                                        diff_high = total_fact_orders - total_plan_high
                                        st.metric("📈 Высокий план", f"{total_plan_high:,.0f} шт", delta=f"{diff_high:+.0f} шт", delta_color="normal" if diff_high >= 0 else "inverse")
                                    
                                    # График факт vs план
                                    st.markdown("---")
                                    st.subheader("📈 График: Факт vs План")
                                    
                                    import plotly.graph_objs as go
                                    
                                    fig_situation = go.Figure()
                                    
                                    # Факт заказов
                                    fig_situation.add_trace(go.Scatter(
                                        x=fact_df['Дата'],
                                        y=fact_df['Заказы (факт)'],
                                        mode='lines',
                                        name='Факт заказов',
                                        line=dict(color='blue', width=2)
                                    ))
                                    
                                    # Планы
                                    fig_situation.add_trace(go.Scatter(
                                        x=fact_df['Дата'],
                                        y=fact_df['План (низкий)'],
                                        mode='lines',
                                        name='Низкий план',
                                        line=dict(color='red', width=1, dash='dot')
                                    ))
                                    
                                    fig_situation.add_trace(go.Scatter(
                                        x=fact_df['Дата'],
                                        y=fact_df['План (средний)'],
                                        mode='lines',
                                        name='Средний план',
                                        line=dict(color='orange', width=2, dash='dash')
                                    ))
                                    
                                    fig_situation.add_trace(go.Scatter(
                                        x=fact_df['Дата'],
                                        y=fact_df['План (высокий)'],
                                        mode='lines',
                                        name='Высокий план',
                                        line=dict(color='green', width=1, dash='dot')
                                    ))
                                    
                                    fig_situation.update_layout(
                                        title="Факт заказов vs План продаж",
                                        xaxis_title="Дата",
                                        yaxis_title="Заказы, шт",
                                        hovermode='x unified',
                                        height=400
                                    )
                                    
                                    st.plotly_chart(fig_situation, use_container_width=True)
                                    
                                    # Таблица по дням (последние 14 дней)
                                    st.markdown("---")
                                    st.subheader("📋 Детализация (последние 14 дней)")
                                    
                                    recent_df = fact_df.tail(14).copy()
                                    recent_df['Дата'] = recent_df['Дата'].dt.strftime('%d.%m.%Y')
                                    recent_df['Цена (факт)'] = recent_df['Цена (факт)'].apply(lambda x: f"{x:,.0f} ₽")
                                    recent_df['% от плана'] = (recent_df['Заказы (факт)'] / recent_df['План (средний)'] * 100).apply(lambda x: f"{x:.0f}%")
                                    
                                    display_df = recent_df[['Дата', 'Заказы (факт)', 'Продажи (факт)', 'План (средний)', '% от плана', 'Цена (факт)']]
                                    st.dataframe(display_df, use_container_width=True, hide_index=True)
                                    
                                    st.caption("⚠️ Данные симулированы. В будущем будет загрузка реальных данных по API.")
                            
                            # ================= ВКЛАДКА "ТАБЛИЦА" =================
                            with plan_subtab3:
                                st.markdown("### 📋 Таблица воронки продаж")
                                st.markdown("Детализация планов и фактических данных по дням")
                                
                                # Получаем данные плана для выбранной комбинации
                                plan_details_key = f'plan_details_table_{selected_combo_key}'
                                plan_details = st.session_state.get(plan_details_key, [])
                                
                                if plan_details and len(plan_details) > 0:
                                    # Параметры для расчета рентабельности (берем из настроек или используем значения по умолчанию)
                                    buyout_pct = st.session_state.get("buyout_pct", 80.0)
                                    
                                    # Загружаем настройки юнит-экономики из файла
                                    def load_ue_plan_settings():
                                        try:
                                            if os.path.exists("ue_settings.json"):
                                                with open("ue_settings.json", 'r', encoding='utf-8') as f:
                                                    return json.load(f)
                                        except:
                                            pass
                                        return {}
                                    
                                    ue_plan_settings = load_ue_plan_settings()
                                    plan_ue_key = f"{selected_combo_key}_plan"
                                    combo_ue_plan = ue_plan_settings.get(plan_ue_key, ue_plan_settings.get(selected_combo_key, {}))
                                    
                                    # Параметры юнит-экономики (из сохраненных настроек, session_state или значения по умолчанию)
                                    ue_cost = combo_ue_plan.get('cost_price', st.session_state.get(f'ue_cost_p_{selected_combo_key}', 500.0))
                                    ue_comm = combo_ue_plan.get('commission', st.session_state.get(f'ue_comm_p_{selected_combo_key}', 15.0))
                                    ue_log = combo_ue_plan.get('logistics', st.session_state.get(f'ue_log_p_{selected_combo_key}', 100.0))
                                    ue_adv = combo_ue_plan.get('advertising', st.session_state.get(f'ue_adv_p_{selected_combo_key}', 5.0))
                                    ue_spp = combo_ue_plan.get('spp', st.session_state.get(f'ue_spp_p_{selected_combo_key}', 25.0))
                                    ue_buy = combo_ue_plan.get('buyout', st.session_state.get(f'ue_buy_p_{selected_combo_key}', buyout_pct))
                                    ue_tax = combo_ue_plan.get('tax', st.session_state.get(f'ue_tax_p_{selected_combo_key}', 7.0))
                                    
                                    # Создаем структуру таблицы: строки - метрики, столбцы - дни
                                    table_rows = {
                                        'Заказали, шт': [],  # Заказали факт
                                        'Заказы план': [],  # Заказали план
                                        'Продажа факт': [],  # Продажа факт
                                        'Продажа план': [],  # Продажа план
                                        'Средняя цена факт': [],
                                        'Средняя цена план': [],
                                        'Прибыль факт': [],
                                        'Прибыль план': [],
                                        'Рентабельность факт': [],
                                        'Рентабельность план': [],
                                        'ДДР': [],
                                        'Реклама': [],
                                        'Конверсия в корзину': [],
                                        'Конверсия в заказ': [],
                                        'Процент выкупа': [],
                                        'Заказали на сумму, ₽': [],
                                        'Выкупили на сумму, ₽': [],
                                        'Отменили, шт': []
                                    }
                                    
                                    # Список дат для столбцов
                                    date_columns = []
                                    
                                    # Заполняем данные для каждого дня
                                    for day_idx, day_detail in enumerate(plan_details):
                                        date = day_detail.get('Дата')
                                        if hasattr(date, 'strftime'):
                                            date_str = date.strftime('%d.%m.%Y')
                                            # Используем дату для seed, чтобы значения были стабильными, но разными для каждого дня
                                            date_hash = hash(date_str) % 10000
                                            np.random.seed(42 + date_hash)
                                        else:
                                            date_str = str(date)
                                            np.random.seed(42 + day_idx)
                                        date_columns.append(date_str)
                                        
                                        # Данные из плана продаж
                                        orders_plan = day_detail.get('Средний план (среднее)', 0)
                                        sales_plan = orders_plan * (buyout_pct / 100.0)  # Продажа план = Заказы план × % выкупа
                                        avg_price_plan = day_detail.get('Средний план цены') or day_detail.get('Средняя цена') or 0
                                        
                                        # Расчет рентабельности плана через юнит-экономику
                                        if avg_price_plan > 0 and sales_plan > 0:
                                            # Рассчитываем цену без СПП для юнит-экономики
                                            spp_factor = (1 - ue_spp / 100) if ue_spp < 100 else 1
                                            avg_price_plan_no_spp = avg_price_plan / spp_factor
                                            
                                            # Рассчитываем юнит-экономику для плана
                                            ue_plan = calculate_unit_economics(
                                                cost_price=ue_cost,
                                                retail_price=avg_price_plan_no_spp,
                                                commission_rate=ue_comm,
                                                logistics_cost=ue_log,
                                                advertising_percent=ue_adv,
                                                buyout_percent=ue_buy,
                                                tax_rate=ue_tax
                                            )
                                            
                                            # Рентабельность план из юнит-экономики
                                            rentability_plan = ue_plan['Рентабельность, %']
                                            # Прибыль план = Прибыль с единицы × Количество продаж
                                            profit_plan = ue_plan['Прибыль с ед.'] * sales_plan
                                        else:
                                            rentability_plan = 0
                                            profit_plan = 0
                                        
                                        # Рандомные данные для текущих показателей (позже будут из API)
                                        orders_fact = max(0, int(orders_plan * np.random.uniform(0.7, 1.3)))
                                        sales_fact = max(0, int(orders_fact * (buyout_pct / 100.0) * np.random.uniform(0.95, 1.05)))
                                        
                                        # Сначала рассчитываем сумму заказов на основе плановой цены с отклонением
                                        # Фактическая цена может отличаться от плановой на ±10%
                                        price_variation = np.random.uniform(0.9, 1.1) if avg_price_plan > 0 else 1.0
                                        orders_sum = orders_fact * avg_price_plan * price_variation if avg_price_plan > 0 and orders_fact > 0 else 0
                                        
                                        # Средняя цена факт = Заказали на сумму / Заказали (шт)
                                        avg_price_fact = orders_sum / orders_fact if orders_fact > 0 else 0
                                        
                                        # Выкупили на сумму = Выкупили (шт) × Средняя цена факт
                                        sales_sum = sales_fact * avg_price_fact if avg_price_fact > 0 else 0
                                        
                                        cancelled = max(0, int((orders_fact - sales_fact) * np.random.uniform(0.3, 0.7)))
                                        reklama = orders_sum * np.random.uniform(0, 0.05)
                                        
                                        # Симулируем данные для конверсий (позже будут из API)
                                        # Просмотры - обычно в 10-50 раз больше заказов
                                        views = max(orders_fact * 20, int(orders_plan * 20 * np.random.uniform(0.8, 1.2))) if orders_plan > 0 else 0
                                        # Добавления в корзину - обычно в 2-5 раз больше заказов
                                        cart_adds = max(orders_fact * 3, int(orders_fact * np.random.uniform(2, 5))) if orders_fact > 0 else 0
                                        
                                        # Расчет конверсий и процента выкупа
                                        # Конверсия в корзину = (Добавили в корзину / Просмотры) * 100
                                        conversion_to_cart = (cart_adds / views * 100) if views > 0 else 0
                                        # Конверсия в заказ = (Заказали / Добавили в корзину) * 100
                                        conversion_to_order = (orders_fact / cart_adds * 100) if cart_adds > 0 else 0
                                        # Процент выкупа = (Выкупили / Заказали) * 100
                                        buyout_percent = (sales_fact / orders_fact * 100) if orders_fact > 0 else 0
                                        
                                        # Расчет рентабельности факт через юнит-экономику
                                        if sales_sum > 0 and avg_price_fact > 0:
                                            # Рассчитываем цену без СПП для факта
                                            spp_factor_fact = (1 - ue_spp / 100) if ue_spp < 100 else 1
                                            avg_price_fact_no_spp = avg_price_fact / spp_factor_fact
                                            
                                            # Рассчитываем юнит-экономику для факта
                                            ue_fact = calculate_unit_economics(
                                                cost_price=ue_cost,
                                                retail_price=avg_price_fact_no_spp,
                                                commission_rate=ue_comm,
                                                logistics_cost=ue_log,
                                                advertising_percent=ue_adv,
                                                buyout_percent=ue_buy,
                                                tax_rate=ue_tax
                                            )
                                            
                                            # Рентабельность факт из юнит-экономики
                                            rentability_fact = ue_fact['Рентабельность, %']
                                            # Прибыль факт = Прибыль с единицы × Количество продаж
                                            profit_fact = ue_fact['Прибыль с ед.'] * sales_fact
                                        else:
                                            rentability_fact = 0
                                            profit_fact = 0
                                        
                                        # ДДР (Доля доставки в рознице) - процент отношения Реклама к Заказали на сумму
                                        # ДДР = (Реклама / Заказали на сумму) × 100%
                                        if orders_sum > 0:
                                            ddr = (reklama / orders_sum) * 100.0
                                        else:
                                            ddr = 0
                                        
                                        # Заполняем строки в правильном порядке
                                        table_rows['Заказали, шт'].append(orders_fact)  # Заказали факт
                                        table_rows['Заказы план'].append(orders_plan)  # Заказали план
                                        table_rows['Продажа факт'].append(sales_fact)  # Продажа факт
                                        table_rows['Продажа план'].append(sales_plan)  # Продажа план
                                        table_rows['Средняя цена факт'].append(avg_price_fact)
                                        table_rows['Средняя цена план'].append(avg_price_plan)
                                        table_rows['Прибыль факт'].append(profit_fact)
                                        table_rows['Прибыль план'].append(profit_plan)
                                        table_rows['Рентабельность факт'].append(rentability_fact)
                                        table_rows['Рентабельность план'].append(rentability_plan)
                                        table_rows['ДДР'].append(ddr)
                                        table_rows['Реклама'].append(reklama)
                                        table_rows['Конверсия в корзину'].append(conversion_to_cart)
                                        table_rows['Конверсия в заказ'].append(conversion_to_order)
                                        table_rows['Процент выкупа'].append(buyout_percent)
                                        table_rows['Заказали на сумму, ₽'].append(orders_sum)
                                        table_rows['Выкупили на сумму, ₽'].append(sales_sum)
                                        table_rows['Отменили, шт'].append(cancelled)
                                    
                                    # Создаем DataFrame для отображения (сохраняем числовые значения для сравнения)
                                    table_df = pd.DataFrame.from_dict(table_rows, orient='index', columns=date_columns)
                                    
                                    # Функция для условного форматирования ячеек
                                    def highlight_performance(df):
                                        """Выделяет ячейки цветом в зависимости от выполнения плана"""
                                        # Создаем DataFrame со стилями (изначально пустые стили)
                                        styles = pd.DataFrame('', index=df.index, columns=df.columns)
                                        
                                        # Получаем индексы строк (один раз, вне цикла)
                                        orders_plan_idx = df.index.get_loc('Заказы план') if 'Заказы план' in df.index else None
                                        sales_plan_idx = df.index.get_loc('Продажа план') if 'Продажа план' in df.index else None
                                        orders_fact_idx = df.index.get_loc('Заказали, шт') if 'Заказали, шт' in df.index else None
                                        sales_fact_idx = df.index.get_loc('Продажа факт') if 'Продажа факт' in df.index else None
                                        profit_plan_idx = df.index.get_loc('Прибыль план') if 'Прибыль план' in df.index else None
                                        profit_fact_idx = df.index.get_loc('Прибыль факт') if 'Прибыль факт' in df.index else None
                                        
                                        # Для каждого столбца (дня) проверяем выполнение плана
                                        for col in df.columns:
                                            # Проверяем "Заказали, шт" vs "Заказы план"
                                            if orders_fact_idx is not None and orders_plan_idx is not None:
                                                plan_val = df.iloc[orders_plan_idx, df.columns.get_loc(col)]
                                                fact_val = df.iloc[orders_fact_idx, df.columns.get_loc(col)]
                                                if pd.notna(plan_val) and pd.notna(fact_val) and plan_val > 0:
                                                    if fact_val >= plan_val:
                                                        styles.iloc[orders_fact_idx, df.columns.get_loc(col)] = 'background-color: #32CD32'  # Яркий зеленый - план выполнен
                                                    else:
                                                        styles.iloc[orders_fact_idx, df.columns.get_loc(col)] = 'background-color: #FF6B6B'  # Яркий красный - отставание
                                            
                                            # Проверяем "Продажа факт" vs "Продажа план"
                                            if sales_fact_idx is not None and sales_plan_idx is not None:
                                                plan_val = df.iloc[sales_plan_idx, df.columns.get_loc(col)]
                                                fact_val = df.iloc[sales_fact_idx, df.columns.get_loc(col)]
                                                if pd.notna(plan_val) and pd.notna(fact_val) and plan_val > 0:
                                                    if fact_val >= plan_val:
                                                        styles.iloc[sales_fact_idx, df.columns.get_loc(col)] = 'background-color: #32CD32'  # Яркий зеленый - план выполнен
                                                    else:
                                                        styles.iloc[sales_fact_idx, df.columns.get_loc(col)] = 'background-color: #FF6B6B'  # Яркий красный - отставание
                                            
                                            # Проверяем "Прибыль факт" vs "Прибыль план"
                                            if profit_fact_idx is not None and profit_plan_idx is not None:
                                                plan_val = df.iloc[profit_plan_idx, df.columns.get_loc(col)]
                                                fact_val = df.iloc[profit_fact_idx, df.columns.get_loc(col)]
                                                if pd.notna(plan_val) and pd.notna(fact_val) and plan_val > 0:
                                                    if fact_val >= plan_val:
                                                        styles.iloc[profit_fact_idx, df.columns.get_loc(col)] = 'background-color: #32CD32'  # Яркий зеленый - план выполнен
                                                    else:
                                                        styles.iloc[profit_fact_idx, df.columns.get_loc(col)] = 'background-color: #FF6B6B'  # Яркий красный - отставание
                                        
                                        return styles
                                    
                                    # Применяем условное форматирование к числовому DataFrame
                                    styled_df = table_df.style.apply(highlight_performance, axis=None)
                                    
                                    # Форматируем значения для отображения через format
                                    # Для строк с целыми числами
                                    int_rows = ['Заказы план', 'Продажа план', 'Заказали, шт', 'Продажа факт', 'Отменили, шт']
                                    for row in int_rows:
                                        if row in table_df.index:
                                            styled_df = styled_df.format('{:.0f}', subset=pd.IndexSlice[row, :])
                                    
                                    # Для строк с валютами
                                    currency_rows = ['Средняя цена план', 'Средняя цена факт', 'Заказали на сумму, ₽', 'Выкупили на сумму, ₽', 'Реклама', 'Прибыль план', 'Прибыль факт']
                                    for row in currency_rows:
                                        if row in table_df.index:
                                            styled_df = styled_df.format(lambda x: f"{x:,.0f} ₽" if pd.notna(x) and x > 0 else "0 ₽", subset=pd.IndexSlice[row, :])
                                    
                                    # Для строк с процентами
                                    percent_rows = ['Рентабельность план', 'Рентабельность факт', 'Конверсия в корзину', 'Конверсия в заказ', 'Процент выкупа', 'ДДР']
                                    for row in percent_rows:
                                        if row in table_df.index:
                                            styled_df = styled_df.format('{:.2f}%', subset=pd.IndexSlice[row, :])
                                    
                                    # Отображаем таблицу со стилями
                                    st.dataframe(
                                        styled_df,
                                        use_container_width=True,
                                        height=600
                                    )
                                    
                                    st.info("💡 Текущие данные (заказали, выкупили, суммы, отменили, реклама) генерируются случайно. В будущем они будут загружаться из API.")
                                else:
                                    st.warning("⚠️ Нет данных плана для этой комбинации. Сначала создайте план во вкладке '📊 План'.")
                            
                            # ================= ВКЛАДКА "ЧАТ С ИИ" =================
                            with plan_subtab4:
                                st.markdown("### 💬 Чат с ИИ-аналитиком")
                                st.markdown("Задайте вопросы о комбинации товаров и получите рекомендации")
                                
                                # Получаем данные о товарах комбинации для контекста
                                df = st.session_state.get('df', None)
                                combo_products_df_for_chat = None
                                if df is not None and combo_skus:
                                    combo_skus_list_for_chat = [str(sku).replace(".0", "") for sku in combo_skus] if combo_skus else []
                                    mask = df["Артикул"].astype(str).str.replace(".0", "").isin(combo_skus_list_for_chat)
                                    combo_products_df_for_chat = df[mask].copy()
                                
                                # Инициализация истории чата
                                chat_key = f'ai_chat_history_{selected_combo_key}'
                                if chat_key not in st.session_state:
                                    st.session_state[chat_key] = []
                                
                                # Отображаем историю чата
                                chat_history = st.session_state[chat_key]
                                
                                # Контейнер для истории чата
                                chat_container = st.container()
                                
                                with chat_container:
                                    if not chat_history:
                                        st.info("👋 Привет! Я ИИ-аналитик. Задайте мне вопрос о комбинации товаров, и я помогу с анализом и рекомендациями.")
                                    
                                    # Отображаем сообщения
                                    for message in chat_history:
                                        role = message.get("role", "user")
                                        content = message.get("content", "")
                                        
                                        if role == "user":
                                            with st.chat_message("user"):
                                                st.markdown(content)
                                        else:
                                            with st.chat_message("assistant"):
                                                st.markdown(content)
                                
                                # Поле ввода сообщения
                                user_input = st.chat_input("Введите ваш вопрос о комбинации товаров...")
                                
                                if user_input:
                                    # Добавляем сообщение пользователя в историю
                                    chat_history.append({"role": "user", "content": user_input})
                                    st.session_state[chat_key] = chat_history
                                    st.rerun()
                                
                                # Кнопки для быстрых вопросов
                                st.markdown("---")
                                st.markdown("#### 💡 Быстрые вопросы")
                                
                                quick_questions_col1, quick_questions_col2 = st.columns(2)
                                
                                with quick_questions_col1:
                                    if st.button("🔍 Проанализировать комбинацию", use_container_width=True, key=f"quick_analyze_{selected_combo_key}"):
                                        if combo_products_df_for_chat is not None and not combo_products_df_for_chat.empty:
                                            # Запускаем анализ комбинации
                                            category = "Рашрашд мужской (компрессионная одежда)"
                                            
                                            with st.spinner("🔄 Анализирую комбинацию товаров..."):
                                                analysis_result = analyze_combination_products_with_ai(
                                                    combo_products_df_for_chat,
                                                    selected_combo_key,
                                                    category=category
                                                )
                                                
                                                if "error" not in analysis_result:
                                                    # Формируем ответ на основе анализа
                                                    response_parts = []
                                                    response_parts.append("✅ **Анализ комбинации завершен!**\n\n")
                                                    
                                                    if "common_characteristics" in analysis_result:
                                                        response_parts.append(f"📊 **Общие характеристики:**\n{analysis_result['common_characteristics']}\n\n")
                                                    
                                                    if "strengths" in analysis_result and analysis_result["strengths"]:
                                                        response_parts.append("✅ **Сильные стороны:**\n")
                                                        for strength in analysis_result["strengths"]:
                                                            response_parts.append(f"- {strength}\n")
                                                        response_parts.append("\n")
                                                    
                                                    if "weaknesses" in analysis_result and analysis_result["weaknesses"]:
                                                        response_parts.append("⚠️ **Слабые стороны:**\n")
                                                        for weakness in analysis_result["weaknesses"]:
                                                            response_parts.append(f"- {weakness}\n")
                                                        response_parts.append("\n")
                                                    
                                                    if "recommendations" in analysis_result and analysis_result["recommendations"]:
                                                        response_parts.append("💡 **Рекомендации:**\n")
                                                        for rec in analysis_result["recommendations"][:3]:  # Показываем первые 3
                                                            priority_emoji = "🔴" if rec.get("priority") == "high" else "🟡" if rec.get("priority") == "medium" else "🟢"
                                                            response_parts.append(f"{priority_emoji} **{rec.get('category', 'Общее')}:** {rec.get('recommendation', '')}\n")
                                                        response_parts.append("\n")
                                                    
                                                    response = "".join(response_parts)
                                                    
                                                    # Добавляем ответ в историю
                                                    chat_history.append({"role": "assistant", "content": response})
                                                    st.session_state[chat_key] = chat_history
                                                    st.session_state[f'ai_analysis_{selected_combo_key}'] = analysis_result
                                                    st.rerun()
                                                else:
                                                    error_msg = f"❌ Ошибка анализа: {analysis_result.get('error', 'Неизвестная ошибка')}"
                                                    chat_history.append({"role": "assistant", "content": error_msg})
                                                    st.session_state[chat_key] = chat_history
                                                    st.rerun()
                                        else:
                                            st.warning("⚠️ Нет данных о товарах комбинации")
                                    
                                    if st.button("📊 Показать характеристики", use_container_width=True, key=f"quick_characteristics_{selected_combo_key}"):
                                        if combo_products_df_for_chat is not None and not combo_products_df_for_chat.empty:
                                            # Формируем ответ с характеристиками
                                            response_parts = []
                                            response_parts.append("📊 **Характеристики комбинации:**\n\n")
                                            
                                            # Базовые метрики
                                            if "Заказы" in combo_products_df_for_chat.columns:
                                                total_orders = combo_products_df_for_chat["Заказы"].sum()
                                                response_parts.append(f"📦 **Общие заказы:** {total_orders:,.0f} шт\n")
                                            
                                            if "Выручка" in combo_products_df_for_chat.columns:
                                                total_revenue = combo_products_df_for_chat["Выручка"].sum()
                                                response_parts.append(f"💰 **Общая выручка:** {total_revenue:,.0f} ₽\n")
                                            
                                            if "Средняя цена" in combo_products_df_for_chat.columns:
                                                avg_price = combo_products_df_for_chat["Средняя цена"].mean()
                                                response_parts.append(f"🏷️ **Средняя цена:** {avg_price:,.0f} ₽\n")
                                            
                                            response_parts.append(f"\n📋 **Количество товаров в комбинации:** {len(combo_products_df_for_chat)}")
                                            
                                            response = "".join(response_parts)
                                            chat_history.append({"role": "user", "content": "Покажи характеристики комбинации"})
                                            chat_history.append({"role": "assistant", "content": response})
                                            st.session_state[chat_key] = chat_history
                                            st.rerun()
                                        else:
                                            st.warning("⚠️ Нет данных о товарах комбинации")
                                
                                with quick_questions_col2:
                                    if st.button("💡 Получить рекомендации", use_container_width=True, key=f"quick_recommendations_{selected_combo_key}"):
                                        # Используем сохраненный анализ, если есть
                                        if f'ai_analysis_{selected_combo_key}' in st.session_state:
                                            analysis_result = st.session_state[f'ai_analysis_{selected_combo_key}']
                                            if "error" not in analysis_result and "recommendations" in analysis_result:
                                                response_parts = []
                                                response_parts.append("💡 **Рекомендации по улучшению комбинации:**\n\n")
                                                
                                                for rec in analysis_result["recommendations"]:
                                                    priority_emoji = "🔴" if rec.get("priority") == "high" else "🟡" if rec.get("priority") == "medium" else "🟢"
                                                    response_parts.append(f"{priority_emoji} **{rec.get('category', 'Общее')}:**\n")
                                                    response_parts.append(f"{rec.get('recommendation', '')}\n")
                                                    if rec.get('expected_impact'):
                                                        response_parts.append(f"💭 *Ожидаемый эффект: {rec['expected_impact']}*\n")
                                                    response_parts.append("\n")
                                                
                                                response = "".join(response_parts)
                                                chat_history.append({"role": "user", "content": "Дай рекомендации"})
                                                chat_history.append({"role": "assistant", "content": response})
                                                st.session_state[chat_key] = chat_history
                                                st.rerun()
                                            else:
                                                st.info("ℹ️ Сначала выполните анализ комбинации, нажав кнопку 'Проанализировать комбинацию'")
                                        else:
                                            st.info("ℹ️ Сначала выполните анализ комбинации, нажав кнопку 'Проанализировать комбинацию'")
                                    
                                    if st.button("🗑️ Очистить чат", use_container_width=True, key=f"clear_chat_{selected_combo_key}"):
                                        st.session_state[chat_key] = []
                                        st.rerun()
                        
                        else:
                            st.warning(f"⚠️ Не удалось найти товары для комбинации: {selected_combo_key}")
        
        # Вкладка "Анализ отзывов"
        reviews_tab = None
        marketing_tab = None
        if PROPHET_AVAILABLE:
            reviews_tab = tab6  # после "🗺️ План продаж"
            marketing_tab = tab7
        else:
            reviews_tab = tab5
            marketing_tab = tab6
        
        # Вкладка "Расчет заказа"
        order_calc_tab = None
        if PROPHET_AVAILABLE:
            order_calc_tab = tab8  # таб после "📣 Маркетинг"
        else:
            order_calc_tab = tab7
        
        # Вкладка "Анализ отзывов"
        if reviews_tab is not None:
            with reviews_tab:
                st.subheader("📝 Анализ отзывов")
                reviews_cache_file = "ai_reviews_cache.json"
                reviews_cache = load_ai_cache(reviews_cache_file)
                
                def render_ai_reviews(result: dict):
                    if result.get("error"):
                        st.error(result["error"])
                        if result.get("raw_response"):
                            with st.expander("Показать сырой ответ ИИ", expanded=False):
                                st.text(result.get("raw_response", ""))
                        return
                    st.markdown("**Положительные стороны:**")
                    for item in result.get("positive", []):
                        st.write(f"- {item.get('topic')}: {item.get('percent')}%")
                    st.markdown("**Отрицательные стороны:**")
                    for item in result.get("negative", []):
                        st.write(f"- {item.get('topic')}: {item.get('percent')}%")
                    if result.get("improvements"):
                        st.markdown("**Что улучшить, чтобы быть конкурентнее:**")
                        for item in result.get("improvements", []):
                            st.write(f"- {item}")
                    if result.get("summary"):
                        st.info(result["summary"])
                
                # Проверяем наличие данных о комбинациях
                top_10_combinations = st.session_state.get('top_10_combinations', [])
                cleaned_combo_to_skus = st.session_state.get('cleaned_combo_to_skus', {})
                
                if not top_10_combinations:
                    st.info("ℹ️ Сначала перейдите во вкладку '📈 Аналитика по параметрам' и сформируйте топ комбинации.")
                else:
                    combo_list = []
                    for combo in top_10_combinations:
                        if isinstance(combo, dict):
                            combo_key = combo.get("Комбинация", "")
                        else:
                            combo_key = str(combo)
                        if combo_key and combo_key in cleaned_combo_to_skus:
                            skus = cleaned_combo_to_skus[combo_key]
                            if skus:
                                combo_display = f"{combo_key} ({len(skus)} товаров)"
                                combo_list.append((combo_display, combo_key))
                    
                    if not combo_list:
                        st.warning("⚠️ Не найдено комбинаций с товарами для анализа отзывов.")
                    else:
                        if len(combo_list) == 1:
                            _, selected_combo_key = combo_list[0]
                        else:
                            default_combo_key = st.session_state.get("selected_combo_key_global")
                            default_idx = 0
                            if default_combo_key:
                                for i, (_, key) in enumerate(combo_list):
                                    if key == default_combo_key:
                                        default_idx = i
                                        break
                            selected_combo_tuple = st.selectbox(
                                "📝 Выберите комбинацию для анализа отзывов:",
                                options=combo_list,
                                format_func=lambda x: x[0],
                                index=default_idx,
                                key="reviews_combo_select"
                            )
                            _, selected_combo_key = selected_combo_tuple
                        
                        if selected_combo_key in cleaned_combo_to_skus:
                            combo_skus = cleaned_combo_to_skus[selected_combo_key]
                            combo_skus, excluded_skus = filter_skus_by_analysis_with_details(combo_skus)
                            if excluded_skus:
                                excluded_preview = ", ".join([str(s) for s in excluded_skus[:10]])
                                suffix = f" (+{len(excluded_skus) - 10})" if len(excluded_skus) > 10 else ""
                                st.caption(
                                    f"🧹 Исключено артикулов из фильтра анализа: {len(excluded_skus)} "
                                    f"(фильтр «Анализ данных»). {excluded_preview}{suffix}"
                                )
                            
                            otziv_reports, otziv_missing = find_and_load_otziv_reports(tuple(combo_skus), "Otziv")
                            if otziv_missing:
                                st.warning(f"⚠️ Не прочитаны отчеты отзывов для {len(otziv_missing)} артикулов.")
                                st.markdown(
                                    "\n".join([f"- {sku}: {reason}" for sku, reason in otziv_missing.items()])
                                )
                            
                            if otziv_reports:
                                review_frames = []
                                for sku, info in otziv_reports.items():
                                    df_rev = info["data"].copy()
                                    df_rev.columns = df_rev.columns.astype(str).str.strip()
                                    
                                    sku_col = None
                                    for c in df_rev.columns:
                                        if "артикул" in c.lower():
                                            sku_col = c
                                            break
                                    if sku_col:
                                        df_rev = df_rev[df_rev[sku_col].astype(str).str.replace(".0", "") == str(sku)]
                                    
                                    date_col = None
                                    for c in df_rev.columns:
                                        if "дата" in c.lower():
                                            date_col = c
                                            break
                                    if date_col:
                                        df_rev[date_col] = (
                                            df_rev[date_col]
                                            .astype(str)
                                            .str.replace(r"\s*\\(.*\\)", "", regex=True)
                                        )
                                        df_rev[date_col] = pd.to_datetime(df_rev[date_col], errors="coerce")
                                    
                                    df_rev["__sku__"] = sku
                                    review_frames.append(df_rev)
                                
                                reviews_df = pd.concat(review_frames, ignore_index=True) if review_frames else pd.DataFrame()
                                
                                if not reviews_df.empty:
                                    date_col = None
                                    for c in reviews_df.columns:
                                        if "дата" in c.lower():
                                            date_col = c
                                            break
                                    if date_col and reviews_df[date_col].notna().any():
                                        min_date = reviews_df[date_col].min().date()
                                        max_date = reviews_df[date_col].max().date()
                                        date_range = st.date_input(
                                            "Период отзывов",
                                            value=(min_date, max_date),
                                            min_value=min_date,
                                            max_value=max_date
                                        )
                                        if isinstance(date_range, tuple) and len(date_range) == 2:
                                            start_r, end_r = date_range
                                            reviews_df = reviews_df[
                                                (reviews_df[date_col].dt.date >= start_r) &
                                                (reviews_df[date_col].dt.date <= end_r)
                                            ]
                                    
                                    rating_col = None
                                    for c in reviews_df.columns:
                                        if "оценка" in c.lower():
                                            rating_col = c
                                            break
                                    def show_rating_kpi(df, title_prefix=""):
                                        if not rating_col:
                                            return
                                        ratings = pd.to_numeric(df[rating_col], errors="coerce")
                                        avg_rating = ratings.mean() if ratings.notna().any() else 0
                                        total_reviews = int(ratings.notna().sum())
                                        share_5 = (ratings[ratings == 5].count() / total_reviews * 100) if total_reviews > 0 else 0
                                        share_1 = (ratings[ratings == 1].count() / total_reviews * 100) if total_reviews > 0 else 0
                                        
                                        st.markdown(f"**{title_prefix} KPI оценок**")
                                        k1, k2, k3, k4 = st.columns(4)
                                        with k1:
                                            st.metric("⭐ Средняя оценка", f"{avg_rating:.2f}")
                                        with k2:
                                            st.metric("📝 Отзывов", f"{total_reviews}")
                                        with k3:
                                            st.metric("👍 5★", f"{share_5:.1f}%")
                                        with k4:
                                            st.metric("👎 1★", f"{share_1:.1f}%")
                                    
                                    if rating_col:
                                        show_rating_kpi(reviews_df, "Общий")
                                    
                                    comment_col = None
                                    pros_col = None
                                    cons_col = None
                                    for c in reviews_df.columns:
                                        cl = c.lower()
                                        if "комментар" in cl:
                                            comment_col = c
                                        elif "достоин" in cl:
                                            pros_col = c
                                        elif "недостат" in cl:
                                            cons_col = c
                                    
                                    date_key = "all"
                                    if date_col and reviews_df[date_col].notna().any():
                                        date_key = f"{reviews_df[date_col].min().date()}_{reviews_df[date_col].max().date()}"
                                    cache_key_all = f"{selected_combo_key}|all|{date_key}"
                                    
                                    if cache_key_all in reviews_cache:
                                        st.info("ℹ️ Результат ИИ загружен из кеша.")
                                        render_ai_reviews(reviews_cache[cache_key_all])
                                        recalc_all = st.button("🔄 Пересчитать (общий анализ)", key=f"ai_reviews_tab_recalc_{selected_combo_key}")
                                    else:
                                        recalc_all = st.button("🤖 Проанализировать отзывы с ИИ", key=f"ai_reviews_tab_{selected_combo_key}")
                                    
                                    if recalc_all:
                                        api_key = st.session_state.get('openai_api_key', '') or st.secrets.get('openai_api_key', '')
                                        if not api_key:
                                            st.error("❌ Укажите OpenAI API ключ в настройках.")
                                        else:
                                            import utils.ai_analysis as ai_module
                                            ai_module = importlib.reload(ai_module)
                                            ai_result = ai_module.analyze_reviews_with_ai_core(
                                                comments=reviews_df[comment_col].tolist() if comment_col else [],
                                                advantages=reviews_df[pros_col].tolist() if pros_col else [],
                                                disadvantages=reviews_df[cons_col].tolist() if cons_col else [],
                                                api_key=api_key
                                            )
                                            reviews_cache[cache_key_all] = ai_result
                                            save_ai_cache(reviews_cache_file, reviews_cache)
                                            render_ai_reviews(ai_result)
                                    
                                    # Анализ по планам (низкий/средний/высокий)
                                    st.markdown("### 📌 Анализ отзывов по планам")
                                    all_combo_skus = sorted([str(sku).replace(".0", "") for sku in combo_skus if sku and str(sku).lower() not in ['nan', 'none', '']])
                                    total_skus = len(all_combo_skus)
                                    low_plan_skus = set()
                                    mid_plan_skus = set()
                                    high_plan_skus = set()
                                    if total_skus > 0:
                                        high_count = max(1, int(total_skus / 3))
                                        high_plan_skus = set(all_combo_skus[:high_count])
                                        mid_start = high_count
                                        mid_end = mid_start + max(1, int(total_skus / 3))
                                        if mid_end > mid_start and mid_end <= total_skus:
                                            mid_plan_skus = set(all_combo_skus[mid_start:mid_end])
                                        else:
                                            mid_plan_skus = set(all_combo_skus[mid_start:])
                                        low_start = mid_end if mid_end <= total_skus else mid_start
                                        low_plan_skus = set(all_combo_skus[low_start:])
                                    
                                    def plan_reviews_df(plan_skus_set):
                                        if "__sku__" not in reviews_df.columns:
                                            return reviews_df.iloc[0:0]
                                        return reviews_df[reviews_df["__sku__"].astype(str).isin(plan_skus_set)].copy()
                                    
                                    plan_blocks = [
                                        ("📉 Низкий план", low_plan_skus, "low"),
                                        ("📊 Средний план", mid_plan_skus, "mid"),
                                        ("📈 Высокий план", high_plan_skus, "high")
                                    ]
                                    
                                    for plan_label, plan_skus_set, plan_key_suffix in plan_blocks:
                                        df_plan = plan_reviews_df(plan_skus_set)
                                        st.markdown(f"**{plan_label}**")
                                        if df_plan.empty:
                                            st.info("ℹ️ Нет отзывов по артикулу(ам) этого плана.")
                                            continue
                                        show_rating_kpi(df_plan, plan_label)
                                        
                                        plan_cache_key = f"{selected_combo_key}|plan:{plan_key_suffix}|{date_key}"
                                        if plan_cache_key in reviews_cache:
                                            st.info("ℹ️ Результат ИИ загружен из кеша.")
                                            render_ai_reviews(reviews_cache[plan_cache_key])
                                            recalc_plan = st.button(f"🔄 Пересчитать ({plan_label})", key=f"ai_reviews_plan_recalc_{plan_key_suffix}_{selected_combo_key}")
                                        else:
                                            recalc_plan = st.button(f"🤖 ИИ анализ ({plan_label})", key=f"ai_reviews_plan_{plan_key_suffix}_{selected_combo_key}")
                                        
                                        if recalc_plan:
                                            api_key = st.session_state.get('openai_api_key', '') or st.secrets.get('openai_api_key', '')
                                            if not api_key:
                                                st.error("❌ Укажите OpenAI API ключ в настройках.")
                                            else:
                                                import utils.ai_analysis as ai_module
                                                ai_module = importlib.reload(ai_module)
                                                ai_result = ai_module.analyze_reviews_with_ai_core(
                                                    comments=df_plan[comment_col].tolist() if comment_col else [],
                                                    advantages=df_plan[pros_col].tolist() if pros_col else [],
                                                    disadvantages=df_plan[cons_col].tolist() if cons_col else [],
                                                    api_key=api_key
                                                )
                                                reviews_cache[plan_cache_key] = ai_result
                                                save_ai_cache(reviews_cache_file, reviews_cache)
                                                render_ai_reviews(ai_result)
                                    
                                    # Анализ по каждому артикулу
                                    st.markdown("### 🔍 Анализ отзывов по каждому артикулу")
                                    if "__sku__" in reviews_df.columns:
                                        for sku in sorted(reviews_df["__sku__"].dropna().astype(str).unique()):
                                            df_sku = reviews_df[reviews_df["__sku__"].astype(str) == sku]
                                            st.markdown(f"**Артикул {sku}**")
                                            if df_sku.empty:
                                                st.info("ℹ️ Нет отзывов.")
                                                continue
                                            show_rating_kpi(df_sku, f"Артикул {sku}")
                                            
                                            sku_cache_key = f"{selected_combo_key}|sku:{sku}|{date_key}"
                                            if sku_cache_key in reviews_cache:
                                                st.info("ℹ️ Результат ИИ загружен из кеша.")
                                                render_ai_reviews(reviews_cache[sku_cache_key])
                                                recalc_sku = st.button(f"🔄 Пересчитать (артикул {sku})", key=f"ai_reviews_sku_recalc_{sku}_{selected_combo_key}")
                                            else:
                                                recalc_sku = st.button(f"🤖 ИИ анализ (артикул {sku})", key=f"ai_reviews_sku_{sku}_{selected_combo_key}")
                                            
                                            if recalc_sku:
                                                api_key = st.session_state.get('openai_api_key', '') or st.secrets.get('openai_api_key', '')
                                                if not api_key:
                                                    st.error("❌ Укажите OpenAI API ключ в настройках.")
                                                else:
                                                    import utils.ai_analysis as ai_module
                                                    ai_module = importlib.reload(ai_module)
                                                    ai_result = ai_module.analyze_reviews_with_ai_core(
                                                        comments=df_sku[comment_col].tolist() if comment_col else [],
                                                        advantages=df_sku[pros_col].tolist() if pros_col else [],
                                                        disadvantages=df_sku[cons_col].tolist() if cons_col else [],
                                                        api_key=api_key
                                                    )
                                                    reviews_cache[sku_cache_key] = ai_result
                                                    save_ai_cache(reviews_cache_file, reviews_cache)
                                                    render_ai_reviews(ai_result)
                                else:
                                    st.info("ℹ️ Нет отзывов для выбранной комбинации.")
        
        # Вкладка "Маркетинг"
        if marketing_tab is not None:
            with marketing_tab:
                st.subheader("📣 Маркетинг")
                marketing_cache_file = "ai_marketing_cache.json"
                marketing_cache = load_ai_cache(marketing_cache_file)
                
                # Проверяем наличие данных о комбинациях
                top_10_combinations = st.session_state.get('top_10_combinations', [])
                cleaned_combo_to_skus = st.session_state.get('cleaned_combo_to_skus', {})
                
                if not top_10_combinations:
                    st.info("ℹ️ Сначала перейдите во вкладку '📈 Аналитика по параметрам' и сформируйте топ комбинации.")
                else:
                    combo_list = []
                    for combo in top_10_combinations:
                        if isinstance(combo, dict):
                            combo_key = combo.get("Комбинация", "")
                        else:
                            combo_key = str(combo)
                        if combo_key and combo_key in cleaned_combo_to_skus:
                            skus = cleaned_combo_to_skus[combo_key]
                            if skus:
                                combo_display = f"{combo_key} ({len(skus)} товаров)"
                                combo_list.append((combo_display, combo_key))
                    
                    if not combo_list:
                        st.warning("⚠️ Не найдено комбинаций с товарами для маркетинг-анализа.")
                    else:
                        if len(combo_list) == 1:
                            _, selected_combo_key = combo_list[0]
                        else:
                            default_combo_key = st.session_state.get("selected_combo_key_global")
                            default_idx = 0
                            if default_combo_key:
                                for i, (_, key) in enumerate(combo_list):
                                    if key == default_combo_key:
                                        default_idx = i
                                        break
                            selected_combo_tuple = st.selectbox(
                                "📣 Выберите комбинацию для маркетинг-анализа:",
                                options=combo_list,
                                format_func=lambda x: x[0],
                                index=default_idx,
                                key="marketing_combo_select"
                            )
                            _, selected_combo_key = selected_combo_tuple
                        
                        if selected_combo_key in cleaned_combo_to_skus:
                            combo_skus = cleaned_combo_to_skus[selected_combo_key]
                            combo_skus, excluded_skus = filter_skus_by_analysis_with_details(combo_skus)
                            if excluded_skus:
                                excluded_preview = ", ".join([str(s) for s in excluded_skus[:10]])
                                suffix = f" (+{len(excluded_skus) - 10})" if len(excluded_skus) > 10 else ""
                                st.caption(
                                    f"🧹 Исключено артикулов из фильтра анализа: {len(excluded_skus)} "
                                    f"(фильтр «Анализ данных»). {excluded_preview}{suffix}"
                                )
                            
                            # Формируем планы (как в заказе)
                            all_combo_skus = sorted([str(sku).replace(".0", "") for sku in combo_skus if sku and str(sku).lower() not in ['nan', 'none', '']])
                            total_skus = len(all_combo_skus)
                            low_plan_skus = set()
                            mid_plan_skus = set()
                            high_plan_skus = set()
                            if total_skus > 0:
                                high_count = max(1, int(total_skus / 3))
                                high_plan_skus = set(all_combo_skus[:high_count])
                                mid_start = high_count
                                mid_end = mid_start + max(1, int(total_skus / 3))
                                if mid_end > mid_start and mid_end <= total_skus:
                                    mid_plan_skus = set(all_combo_skus[mid_start:mid_end])
                                else:
                                    mid_plan_skus = set(all_combo_skus[mid_start:])
                                low_start = mid_end if mid_end <= total_skus else mid_start
                                low_plan_skus = set(all_combo_skus[low_start:])
                            
                            def collect_images(skus_list):
                                image_paths = []
                                missing = []
                                import utils.image_cache as image_cache
                                for sku in skus_list:
                                    sku_str = str(sku).replace(".0", "")
                                    # Берем все загруженные изображения из кеша (если есть)
                                    cached_paths = image_cache.get_cached_images_for_sku(sku_str)
                                    cached_paths = [p for p in cached_paths if p and os.path.exists(p)]
                                    if cached_paths:
                                        image_paths.extend(cached_paths)
                                    else:
                                        img_path = image_cache.get_cached_image_path(sku_str)
                                        if img_path and os.path.exists(img_path):
                                            image_paths.append(img_path)
                                        else:
                                            missing.append(sku_str)
                                return image_paths, missing
                            
                            def render_marketing_result(result: dict):
                                if result.get("error"):
                                    st.error(result["error"])
                                    if result.get("raw_response"):
                                        with st.expander("Показать сырой ответ ИИ", expanded=False):
                                            st.text(result.get("raw_response", ""))
                                    return
                                st.markdown("**Инсайты:**")
                                for item in result.get("insights", []):
                                    st.write(f"- {item}")
                                if result.get("color_scheme"):
                                    st.markdown("**Цветовая схема:**")
                                    for item in result.get("color_scheme", []):
                                        st.write(f"- {item}")
                                if result.get("positioning"):
                                    st.markdown("**Позиционирование/конкурентность:**")
                                    for item in result.get("positioning", []):
                                        st.write(f"- {item}")
                                if result.get("expert_opinion"):
                                    st.markdown("**Экспертное мнение маркетолога:**")
                                    st.write(result.get("expert_opinion"))
                                if result.get("designer_opinion"):
                                    st.markdown("**Мнение дизайнера:**")
                                    st.write(result.get("designer_opinion"))
                                if result.get("summary"):
                                    st.info(result["summary"])
                            
                            # Общий анализ по всем товарам
                            st.markdown("### 🧠 Общий анализ главных фото (все товары)")
                            all_images, all_missing = collect_images(all_combo_skus)
                            if all_missing:
                                st.warning(f"⚠️ Нет главного фото для артикулов: {', '.join(all_missing[:10])}{'...' if len(all_missing) > 10 else ''}")
                            if all_images:
                                cache_key = f"{selected_combo_key}|all|marketing"
                                if cache_key in marketing_cache:
                                    st.info("ℹ️ Результат ИИ загружен из кеша.")
                                    render_marketing_result(marketing_cache[cache_key])
                                    recalc = st.button("🔄 Пересчитать (общий)", key=f"marketing_recalc_all_{selected_combo_key}")
                                else:
                                    recalc = st.button("🤖 Проанализировать (общий)", key=f"marketing_analyze_all_{selected_combo_key}")
                                
                                if recalc:
                                    api_key = st.session_state.get('openai_api_key', '') or st.secrets.get('openai_api_key', '')
                                    if not api_key:
                                        st.error("❌ Укажите OpenAI API ключ в настройках.")
                                    else:
                                        import utils.ai_analysis as ai_module
                                        ai_module = importlib.reload(ai_module)
                                        result = ai_module.analyze_marketing_images_with_ai_core(
                                            image_paths=all_images[:8],
                                            api_key=api_key,
                                            product_name=selected_combo_key
                                        )
                                        marketing_cache[cache_key] = result
                                        save_ai_cache(marketing_cache_file, marketing_cache)
                                        render_marketing_result(result)
                            else:
                                st.info("ℹ️ Нет доступных изображений для анализа.")
                            
                            # Анализ по планам
                            st.markdown("### 📌 Анализ по планам")
                            plan_blocks = [
                                ("📉 Низкий план", low_plan_skus, "low"),
                                ("📊 Средний план", mid_plan_skus, "mid"),
                                ("📈 Высокий план", high_plan_skus, "high")
                            ]
                            for plan_label, plan_skus_set, plan_key_suffix in plan_blocks:
                                st.markdown(f"**{plan_label}**")
                                images, missing = collect_images(plan_skus_set)
                                if missing:
                                    st.warning(f"⚠️ Нет главного фото для: {', '.join(list(missing)[:10])}{'...' if len(missing) > 10 else ''}")
                                if images:
                                    cache_key = f"{selected_combo_key}|plan:{plan_key_suffix}|marketing"
                                    if cache_key in marketing_cache:
                                        st.info("ℹ️ Результат ИИ загружен из кеша.")
                                        render_marketing_result(marketing_cache[cache_key])
                                        recalc = st.button(f"🔄 Пересчитать ({plan_label})", key=f"marketing_recalc_{plan_key_suffix}_{selected_combo_key}")
                                    else:
                                        recalc = st.button(f"🤖 Проанализировать ({plan_label})", key=f"marketing_analyze_{plan_key_suffix}_{selected_combo_key}")
                                    
                                    if recalc:
                                        api_key = st.session_state.get('openai_api_key', '') or st.secrets.get('openai_api_key', '')
                                        if not api_key:
                                            st.error("❌ Укажите OpenAI API ключ в настройках.")
                                        else:
                                            import utils.ai_analysis as ai_module
                                            ai_module = importlib.reload(ai_module)
                                            result = ai_module.analyze_marketing_images_with_ai_core(
                                                image_paths=images[:8],
                                                api_key=api_key,
                                                product_name=selected_combo_key
                                            )
                                            marketing_cache[cache_key] = result
                                            save_ai_cache(marketing_cache_file, marketing_cache)
                                            render_marketing_result(result)
                                else:
                                    st.info("ℹ️ Нет изображений для анализа в этом плане.")
        
        if order_calc_tab is not None:
            with order_calc_tab:
                st.subheader("📦 Расчет заказа товара")
                
                # Проверяем наличие данных о комбинациях
                top_10_combinations = st.session_state.get('top_10_combinations', [])
                cleaned_combo_to_skus = st.session_state.get('cleaned_combo_to_skus', {})
                
                if not top_10_combinations:
                    st.info("ℹ️ Сначала перейдите во вкладку '📈 Аналитика по параметрам' и сформируйте топ комбинации, чтобы использовать расчет заказа.")
                else:
                    # Формируем список всех комбинаций для выбора
                    combo_list = []
                    
                    for combo in top_10_combinations:
                        # combo - это словарь с ключом "Комбинация" (уже очищенная комбинация)
                        if isinstance(combo, dict):
                            combo_key = combo.get("Комбинация", "")
                        else:
                            combo_key = str(combo)
                        
                        # В regrouped_analytics сохраняется уже очищенная комбинация (cleaned_combo_str)
                        # которая должна совпадать с ключами в cleaned_combo_to_skus
                        if combo_key and combo_key in cleaned_combo_to_skus:
                            skus = cleaned_combo_to_skus[combo_key]
                            if skus:  # Проверяем, что есть товары
                                combo_display = f"{combo_key} ({len(skus)} товаров)"
                                combo_list.append((combo_display, combo_key))
                    
                    if not combo_list:
                        st.warning("⚠️ Не найдено комбинаций с товарами для расчета заказа.")
                    elif combo_list:
                        # Отслеживаем предыдущую выбранную комбинацию
                        last_combo_key = st.session_state.get("last_order_calc_combo_key", None)
                        
                        if len(combo_list) == 1:
                            selected_combo_display, selected_combo_key = combo_list[0]
                        else:
                            default_combo_key = st.session_state.get("selected_combo_key_global")
                            default_idx = 0
                            if default_combo_key:
                                for i, (_, key) in enumerate(combo_list):
                                    if key == default_combo_key:
                                        default_idx = i
                                        break
                            selected_combo_tuple = st.selectbox(
                                "📦 Выберите комбинацию товаров:",
                                options=combo_list,
                                format_func=lambda x: x[0],
                                index=default_idx,
                                key="order_calc_combo_select"
                            )
                            selected_combo_display, selected_combo_key = selected_combo_tuple
                        
                        # Если комбинация изменилась, сбрасываем параметры
                        if last_combo_key != selected_combo_key:
                            # Очищаем все параметры для всех планов старой комбинации
                            for plan_type in ["low", "mid", "high"]:
                                old_plan_key = f"{last_combo_key}_{plan_type}" if last_combo_key else None
                                if old_plan_key:
                                    if f"start_date_{old_plan_key}" in st.session_state:
                                        del st.session_state[f"start_date_{old_plan_key}"]
                                    if f"calculation_days_{old_plan_key}" in st.session_state:
                                        del st.session_state[f"calculation_days_{old_plan_key}"]
                                    if f"safety_stock_pct_{old_plan_key}" in st.session_state:
                                        del st.session_state[f"safety_stock_pct_{old_plan_key}"]
                                    if f"min_end_stock_pct_{old_plan_key}" in st.session_state:
                                        del st.session_state[f"min_end_stock_pct_{old_plan_key}"]
                            # Очищаем все параметры для всех планов новой комбинации (чтобы сбросить к значениям по умолчанию)
                            for plan_type in ["low", "mid", "high"]:
                                new_plan_key = f"{selected_combo_key}_{plan_type}"
                                if f"start_date_{new_plan_key}" in st.session_state:
                                    del st.session_state[f"start_date_{new_plan_key}"]
                                if f"calculation_days_{new_plan_key}" in st.session_state:
                                    del st.session_state[f"calculation_days_{new_plan_key}"]
                                if f"safety_stock_pct_{new_plan_key}" in st.session_state:
                                    del st.session_state[f"safety_stock_pct_{new_plan_key}"]
                                if f"min_end_stock_pct_{new_plan_key}" in st.session_state:
                                    del st.session_state[f"min_end_stock_pct_{new_plan_key}"]
                            # Сбрасываем last_plan_key, чтобы параметры сбросились при следующем выборе плана
                            if "last_order_calc_plan_key" in st.session_state:
                                del st.session_state["last_order_calc_plan_key"]
                            # Сохраняем новую комбинацию
                            st.session_state["last_order_calc_combo_key"] = selected_combo_key
                        
                        # Получаем товары комбинации
                        if selected_combo_key in cleaned_combo_to_skus:
                            combo_skus = cleaned_combo_to_skus[selected_combo_key]
                            # Применяем фильтр артикулов из "Анализ данных"
                            combo_skus, excluded_skus = filter_skus_by_analysis_with_details(combo_skus)
                            if excluded_skus:
                                excluded_preview = ", ".join([str(s) for s in excluded_skus[:10]])
                                suffix = f" (+{len(excluded_skus) - 10})" if len(excluded_skus) > 10 else ""
                                st.caption(
                                    f"🧹 Исключено артикулов из фильтра анализа: {len(excluded_skus)} "
                                    f"(фильтр «Анализ данных»). {excluded_preview}{suffix}"
                                )
                            
                            # ========== АНАЛИЗ ОТЗЫВОВ (удобный блок сразу после выбора комбинации) ==========
                            with st.expander("📝 Анализ отзывов", expanded=False):
                                otziv_reports, otziv_missing = find_and_load_otziv_reports(tuple(combo_skus), "Otziv")
                                if otziv_missing:
                                    st.warning(f"⚠️ Не прочитаны отчеты отзывов для {len(otziv_missing)} артикулов.")
                                    with st.expander("Причины (отзывы)", expanded=False):
                                        st.markdown(
                                            "\n".join([f"- {sku}: {reason}" for sku, reason in otziv_missing.items()])
                                        )
                                
                                if otziv_reports:
                                    review_frames = []
                                    for sku, info in otziv_reports.items():
                                        df_rev = info["data"].copy()
                                        # Нормализуем колонки
                                        df_rev.columns = df_rev.columns.astype(str).str.strip()
                                        
                                        # Фильтр по артикулу
                                        sku_col = None
                                        for c in df_rev.columns:
                                            if "артикул" in c.lower():
                                                sku_col = c
                                                break
                                        if sku_col:
                                            df_rev = df_rev[df_rev[sku_col].astype(str).str.replace(".0", "") == str(sku)]
                                        
                                        # Парсинг даты
                                        date_col = None
                                        for c in df_rev.columns:
                                            if "дата" in c.lower():
                                                date_col = c
                                                break
                                        if date_col:
                                            df_rev[date_col] = (
                                                df_rev[date_col]
                                                .astype(str)
                                                .str.replace(r"\s*\\(.*\\)", "", regex=True)
                                            )
                                            df_rev[date_col] = pd.to_datetime(df_rev[date_col], errors="coerce")
                                        
                                        df_rev["__sku__"] = sku
                                        review_frames.append(df_rev)
                                    
                                    reviews_df = pd.concat(review_frames, ignore_index=True) if review_frames else pd.DataFrame()
                                    
                                    if not reviews_df.empty:
                                        # Фильтр по датам
                                        date_col = None
                                        for c in reviews_df.columns:
                                            if "дата" in c.lower():
                                                date_col = c
                                                break
                                        if date_col and reviews_df[date_col].notna().any():
                                            min_date = reviews_df[date_col].min().date()
                                            max_date = reviews_df[date_col].max().date()
                                            date_range = st.date_input(
                                                "Период отзывов",
                                                value=(min_date, max_date),
                                                min_value=min_date,
                                                max_value=max_date
                                            )
                                            if isinstance(date_range, tuple) and len(date_range) == 2:
                                                start_r, end_r = date_range
                                                reviews_df = reviews_df[
                                                    (reviews_df[date_col].dt.date >= start_r) &
                                                    (reviews_df[date_col].dt.date <= end_r)
                                                ]
                                        
                                        # KPI по оценкам
                                        rating_col = None
                                        for c in reviews_df.columns:
                                            if "оценка" in c.lower():
                                                rating_col = c
                                                break
                                        if rating_col:
                                            ratings = pd.to_numeric(reviews_df[rating_col], errors="coerce")
                                            avg_rating = ratings.mean() if ratings.notna().any() else 0
                                            total_reviews = int(ratings.notna().sum())
                                            share_5 = (ratings[ratings == 5].count() / total_reviews * 100) if total_reviews > 0 else 0
                                            share_1 = (ratings[ratings == 1].count() / total_reviews * 100) if total_reviews > 0 else 0
                                            
                                            k1, k2, k3, k4 = st.columns(4)
                                            with k1:
                                                st.metric("⭐ Средняя оценка", f"{avg_rating:.2f}")
                                            with k2:
                                                st.metric("📝 Отзывов", f"{total_reviews}")
                                            with k3:
                                                st.metric("👍 5★", f"{share_5:.1f}%")
                                            with k4:
                                                st.metric("👎 1★", f"{share_1:.1f}%")
                                        
                                        # ИИ анализ комментариев/достоинств/недостатков
                                        comment_col = None
                                        pros_col = None
                                        cons_col = None
                                        for c in reviews_df.columns:
                                            cl = c.lower()
                                            if "комментар" in cl:
                                                comment_col = c
                                            elif "достоин" in cl:
                                                pros_col = c
                                            elif "недостат" in cl:
                                                cons_col = c
                                        
                                        if st.button("🤖 Проанализировать отзывы с ИИ", key=f"ai_reviews_{selected_combo_key}"):
                                            api_key = st.session_state.get('openai_api_key', '') or st.secrets.get('openai_api_key', '')
                                            if not api_key:
                                                st.error("❌ Укажите OpenAI API ключ в настройках.")
                                            else:
                                                ai_result = analyze_reviews_with_ai_core(
                                                    comments=reviews_df[comment_col].tolist() if comment_col else [],
                                                    advantages=reviews_df[pros_col].tolist() if pros_col else [],
                                                    disadvantages=reviews_df[cons_col].tolist() if cons_col else [],
                                                    api_key=api_key
                                                )
                                                if ai_result.get("error"):
                                                    st.error(ai_result["error"])
                                                else:
                                                    st.markdown("**Положительные стороны:**")
                                                    for item in ai_result.get("positive", []):
                                                        st.write(f"- {item.get('topic')}: {item.get('percent')}%")
                                                    st.markdown("**Отрицательные стороны:**")
                                                    for item in ai_result.get("negative", []):
                                                        st.write(f"- {item.get('topic')}: {item.get('percent')}%")
                                                    if ai_result.get("summary"):
                                                        st.info(ai_result["summary"])
                                    else:
                                        st.info("ℹ️ Нет отзывов для выбранной комбинации.")
                            
                            # Проверяем наличие отчетов для комбинации
                            combo_report_key = f"report_{selected_combo_key}"
                            # Проверяем наличие таблицы планов из вкладки "План продаж"
                            plan_details_key = f'plan_details_table_{selected_combo_key}'
                            plan_details_table = st.session_state.get(plan_details_key, None)
                            
                            if plan_details_table is None:
                                st.warning("⚠️ Для расчета заказа необходимо сначала построить план продаж во вкладке '🗺️ План продаж'. Таблица детализации планов по дням будет создана автоматически.")
                            else:
                                # Используем таблицу планов из вкладки "План продаж"
                                total_days_in_table = len(plan_details_table)
                                if total_days_in_table > 0:
                                    # Определяем диапазон дат в таблице
                                    dates_in_table = []
                                    for day_detail in plan_details_table:
                                        day_date = day_detail['Дата']
                                        if isinstance(day_date, str):
                                            day_date = pd.Timestamp(day_date)
                                        elif hasattr(day_date, 'date'):
                                            day_date = pd.Timestamp(day_date)
                                        dates_in_table.append(day_date)
                                    
                                    if dates_in_table:
                                        min_date = min(dates_in_table)
                                        max_date = max(dates_in_table)
                                        st.success(f"✅ Таблица планов загружена: {total_days_in_table} дней (с {min_date.strftime('%d.%m.%Y') if hasattr(min_date, 'strftime') else str(min_date)[:10]} по {max_date.strftime('%d.%m.%Y') if hasattr(max_date, 'strftime') else str(max_date)[:10]})")
                                    else:
                                        st.info(f"ℹ️ Таблица планов загружена: {total_days_in_table} дней")
                                else:
                                    st.warning("⚠️ Таблица планов пуста. Постройте план продаж во вкладке '🗺️ План продаж'.")
                                
                                # Выбор плана для расчета
                                st.markdown("#### 📦 Выбор плана для расчета заказа")
                                
                                plan_options = [
                                    "📉 Низкий план",
                                    "📊 Средний план",
                                    "📈 Высокий план"
                                ]
                                
                                selected_plan_display = st.selectbox(
                                    "Выберите план:",
                                    options=plan_options,
                                    index=1,  # По умолчанию средний план
                                    key="order_calc_plan_select"
                                )
                                
                                if "Низкий" in selected_plan_display:
                                    selected_plan_type = "low"
                                    plan_column = "Низкий план (среднее)"
                                elif "Высокий" in selected_plan_display:
                                    selected_plan_type = "high"
                                    plan_column = "Высокий план (среднее)"
                                else:
                                    selected_plan_type = "mid"
                                    plan_column = "Средний план (среднее)"
                                
                                # Параметры расчета
                                st.markdown("#### ⚙️ Параметры расчета")
                                
                                col1, col2, col3, col4 = st.columns(4)
                                
                                plan_key = f"{selected_combo_key}_{selected_plan_type}"
                                
                                # Проверяем, изменилась ли комбинация или план
                                last_plan_key_key = "last_order_calc_plan_key"
                                last_plan_key = st.session_state.get(last_plan_key_key, None)
                                
                                # Если комбинация или план изменились, сбрасываем параметры
                                if last_plan_key != plan_key:
                                    # Удаляем старые значения параметров для нового ключа
                                    if f"start_date_{plan_key}" in st.session_state:
                                        del st.session_state[f"start_date_{plan_key}"]
                                    if f"calculation_days_{plan_key}" in st.session_state:
                                        del st.session_state[f"calculation_days_{plan_key}"]
                                    if f"safety_stock_pct_{plan_key}" in st.session_state:
                                        del st.session_state[f"safety_stock_pct_{plan_key}"]
                                    if f"min_end_stock_pct_{plan_key}" in st.session_state:
                                        del st.session_state[f"min_end_stock_pct_{plan_key}"]
                                    # Сохраняем новый ключ
                                    st.session_state[last_plan_key_key] = plan_key
                                
                                with col1:
                                    # Начальная дата расчета
                                    from datetime import datetime, timedelta
                                    today = datetime.now().date()
                                    start_date = st.date_input(
                                        "📅 Начало периода расчета",
                                        value=st.session_state.get(f"start_date_{plan_key}", today),
                                        key=f"start_date_input_{plan_key}"
                                    )
                                    st.session_state[f"start_date_{plan_key}"] = start_date
                                
                                with col2:
                                    # Период расчета (в днях) - например, срок производства
                                    calculation_days = st.number_input(
                                        "📆 Период расчета, дней",
                                        min_value=1,
                                        value=st.session_state.get(f"calculation_days_{plan_key}", 60),
                                        step=1,
                                        key=f"calculation_days_input_{plan_key}"
                                    )
                                    st.session_state[f"calculation_days_{plan_key}"] = calculation_days
                                    
                                    # Конечная дата периода
                                    end_date = start_date + timedelta(days=calculation_days - 1)
                                    st.metric("📅 Конец периода", end_date.strftime("%d.%m.%Y"))
                                
                                with col3:
                                    # Текущие остатки
                                    current_stock = st.number_input(
                                        "📦 Текущие остатки, шт",
                                        min_value=0,
                                        value=0,
                                        step=1,
                                        key=f"current_stock_{plan_key}"
                                    )
                                    
                                    # Процент выкупа
                                    buyout_pct = st.session_state.get("buyout_pct", 25)
                                    st.metric("📈 Процент выкупа", f"{buyout_pct}%")
                                    buyout_k = buyout_pct / 100.0
                                
                                with col4:
                                    # Запас (в процентах)
                                    safety_stock_pct = st.number_input(
                                        "🛡️ Запас, %",
                                        min_value=0,
                                        max_value=100,
                                        value=st.session_state.get(f"safety_stock_pct_{plan_key}", 5),
                                        step=1,
                                        key=f"safety_stock_pct_input_{plan_key}"
                                    )
                                    st.session_state[f"safety_stock_pct_{plan_key}"] = safety_stock_pct
                                    
                                    # Минимальный запас на остатках (в процентах)
                                    min_end_stock_pct = st.number_input(
                                        "📦 Запас на остатках (мин.), %",
                                        min_value=0.0,
                                        max_value=100.0,
                                        value=float(st.session_state.get(f"min_end_stock_pct_{plan_key}", 5.0)),
                                        step=0.1,
                                        key=f"min_end_stock_pct_input_{plan_key}",
                                        help="Минимальный остаток на конец периода в процентах от суммы заказов"
                                    )
                                    st.session_state[f"min_end_stock_pct_{plan_key}"] = min_end_stock_pct
                                    
                                    # Дни возврата
                                    return_days = 7
                                    st.metric("🔄 Дни до возврата", f"{return_days} дней")
                                
                                # Используем данные из таблицы планов
                                # Фильтруем данные по выбранному периоду
                                period_start = pd.Timestamp(start_date)
                                period_end = period_start + timedelta(days=calculation_days - 1)
                                
                                # Фильтруем данные таблицы планов по выбранному периоду
                                period_plan_data = []
                                
                                # Преобразуем границы периода в date для сравнения
                                if isinstance(start_date, pd.Timestamp):
                                    period_start_date = start_date.date()
                                elif hasattr(start_date, 'date'):
                                    period_start_date = start_date.date()
                                else:
                                    period_start_date = pd.Timestamp(start_date).date()
                                
                                if isinstance(end_date, pd.Timestamp):
                                    period_end_date = end_date.date()
                                elif hasattr(end_date, 'date'):
                                    period_end_date = end_date.date()
                                else:
                                    period_end_date = pd.Timestamp(end_date).date()
                                
                                for day_detail in plan_details_table:
                                    day_date = day_detail['Дата']
                                    
                                    # Преобразуем дату из таблицы в date
                                    try:
                                        if isinstance(day_date, str):
                                            day_date = pd.Timestamp(day_date)
                                        elif isinstance(day_date, pd.Timestamp):
                                            pass  # Уже Timestamp
                                        elif hasattr(day_date, 'date'):
                                            day_date = pd.Timestamp(day_date)
                                        else:
                                            day_date = pd.Timestamp(day_date)
                                        
                                        # Преобразуем в date для сравнения
                                        if hasattr(day_date, 'date'):
                                            day_date_only = day_date.date()
                                        else:
                                            day_date_only = pd.Timestamp(day_date).date()
                                        
                                        # Проверяем, попадает ли дата в выбранный период
                                        if period_start_date <= day_date_only <= period_end_date:
                                            period_plan_data.append(day_detail)
                                    except Exception as e:
                                        # Пропускаем записи с некорректными датами
                                        continue
                                
                                # Показываем информацию о выбранном периоде и найденных данных
                                if len(period_plan_data) > 0:
                                    st.success(f"✅ Найдено {len(period_plan_data)} дней с данными для периода: {start_date.strftime('%d.%m.%Y')} - {end_date.strftime('%d.%m.%Y')} ({calculation_days} дней)")
                                else:
                                    st.warning(f"⚠️ Не найдено данных для периода: {start_date.strftime('%d.%m.%Y')} - {end_date.strftime('%d.%m.%Y')} ({calculation_days} дней). Убедитесь, что во вкладке '🗺️ План продаж' построен план продаж для этого периода.")
                                
                                if len(period_plan_data) > 0:
                                    # Расчет прогноза продаж
                                    st.markdown("#### 📊 Расчет заказа")
                                    
                                    # Используем данные из таблицы планов для расчета
                                    # Собираем значения планов для каждого дня в периоде
                                    period_plan_values = []  # Значения выбранного плана для каждого дня периода
                                    period_low_plan_values = []  # Низкий план
                                    period_mid_plan_values = []  # Средний план
                                    period_high_plan_values = []  # Высокий план
                                    period_dates_with_plan = []  # Даты, для которых есть план
                                    
                                    # Создаем словарь для быстрого поиска данных по дате
                                    plan_data_by_date = {}
                                    for day_detail in period_plan_data:
                                        day_date = day_detail['Дата']
                                        if isinstance(day_date, str):
                                            day_date = pd.Timestamp(day_date)
                                        elif hasattr(day_date, 'date'):
                                            day_date = pd.Timestamp(day_date)
                                        plan_data_by_date[day_date.date()] = day_detail
                                    
                                    # Для каждого дня в периоде расчета
                                    period_date_range = pd.date_range(start=start_date, periods=calculation_days, freq='D')
                                    for period_date in period_date_range:
                                        # Преобразуем в date для сравнения
                                        period_date_only = period_date.date() if hasattr(period_date, 'date') else pd.Timestamp(period_date).date()
                                        
                                        # Ищем данные для этой даты в таблице планов
                                        if period_date_only in plan_data_by_date:
                                            day_detail = plan_data_by_date[period_date_only]
                                            day_low_plan = day_detail['Низкий план (среднее)']
                                            day_mid_plan = day_detail['Средний план (среднее)']
                                            day_high_plan = day_detail['Высокий план (среднее)']
                                            
                                            # Выбираем план в зависимости от выбранного типа
                                            if selected_plan_type == "low":
                                                day_plan_value = day_low_plan
                                            elif selected_plan_type == "high":
                                                day_plan_value = day_high_plan
                                            else:  # mid
                                                day_plan_value = day_mid_plan
                                            
                                            period_low_plan_values.append(day_low_plan)
                                            period_mid_plan_values.append(day_mid_plan)
                                            period_high_plan_values.append(day_high_plan)
                                            period_plan_values.append(day_plan_value)
                                            period_dates_with_plan.append(period_date)
                                        else:
                                            # Если нет данных для этой даты, используем 0
                                            period_low_plan_values.append(0)
                                            period_mid_plan_values.append(0)
                                            period_high_plan_values.append(0)
                                            period_plan_values.append(0)
                                            period_dates_with_plan.append(period_date)
                                    
                                    # Суммируем значения планов за весь период
                                    total_low_plan = sum(period_low_plan_values)
                                    total_mid_plan = sum(period_mid_plan_values)
                                    total_high_plan = sum(period_high_plan_values)
                                    
                                    # ИСПРАВЛЕНО: Используем все артикулы из комбинации, а не только из period_plan_data
                                    # Это гарантирует, что все артикулы комбинации будут распределены по планам
                                    if combo_skus:
                                        all_combo_skus = sorted([str(sku).replace(".0", "") for sku in combo_skus if sku and str(sku).lower() not in ['nan', 'none', '']])
                                        total_skus = len(all_combo_skus)
                                        
                                        low_plan_skus = set()
                                        mid_plan_skus = set()
                                        high_plan_skus = set()
                                        
                                        if total_skus > 0:
                                            # Распределяем артикулы по планам примерно равными долями (по третям)
                                            # Высокий план - топ ~33% артикулов
                                            high_count = max(1, int(total_skus / 3))
                                            high_plan_skus = set(all_combo_skus[:high_count])
                                            
                                            # Средний план - средние ~33% артикулов
                                            mid_start = high_count
                                            mid_end = mid_start + max(1, int(total_skus / 3))
                                            if mid_end > mid_start and mid_end <= total_skus:
                                                mid_plan_skus = set(all_combo_skus[mid_start:mid_end])
                                            else:
                                                mid_plan_skus = set(all_combo_skus[mid_start:])
                                            
                                            # Низкий план - нижние ~34% артикулов (остаток)
                                            low_start = mid_end if mid_end <= total_skus else mid_start
                                            low_plan_skus = set(all_combo_skus[low_start:])
                                    else:
                                        # Если нет артикулов из комбинации, пытаемся собрать из period_plan_data (старая логика)
                                        all_plan_skus = set()
                                        for day_detail in period_plan_data:
                                            all_plan_skus.update(day_detail['Товары'].keys())
                                        
                                        sorted_skus_list = sorted([str(sku).replace(".0", "") for sku in all_plan_skus if sku and str(sku).lower() not in ['nan', 'none', '']])
                                        total_skus = len(sorted_skus_list)
                                        
                                        low_plan_skus = set()
                                        mid_plan_skus = set()
                                        high_plan_skus = set()
                                        
                                        if total_skus > 0:
                                            high_count = max(1, int(total_skus / 3))
                                            high_plan_skus = set(sorted_skus_list[:high_count])
                                            
                                            mid_start = high_count
                                            mid_end = mid_start + max(1, int(total_skus / 3))
                                            if mid_end > mid_start and mid_end <= total_skus:
                                                mid_plan_skus = set(sorted_skus_list[mid_start:mid_end])
                                            else:
                                                mid_plan_skus = set(sorted_skus_list[mid_start:])
                                            
                                            low_start = mid_end if mid_end <= total_skus else mid_start
                                            low_plan_skus = set(sorted_skus_list[low_start:])
                                    
                                    # Очищаем артикулы от пустых значений (дополнительная проверка)
                                    low_plan_skus = {sku for sku in low_plan_skus if sku and str(sku).lower() not in ['nan', 'none', '']}
                                    mid_plan_skus = {sku for sku in mid_plan_skus if sku and str(sku).lower() not in ['nan', 'none', '']}
                                    high_plan_skus = {sku for sku in high_plan_skus if sku and str(sku).lower() not in ['nan', 'none', '']}
                                    
                                    # Формируем строки с артикулами (максимум 5 артикулов, остальные "...")
                                    def format_skus(skus_set, max_display=5):
                                        if not skus_set:
                                            return "нет данных"
                                        skus_list = sorted(list(skus_set))[:max_display]
                                        skus_str = ", ".join(skus_list)
                                        if len(skus_set) > max_display:
                                            skus_str += f", ... (+{len(skus_set) - max_display})"
                                        return skus_str
                                    
                                    low_skus_str = format_skus(low_plan_skus)
                                    mid_skus_str = format_skus(mid_plan_skus)
                                    high_skus_str = format_skus(high_plan_skus)
                                    
                                    # Обновляем отображение планов с рассчитанными значениями
                                    st.markdown("#### 📦 Выбор плана для расчета заказа")
                                    plan_options_updated = [
                                        f"📉 Низкий план ({total_low_plan:.0f} шт за период, товары: {low_skus_str})",
                                        f"📊 Средний план ({total_mid_plan:.0f} шт за период, товары: {mid_skus_str})",
                                        f"📈 Высокий план ({total_high_plan:.0f} шт за период, товары: {high_skus_str})"
                                    ]
                                    
                                    # Определяем индекс выбранного плана
                                    if selected_plan_type == "low":
                                        default_idx = 0
                                    elif selected_plan_type == "high":
                                        default_idx = 2
                                    else:
                                        default_idx = 1
                                    
                                    selected_plan_display_updated = st.selectbox(
                                        "Выберите план:",
                                        options=plan_options_updated,
                                        index=default_idx,
                                        key="order_calc_plan_select_updated"
                                    )
                                    
                                    if "Низкий" in selected_plan_display_updated:
                                        selected_plan_type = "low"
                                    elif "Высокий" in selected_plan_display_updated:
                                        selected_plan_type = "high"
                                    else:
                                        selected_plan_type = "mid"
                                    
                                    # Пересчитываем period_plan_values на основе выбранного плана
                                    period_plan_values = []
                                    for i in range(len(period_low_plan_values)):
                                        if selected_plan_type == "low":
                                            period_plan_values.append(period_low_plan_values[i])
                                        elif selected_plan_type == "high":
                                            period_plan_values.append(period_high_plan_values[i])
                                        else:  # mid
                                            period_plan_values.append(period_mid_plan_values[i])
                                    
                                    # Отображаем KPI для всех трех планов
                                    st.markdown("#### 📊 KPI планов (сумма заказов за период без учета выкупа)")
                                    col1, col2, col3 = st.columns(3)
                                    
                                    with col1:
                                        st.metric(
                                            "📉 Низкий план",
                                            f"{total_low_plan:.0f} шт",
                                            help=f"Сумма заказов за период: {total_low_plan:.0f} шт (без учета выкупа)."
                                        )
                                    
                                    with col2:
                                        st.metric(
                                            "📊 Средний план",
                                            f"{total_mid_plan:.0f} шт",
                                            help=f"Сумма заказов за период: {total_mid_plan:.0f} шт (без учета выкупа)."
                                        )
                                    
                                    with col3:
                                        st.metric(
                                            "📈 Высокий план",
                                            f"{total_high_plan:.0f} шт",
                                            help=f"Сумма заказов за период: {total_high_plan:.0f} шт (без учета выкупа)."
                                        )
                                    
                                    
                                    
                                    # Отображаем таблицы планов с артикулами
                                    st.markdown("#### 📋 Распределение артикулов по планам")
                                    
                                    # Создаем DataFrame для таблицы планов
                                    plans_data = []
                                    if low_plan_skus:
                                        plans_data.append({
                                            "План": "📉 Низкий план",
                                            "Сумма за период": f"{total_low_plan:.0f} шт",
                                            "Количество артикулов": len(low_plan_skus),
                                            "Артикулы": ", ".join(sorted(low_plan_skus))
                                        })
                                    if mid_plan_skus:
                                        plans_data.append({
                                            "План": "📊 Средний план",
                                            "Сумма за период": f"{total_mid_plan:.0f} шт",
                                            "Количество артикулов": len(mid_plan_skus),
                                            "Артикулы": ", ".join(sorted(mid_plan_skus))
                                        })
                                    if high_plan_skus:
                                        plans_data.append({
                                            "План": "📈 Высокий план",
                                            "Сумма за период": f"{total_high_plan:.0f} шт",
                                            "Количество артикулов": len(high_plan_skus),
                                            "Артикулы": ", ".join(sorted(high_plan_skus))
                                        })
                                    
                                    if plans_data:
                                        plans_df = pd.DataFrame(plans_data)
                                        st.dataframe(
                                            plans_df,
                                            column_config={
                                                "План": st.column_config.TextColumn("План", width="medium"),
                                                "Сумма за период": st.column_config.TextColumn("Сумма за период", width="small"),
                                                "Количество артикулов": st.column_config.NumberColumn("Кол-во артикулов", width="small"),
                                                "Артикулы": st.column_config.TextColumn("Артикулы", width="large")
                                            },
                                            hide_index=True,
                                            use_container_width=True
                                        )
                                        
                                        # Показываем общую статистику
                                        total_skus_in_plans = len(low_plan_skus) + len(mid_plan_skus) + len(high_plan_skus)
                                        if combo_skus:
                                            total_combo_skus = len([sku for sku in combo_skus if sku and str(sku).lower() not in ['nan', 'none', '']])
                                            if total_skus_in_plans != total_combo_skus:
                                                st.info(f"ℹ️ Всего артикулов в комбинации: {total_combo_skus}, распределено по планам: {total_skus_in_plans}")
                                            else:
                                                st.success(f"✅ Все артикулы комбинации ({total_combo_skus}) распределены по планам")
                                    else:
                                        st.warning("⚠️ Не найдено артикулов для отображения в планах")
                                    
                                    # Планы - это заказы, которые нужно выполнить каждый день
                                    # Рассчитываем необходимое количество товара с учетом возвратов
                                    # Симулируем каждый день периода
                                    
                                    # Для расчета используем сумму значений плана по всем дням (динамика)
                                    total_orders_plan = sum(period_plan_values)  # Сумма планов по каждому дню
                                    days_count = len([v for v in period_plan_values if v > 0])
                                    
                                    # Новая логика: оптимизируем заказ так, чтобы к концу периода остаток был минимальным (но не меньше заданного процента)
                                    # Цель: найти минимальное количество товара для заказа, при котором к концу периода остаток >= min_end_stock_pct% от суммы заказов
                                    
                                    # Минимальный остаток на конец периода (в процентах от суммы заказов)
                                    # min_end_stock_pct уже получен из интерфейса выше
                                    min_end_stock = total_orders_plan * (min_end_stock_pct / 100.0)
                                    
                                    # Функция для моделирования периода с заданным количеством заказанного товара
                                    def simulate_period(order_amount):
                                        """Моделирует период и возвращает остаток на конец периода"""
                                        stock = current_stock + order_amount  # Начальный остаток
                                        stock_used_per_day = [0] * len(period_plan_values)
                                        
                                        for day_idx in range(len(period_plan_values)):
                                            day_orders = period_plan_values[day_idx]
                                            if day_orders <= 0:
                                                continue
                                            
                                            # Добавляем возвраты (товар, использованный 7 дней назад)
                                            if day_idx >= return_days:
                                                stock_used_return_day = stock_used_per_day[day_idx - return_days]
                                                returned_qty = stock_used_return_day * (1 - buyout_k)
                                                stock += returned_qty
                                            
                                            # Вычитаем заказы
                                            needed_for_orders = day_orders
                                            stock_used_per_day[day_idx] = needed_for_orders
                                            stock -= needed_for_orders
                                        
                                        return stock, stock_used_per_day
                                    
                                    # Бинарный поиск минимального заказа
                                    # Начальные границы: от 0 до максимально возможного (сумма заказов + запас)
                                    max_possible_order = int(total_orders_plan * 1.5)  # Верхняя граница
                                    min_order = 0
                                    optimal_order = max_possible_order
                                    
                                    # Бинарный поиск минимального заказа
                                    while min_order <= max_possible_order:
                                        test_order = (min_order + max_possible_order) // 2
                                        end_stock, _ = simulate_period(test_order)
                                        
                                        if end_stock >= min_end_stock:
                                            # Этот заказ достаточен, пробуем меньше
                                            optimal_order = test_order
                                            max_possible_order = test_order - 1
                                        else:
                                            # Недостаточно, нужно больше
                                            min_order = test_order + 1
                                    
                                    # Финальная симуляция с оптимальным заказом для получения деталей
                                    stock_available = current_stock + optimal_order
                                    stock_used_per_day = [0] * len(period_plan_values)
                                    calculation_details = []
                                    
                                    for day_idx in range(len(period_plan_values)):
                                        day_orders = period_plan_values[day_idx]
                                        current_date = period_dates_with_plan[day_idx] if day_idx < len(period_dates_with_plan) else start_date + timedelta(days=day_idx)
                                        if day_orders <= 0:
                                            continue
                                        
                                        stock_before = stock_available
                                        returns_added = 0
                                        
                                        # Добавляем возвраты за этот день
                                        if day_idx >= return_days:
                                            stock_used_return_day = stock_used_per_day[day_idx - return_days]
                                            returned_qty = stock_used_return_day * (1 - buyout_k)
                                            stock_available += returned_qty
                                            returns_added = returned_qty
                                        
                                        # Вычитаем заказы
                                        needed_for_orders = day_orders
                                        stock_used_per_day[day_idx] = needed_for_orders
                                        stock_available -= needed_for_orders
                                        
                                        # Сохраняем детали для этого дня
                                        calculation_details.append({
                                            'day': day_idx + 1,
                                            'date': current_date,
                                            'orders': day_orders,
                                            'stock_before': stock_before,
                                            'returns': returns_added,
                                            'stock_after_returns': stock_before + returns_added,
                                            'shortage': 0,  # Теперь не используем shortage, так как заказ уже рассчитан
                                            'stock_after_order': stock_before + returns_added,
                                            'stock_used': needed_for_orders,
                                            'stock_after': stock_available
                                        })
                                    
                                    # Базовый заказ - оптимальное количество для минимального остатка
                                    base_order_needed = optimal_order
                                    
                                    # Применяем запас безопасности (если задан)
                                    if safety_stock_pct > 0:
                                        safety_multiplier = 1 + (safety_stock_pct / 100.0)
                                        order_with_safety = base_order_needed * safety_multiplier
                                    else:
                                        safety_multiplier = 1.0
                                        order_with_safety = base_order_needed
                                    
                                    # Итоговый заказ
                                    final_order = max(0, int(np.ceil(order_with_safety)))
                                    # Сохраняем рекомендуемый заказ для выбранного плана
                                    st.session_state[f"recommended_order_{selected_combo_key}_{selected_plan_type}"] = final_order
                                    
                                    # ========== РАСПРЕДЕЛЕНИЕ ПО РАЗМЕРАМ ==========
                                    size_reports, size_missing = find_and_load_size_reports(tuple(combo_skus), "size")
                                    if size_missing:
                                        st.warning(f"⚠️ Не прочитаны отчеты по размерам для {len(size_missing)} артикулов.")
                                        with st.expander("Причины (размеры)", expanded=False):
                                            st.markdown(
                                                "\n".join([f"- {sku}: {reason}" for sku, reason in size_missing.items()])
                                            )
                                    
                                    if size_reports:
                                        per_sku_shares = {}
                                        all_sizes = set()
                                        for sku, info in size_reports.items():
                                            df_size = info["data"].copy()
                                            if "Артикул" in df_size.columns:
                                                df_size = df_size[df_size["Артикул"].astype(str) == str(sku)]
                                            if "Размер" in df_size.columns:
                                                import utils.size_reports as size_reports_module
                                                size_reports_module = importlib.reload(size_reports_module)
                                                df_size["Размер"] = df_size["Размер"].apply(size_reports_module.normalize_size)
                                                df_size = df_size[df_size["Размер"].notna()]
                                            if df_size.empty:
                                                continue
                                            grp = df_size.groupby("Размер", as_index=False)["Заказы"].sum()
                                            total_orders = grp["Заказы"].sum()
                                            if total_orders > 0:
                                                grp["Доля, %"] = (grp["Заказы"] / total_orders) * 100
                                            else:
                                                grp["Доля, %"] = 0
                                            grp = grp[["Размер", "Доля, %"]]
                                            per_sku_shares[str(sku)] = grp
                                            all_sizes.update(grp["Размер"].tolist())
                                        
                                        if per_sku_shares:
                                            all_sizes = sorted(all_sizes)
                                            
                                            def build_plan_distribution(plan_skus_set):
                                                plan_skus = [str(s) for s in plan_skus_set if str(s) in per_sku_shares]
                                                if not plan_skus:
                                                    return None, []
                                                rows = []
                                                for sku in plan_skus:
                                                    df_share = per_sku_shares[sku].set_index("Размер").reindex(all_sizes).fillna(0).reset_index()
                                                    df_share["Артикул"] = sku
                                                    rows.append(df_share)
                                                combined = pd.concat(rows, ignore_index=True)
                                                # Средняя доля по артикулам плана
                                                plan_share = combined.groupby("Размер", as_index=False)["Доля, %"].mean()
                                                return plan_share.sort_values("Доля, %", ascending=False), plan_skus
                                            
                                            def allocate_size_qty(share_df: pd.DataFrame, total_qty: float) -> pd.DataFrame:
                                                df_alloc = share_df.copy()
                                                df_alloc["Кол-во, шт"] = (df_alloc["Доля, %"] / 100.0) * float(total_qty)
                                                df_alloc["Кол-во, шт"] = df_alloc["Кол-во, шт"].round().astype(int)
                                                diff = int(round(float(total_qty) - df_alloc["Кол-во, шт"].sum()))
                                                if diff != 0 and len(df_alloc) > 0:
                                                    df_alloc = df_alloc.sort_values("Доля, %", ascending=False).reset_index(drop=True)
                                                    df_alloc.loc[0, "Кол-во, шт"] += diff
                                                return df_alloc
                                            
                                            st.markdown("### ✅ Закупка по размерам (по каждому плану)")
                                            rec_low = st.session_state.get(f"recommended_order_{selected_combo_key}_low")
                                            rec_mid = st.session_state.get(f"recommended_order_{selected_combo_key}_mid")
                                            rec_high = st.session_state.get(f"recommended_order_{selected_combo_key}_high")
                                            plan_sets = [
                                                ("📉 Низкий план", rec_low, low_plan_skus),
                                                ("📊 Средний план", rec_mid, mid_plan_skus),
                                                ("📈 Высокий план", rec_high, high_plan_skus)
                                            ]
                                            for plan_label, plan_total, plan_skus in plan_sets:
                                                if plan_total is None:
                                                    st.warning(f"⚠️ {plan_label}: нет рассчитанного рекомендуемого заказа. Сначала выполните расчет этого плана.")
                                                    continue
                                                share_df, used_skus = build_plan_distribution(plan_skus)
                                                if share_df is None:
                                                    st.warning(f"⚠️ {plan_label}: нет данных по размерам для артикулов плана.")
                                                    continue
                                                st.markdown(f"**{plan_label}: {plan_total:.0f} шт (артикулов в плане с размерами: {len(used_skus)})**")
                                                plan_df = allocate_size_qty(share_df, plan_total)
                                                st.dataframe(
                                                    plan_df[["Размер", "Кол-во, шт", "Доля, %"]],
                                                    use_container_width=True
                                                )
                                            
                                            # Итоговый заказ по размерам: по выбранному плану
                                            if selected_plan_type == "low":
                                                final_share, _ = build_plan_distribution(low_plan_skus)
                                            elif selected_plan_type == "high":
                                                final_share, _ = build_plan_distribution(high_plan_skus)
                                            else:
                                                final_share, _ = build_plan_distribution(mid_plan_skus)
                                            
                                            # Итоговый блок рекомендации по размерам убран по запросу
                                        else:
                                            st.warning("⚠️ Отчеты по размерам есть, но данные пусты.")
                                    else:
                                        st.info("ℹ️ Не найдены отчеты по размерам в папке size.")
                                    
                                    # Анализ отзывов перенесен из блока размеров
                                    
                                    # Финальный остаток на конец периода
                                    final_end_stock = stock_available
                                    
                                    # Количество товара, которое будет выкуплено из итогового заказа
                                    total_buyout_from_order = final_order * buyout_k
                                    total_return_from_order = final_order * (1 - buyout_k)
                                    
                                    # Рассчитываем, сколько товара вернется после конца периода
                                    # Это товар, использованный в последние return_days дней периода
                                    returns_after_period = 0
                                    period_length = len(period_plan_values)
                                    # Товар, использованный в последние return_days дней, вернется после конца периода
                                    for day_idx in range(max(0, period_length - return_days), period_length):
                                        if day_idx < len(stock_used_per_day):
                                            stock_used = stock_used_per_day[day_idx]
                                            # Часть товара, которая не будет выкуплена, вернется через return_days дней
                                            returns_after_period += stock_used * (1 - buyout_k)
                                    
                                    # Расчет даты получения товара (конец периода)
                                    delivery_date = start_date + timedelta(days=calculation_days - 1)
                                    
                                    # Создаем таблицу расчета заказа на основе данных из таблицы планов
                                    # Убираем детализацию по каждому товару, добавляем расчет заказа
                                    order_calculation_table = []
                                    
                                    for day_idx, detail in enumerate(calculation_details):
                                        # Получаем дату из detail
                                        calc_date = detail['date']
                                        
                                        # Находим соответствующий день в period_plan_data для получения плана
                                        plan_day_detail = None
                                        for day_detail in period_plan_data:
                                            day_date = day_detail['Дата']
                                            if isinstance(day_date, str):
                                                day_date = pd.Timestamp(day_date)
                                            elif hasattr(day_date, 'date'):
                                                day_date = pd.Timestamp(day_date)
                                            
                                            calc_date_only = calc_date.date() if hasattr(calc_date, 'date') else pd.Timestamp(calc_date).date()
                                            day_date_only = day_date.date() if hasattr(day_date, 'date') else pd.Timestamp(day_date).date()
                                            
                                            if calc_date_only == day_date_only:
                                                plan_day_detail = day_detail
                                                break
                                        
                                        # Определяем план для этого дня
                                        if plan_day_detail:
                                            if selected_plan_type == "low":
                                                plan_value = plan_day_detail['Низкий план (среднее)']
                                            elif selected_plan_type == "high":
                                                plan_value = plan_day_detail['Высокий план (среднее)']
                                            else:
                                                plan_value = plan_day_detail['Средний план (среднее)']
                                        else:
                                            plan_value = detail['orders']
                                        
                                        # Рассчитываем продажи для этого дня (количество заказов * процент выкупа)
                                        sold_qty = detail['orders'] * buyout_k
                                        
                                        # Формируем строку таблицы
                                        order_calculation_table.append({
                                            'Дата': calc_date.strftime('%d.%m.%Y') if hasattr(calc_date, 'strftime') else str(calc_date),
                                            'План (среднее)': f"{plan_value:.1f}",
                                            'Заказов по плану': f"{detail['orders']:.0f}",
                                            'Продано': f"{sold_qty:.0f}",
                                            'Товар на складе (начало дня)': f"{detail['stock_before']:.0f}",
                                            f'Возвраты (+{return_days} дней)': f"{detail['returns']:.1f}",
                                            'Товар после возвратов': f"{detail['stock_after_returns']:.0f}",
                                            'Использовано для заказов': f"{detail['stock_used']:.0f}",
                                            'Товар на складе (конец дня)': f"{detail['stock_after']:.0f}"
                                        })
                                    
                                    # Рассчитываем общую сумму продаж за период
                                    total_sold = sum([detail['orders'] * buyout_k for detail in calculation_details])
                                    
                                    # Отображаем таблицу расчета заказа
                                    if len(order_calculation_table) > 0:
                                        st.markdown("#### 📋 Таблица расчета заказа (на основе планов продаж)")
                                        st.dataframe(pd.DataFrame(order_calculation_table), use_container_width=True, hide_index=True)
                                    
                                    # Показываем результаты
                                    st.markdown("##### 📈 Результаты расчета")
                                    
                                    result_col1, result_col2, result_col3, result_col4 = st.columns(4)
                                    
                                    with result_col1:
                                        st.metric("📅 Дней в периоде", f"{calculation_days}")
                                    
                                    with result_col2:
                                        st.metric("📈 Сумма заказов по плану", f"{total_orders_plan:.0f} шт")
                                        st.metric("💰 Сумма продаж", f"{total_sold:.0f} шт", help=f"Общее количество проданного товара за период (заказы × процент выкупа {buyout_pct}%)")
                                        st.metric("📦 Текущие остатки", f"{current_stock} шт")
                                        st.metric("📊 Остаток на конец периода", f"{final_end_stock:.0f} шт", 
                                                 help=f"Остаток товара на конец периода (минимум {min_end_stock_pct}% от суммы заказов = {min_end_stock:.0f} шт)")
                                        
                                        # Общий остаток товара после периода
                                        total_stock_after_period = final_end_stock + returns_after_period
                                        st.metric("📦 Общий остаток товара после периода", f"{total_stock_after_period:.0f} шт", 
                                                 help=f"Остаток на конец периода ({final_end_stock:.0f} шт) + товар, который вернется после конца периода ({returns_after_period:.0f} шт)")
                                    
                                    with result_col3:
                                        st.metric("📆 Период расчета", f"{calculation_days} дней")
                                        st.metric("📅 Конец периода", delivery_date.strftime("%d.%m.%Y"))
                                    
                                    with result_col4:
                                        st.metric("🛡️ Запас безопасности", f"{safety_stock_pct}%")
                                        st.metric("📦 Запас на остатках (мин.)", f"{min_end_stock_pct}%", 
                                                 help=f"Минимальный остаток на конец периода: {min_end_stock:.0f} шт ({min_end_stock_pct}% от суммы заказов)")
                                        st.metric("💡 Рекомендуемый заказ", f"{final_order} шт", 
                                                 delta=f"{final_order - int(base_order_needed)} шт" if safety_stock_pct > 0 else None,
                                                 help=f"Оптимизированный заказ для минимального остатка на конец периода (базовый: {base_order_needed:.0f} шт)")
                                        st.metric("🔄 Вернется товара после конца периода", f"{returns_after_period:.0f} шт", 
                                                 help=f"Товар, использованный для заказов в последние {return_days} дней периода, вернется через {return_days} дней после использования (невыкупленная часть)")
                                    
                                    # Детализация расчета
                                    with st.expander("🔍 Детализация расчета", expanded=False):
                                        st.markdown("### Исходные данные")
                                        st.markdown(f"""
                                        - **Период расчета:** с {start_date.strftime('%d.%m.%Y')} по {delivery_date.strftime('%d.%m.%Y')} ({calculation_days} дней)
                                        - **План:** {selected_plan_display.split('(')[0].strip()}
                                        - **Сумма заказов по плану:** {total_orders_plan:.0f} шт (без учета выкупа)
                                        - **Процент выкупа:** {buyout_pct}% (из каждого заказа {buyout_pct}% товара выкупается, остальные {(1-buyout_k)*100:.0f}% возвращаются через {return_days} дней)
                                        - **Дни до возврата:** {return_days} дней
                                        - **Текущие остатки:** {current_stock} шт
                                        - **Запас безопасности:** {safety_stock_pct}%
                                        - **Минимальный остаток на конец периода:** {min_end_stock_pct}% ({min_end_stock:.0f} шт)
                                        """)
                                        
                                        st.markdown("### Пояснение к расчету")
                                        st.markdown(f"""
                                        **Процент выкупа:** Если клиенты заказали 100 шт товара, то из них {buyout_pct} шт будет выкуплено (продано), 
                                        а остальные {(1-buyout_k)*100:.0f} шт вернутся через {return_days} дней и снова будут доступны для выполнения заказов.
                                        
                                        **Новая логика расчета (оптимизация):**
                                        1. **Цель:** Найти минимальное количество товара для заказа, при котором к концу периода остаток будет >= {min_end_stock_pct}% от суммы заказов ({min_end_stock:.0f} шт)
                                        2. **Моделирование:** Для каждого варианта заказа моделируем период:
                                           - Начальный остаток = текущие остатки + заказанный товар
                                           - Каждый день: вычитаем заказы, добавляем возвраты через {return_days} дней
                                        3. **Оптимизация:** Используется бинарный поиск для нахождения минимального заказа, при котором остаток на конец >= {min_end_stock:.0f} шт
                                        4. **Результат:** Базовый заказ = {base_order_needed:.0f} шт (оптимизирован для минимального остатка)
                                        5. **Запас безопасности:** К базовому заказу применяется запас {safety_stock_pct}% (если задан)
                                        """)
                                        
                                        st.markdown("### Итеративный расчет по дням")
                                        # Показываем первые 10 дней и последние 5 дней детально
                                        if len(calculation_details) > 15:
                                            st.markdown("**Первые дни периода:**")
                                            details_table = []
                                            for detail in calculation_details[:10]:
                                                details_table.append({
                                                    'День': detail['day'],
                                                    'Дата': detail['date'].strftime('%d.%m.%Y') if hasattr(detail['date'], 'strftime') else str(detail['date']),
                                                    'Заказов по плану': f"{detail['orders']:.0f}",
                                                    'Товар на складе (начало дня)': f"{detail['stock_before']:.0f}",
                                                    'Возвраты (+{})'.format(return_days): f"{detail['returns']:.1f}",
                                                    'Товар после возвратов': f"{detail['stock_after_returns']:.0f}",
                                                    'Использовано для заказов': f"{detail['stock_used']:.0f}",
                                                    'Товар на складе (конец дня)': f"{detail['stock_after']:.0f}"
                                                })
                                            st.dataframe(pd.DataFrame(details_table), use_container_width=True, hide_index=True)
                                            
                                            st.markdown("**... (дни пропущены) ...**")
                                            
                                            st.markdown("**Последние дни периода:**")
                                            details_table_end = []
                                            for detail in calculation_details[-5:]:
                                                details_table_end.append({
                                                    'День': detail['day'],
                                                    'Дата': detail['date'].strftime('%d.%m.%Y') if hasattr(detail['date'], 'strftime') else str(detail['date']),
                                                    'Заказов по плану': f"{detail['orders']:.0f}",
                                                    'Товар на складе (начало дня)': f"{detail['stock_before']:.0f}",
                                                    'Возвраты (+{})'.format(return_days): f"{detail['returns']:.1f}",
                                                    'Товар после возвратов': f"{detail['stock_after_returns']:.0f}",
                                                    'Использовано для заказов': f"{detail['stock_used']:.0f}",
                                                    'Товар на складе (конец дня)': f"{detail['stock_after']:.0f}"
                                                })
                                            st.dataframe(pd.DataFrame(details_table_end), use_container_width=True, hide_index=True)
                                        else:
                                            details_table = []
                                            for detail in calculation_details:
                                                details_table.append({
                                                    'День': detail['day'],
                                                    'Дата': detail['date'].strftime('%d.%m.%Y') if hasattr(detail['date'], 'strftime') else str(detail['date']),
                                                    'Заказов по плану': f"{detail['orders']:.0f}",
                                                    'Товар на складе (начало дня)': f"{detail['stock_before']:.0f}",
                                                    'Возвраты (+{})'.format(return_days): f"{detail['returns']:.1f}",
                                                    'Товар после возвратов': f"{detail['stock_after_returns']:.0f}",
                                                    'Использовано для заказов': f"{detail['stock_used']:.0f}",
                                                    'Товар на складе (конец дня)': f"{detail['stock_after']:.0f}"
                                                })
                                            st.dataframe(pd.DataFrame(details_table), use_container_width=True, hide_index=True)
                                        
                                        st.markdown("### Итоговый расчет заказа")
                                        st.markdown(f"""
                                        1. **Базовый заказ (оптимизированный):** {base_order_needed:.0f} шт
                                           - Рассчитан методом оптимизации (бинарный поиск) для минимального остатка на конец периода
                                           - Цель: остаток на конец >= {min_end_stock_pct}% от суммы заказов ({min_end_stock:.0f} шт)
                                           - Учитывает возвраты товара каждые {return_days} дней
                                           - Учитывает текущие остатки ({current_stock} шт)
                                           - Моделирует весь период: начальный остаток = {current_stock} + заказ, затем вычитаем заказы каждый день
                                        
                                        2. **Применение запаса безопасности ({safety_stock_pct}%):**
                                           - {base_order_needed:.0f} × {safety_multiplier:.2f} = {order_with_safety:.1f} шт
                                           - Запас нужен для компенсации возможных колебаний спроса
                                        
                                        3. **Итоговый заказ:** {final_order} шт
                                        
                                        **Что произойдет после заказа {final_order} шт:**
                                        - Примерно {total_buyout_from_order:.0f} шт будет выкуплено клиентами ({buyout_pct}%)
                                        - Около {total_return_from_order:.0f} шт вернется через {return_days} дней ({(1-buyout_k)*100:.0f}%)
                                        - Возвращенный товар снова будет доступен для выполнения заказов в последующие дни
                                        """)
                                    
                                    # ================= ЮНИТ-ЭКОНОМИКА В РАСЧЕТЕ ЗАКАЗА =================
                                    st.markdown("---")
                                    st.markdown("#### 💰 Юнит-экономика и расчёт прибыли за период")
                                    
                                    # Загрузка настроек
                                    def load_ue_order_settings_main():
                                        try:
                                            if os.path.exists("ue_settings.json"):
                                                with open("ue_settings.json", 'r', encoding='utf-8') as f:
                                                    return json.load(f)
                                        except:
                                            pass
                                        return {}
                                    
                                    def save_ue_order_settings_main(settings):
                                        try:
                                            with open("ue_settings.json", 'w', encoding='utf-8') as f:
                                                json.dump(settings, f, ensure_ascii=False, indent=2)
                                            return True
                                        except:
                                            return False
                                    
                                    ue_order_settings_main = load_ue_order_settings_main()
                                    order_ue_key_main = f"{selected_combo_key}_order"
                                    combo_ue_main = ue_order_settings_main.get(order_ue_key_main, ue_order_settings_main.get(selected_combo_key, {}))
                                    
                                    with st.expander("⚙️ Настройки юнит-экономики", expanded=True):
                                        ue_save1_m, ue_save2_m = st.columns([3, 1])
                                        with ue_save2_m:
                                            if st.button("💾 Сохранить", key=f"ue_save_order_main_{plan_key}", use_container_width=True):
                                                new_ue_m = {
                                                    'cost_price': st.session_state.get(f'ue_cost_om_{plan_key}', 500.0),
                                                    'commission': st.session_state.get(f'ue_comm_om_{plan_key}', 15.0),
                                                    'logistics': st.session_state.get(f'ue_log_om_{plan_key}', 100.0),
                                                    'advertising': st.session_state.get(f'ue_adv_om_{plan_key}', 5.0),
                                                    'spp': st.session_state.get(f'ue_spp_om_{plan_key}', 25.0),
                                                    'buyout': st.session_state.get(f'ue_buy_om_{plan_key}', 80.0),
                                                    'tax': st.session_state.get(f'ue_tax_om_{plan_key}', 7.0),
                                                    'saved_at': datetime.now().strftime('%Y-%m-%d %H:%M')
                                                }
                                                ue_order_settings_main[order_ue_key_main] = new_ue_m
                                                if save_ue_order_settings_main(ue_order_settings_main):
                                                    st.success("✅ Сохранено!")
                                        with ue_save1_m:
                                            if combo_ue_main.get('saved_at'):
                                                st.caption(f"📅 Сохранено: {combo_ue_main.get('saved_at')}")
                                        
                                        ue_cm1, ue_cm2, ue_cm3 = st.columns(3)
                                        
                                        with ue_cm1:
                                            ue_cost_om = st.number_input("Себестоимость, ₽", min_value=0.0, value=combo_ue_main.get('cost_price', 500.0), step=10.0, key=f"ue_cost_om_{plan_key}")
                                            ue_comm_om = st.number_input("Комиссия WB, %", min_value=0.0, max_value=100.0, value=combo_ue_main.get('commission', 15.0), step=0.5, key=f"ue_comm_om_{plan_key}")
                                        
                                        with ue_cm2:
                                            ue_log_om = st.number_input("Логистика, ₽", min_value=0.0, value=combo_ue_main.get('logistics', 100.0), step=10.0, key=f"ue_log_om_{plan_key}")
                                            ue_adv_om = st.number_input("Реклама, %", min_value=0.0, max_value=100.0, value=combo_ue_main.get('advertising', 5.0), step=0.5, key=f"ue_adv_om_{plan_key}")
                                        
                                        with ue_cm3:
                                            ue_spp_om = st.number_input("СПП, %", min_value=0.0, max_value=100.0, value=combo_ue_main.get('spp', 25.0), step=0.5, key=f"ue_spp_om_{plan_key}")
                                            ue_buy_om = st.number_input("% выкупа", min_value=1.0, max_value=100.0, value=combo_ue_main.get('buyout', 80.0), step=1.0, key=f"ue_buy_om_{plan_key}")
                                            ue_tax_om = st.number_input("Налог, %", min_value=0.0, max_value=100.0, value=combo_ue_main.get('tax', 7.0), step=0.5, key=f"ue_tax_om_{plan_key}")
                                    
                                    # Детализация на 1 единицу
                                    with st.expander("🔍 Детализация расчёта (на 1 единицу)", expanded=False):
                                        st.info(f"📅 Период: {start_date.strftime('%d.%m.%Y')} - {delivery_date.strftime('%d.%m.%Y')} ({calculation_days} дней) | 📦 {selected_plan_display}")
                                        
                                        avg_price_spp_m = avg_check if avg_check and avg_check > 0 else 1000
                                        spp_fm = (1 - ue_spp_om / 100) if ue_spp_om < 100 else 1
                                        avg_price_no_spp_m = avg_price_spp_m / spp_fm
                                        
                                        ue_exm = calculate_unit_economics(
                                            cost_price=ue_cost_om, retail_price=avg_price_no_spp_m,
                                            commission_rate=ue_comm_om, logistics_cost=ue_log_om,
                                            advertising_percent=ue_adv_om, buyout_percent=ue_buy_om, tax_rate=ue_tax_om
                                        )
                                        
                                        dcm1, dcm2 = st.columns(2)
                                        with dcm1:
                                            st.markdown("**📥 Доходы:**")
                                            st.write(f"🏷️ Цена с СПП ({ue_spp_om}%): **{avg_price_spp_m:,.0f} ₽**")
                                            st.write(f"💰 Цена без СПП: **{avg_price_no_spp_m:,.0f} ₽**")
                                            st.markdown("**📤 Расходы:**")
                                            st.write(f"📦 Себестоимость: **{ue_cost_om:,.0f} ₽**")
                                            st.write(f"🏢 Комиссия: **{ue_exm['Комиссия, руб']:,.0f} ₽**")
                                            st.write(f"🚚 Логистика: **{ue_exm['Логистика с учетом выкупа']:,.0f} ₽**")
                                            st.write(f"📢 Реклама: **{ue_exm['Реклама, руб']:,.0f} ₽**")
                                            st.write(f"🏛️ Налог: **{ue_exm['Налог, руб']:,.0f} ₽**")
                                        with dcm2:
                                            st.markdown("**📊 Результат:**")
                                            tot_expm = ue_cost_om + ue_exm['Комиссия, руб'] + ue_exm['Логистика с учетом выкупа'] + ue_exm['Реклама, руб'] + ue_exm['Налог, руб']
                                            st.write(f"💸 Всего расходов: **{tot_expm:,.0f} ₽**")
                                            st.write(f"📈 Выручка с ед.: **{ue_exm['Выручка с ед.']:,.0f} ₽**")
                                            pcm = "green" if ue_exm['Прибыль с ед.'] > 0 else "red"
                                            st.markdown(f"💵 **Прибыль: <span style='color:{pcm};font-size:1.2em;'>{ue_exm['Прибыль с ед.']:,.0f} ₽</span>**", unsafe_allow_html=True)
                                            mcm = "green" if ue_exm['Маржинальность, %'] > 0 else "red"
                                            st.markdown(f"📉 Маржа: <span style='color:{mcm};'>{ue_exm['Маржинальность, %']:.1f}%</span>", unsafe_allow_html=True)
                                            rcm = "green" if ue_exm['Рентабельность, %'] > 0 else "red"
                                            st.markdown(f"📊 Рентабельность: <span style='color:{rcm};'>{ue_exm['Рентабельность, %']:.1f}%</span>", unsafe_allow_html=True)
                                    
                                    # Расчёт прибыли за период
                                    st.markdown("##### 📊 Прибыль за период")
                                    
                                    total_profit_pm = 0
                                    total_revenue_pm = 0
                                    total_sales_pm = 0
                                    sum_spp_revenue = 0
                                    sum_no_spp_revenue = 0
                                    
                                    # Прибыль за месяц (30 дней)
                                    total_profit_month = 0
                                    total_revenue_month = 0
                                    total_sales_month = 0
                                    total_profit_pm_usn = 0
                                    total_revenue_pm_usn = 0
                                    total_usn_tax_pm = 0
                                    
                                    spp_fm_order = (1 - ue_spp_om / 100) if ue_spp_om < 100 else 1
                                    avg_price_no_spp_plan = None
                                    if period_plan_data:
                                        no_spp_values = [
                                            d.get('Средняя цена без СПП')
                                            for d in period_plan_data
                                            if d.get('Средняя цена без СПП')
                                        ]
                                        if no_spp_values:
                                            avg_price_no_spp_plan = np.mean(no_spp_values)
                                    
                                    for i, detail in enumerate(calculation_details):
                                        day_orders = detail['orders']
                                        day_sold = day_orders * buyout_k
                                        
                                        # Получаем цену для этого дня из period_plan_data
                                        day_price_spp_m = avg_check
                                        if i < len(period_plan_data):
                                            day_detail_m = period_plan_data[i]
                                            if selected_plan_type == "low":
                                                day_price_spp_m = day_detail_m.get('Низкий план цены') or day_detail_m.get('Средняя цена') or avg_check
                                            elif selected_plan_type == "high":
                                                day_price_spp_m = day_detail_m.get('Высокий план цены') or day_detail_m.get('Средняя цена') or avg_check
                                            else:
                                                day_price_spp_m = day_detail_m.get('Средний план цены') or day_detail_m.get('Средняя цена') or avg_check
                                        
                                        day_price_no_spp_m = None
                                        if i < len(period_plan_data):
                                            day_price_no_spp_m = period_plan_data[i].get('Средняя цена без СПП')
                                        if not day_price_no_spp_m:
                                            if day_price_spp_m and day_price_spp_m > 0 and spp_fm_order > 0:
                                                day_price_no_spp_m = day_price_spp_m / spp_fm_order
                                            else:
                                                day_price_no_spp_m = avg_price_no_spp_plan or avg_price_no_spp_m
                                        
                                        sum_spp_revenue += day_price_spp_m * day_sold
                                        sum_no_spp_revenue += day_price_no_spp_m * day_sold
                                        
                                        day_profit_m = calculate_daily_profit(
                                            day_sold, day_price_no_spp_m, ue_cost_om, ue_comm_om,
                                            ue_log_om, ue_adv_om, ue_buy_om, tax_rate=ue_tax_om
                                        )
                                        total_profit_pm += day_profit_m['Общая прибыль']
                                        total_revenue_pm += day_profit_m['Общая выручка']
                                        total_sales_pm += day_sold
                                        
                                        ue_no_tax_day = calculate_unit_economics(
                                            cost_price=ue_cost_om,
                                            retail_price=day_price_no_spp_m,
                                            commission_rate=ue_comm_om,
                                            logistics_cost=ue_log_om,
                                            advertising_percent=ue_adv_om,
                                            buyout_percent=ue_buy_om,
                                            tax_rate=0
                                        )
                                        usn_tax_base_day = ue_no_tax_day['Выручка с ед.'] - ue_cost_om
                                        usn_tax_day = max(0, usn_tax_base_day * 0.15)
                                        profit_per_unit_usn = ue_no_tax_day['Выручка с ед.'] - ue_cost_om - usn_tax_day
                                        total_profit_pm_usn += profit_per_unit_usn * day_sold
                                        total_revenue_pm_usn += ue_no_tax_day['Выручка с ед.'] * day_sold
                                        total_usn_tax_pm += usn_tax_day * day_sold
                                    
                                        # Считаем прибыль за месяц (первые 30 дней)
                                        if i < 30:
                                            total_profit_month += day_profit_m['Общая прибыль']
                                            total_revenue_month += day_profit_m['Общая выручка']
                                            total_sales_month += day_sold
                                    
                                    pkm1, pkm2, pkm3, pkm4, pkm5 = st.columns(5)
                                    with pkm1:
                                        pcdm = "normal" if total_profit_pm >= 0 else "inverse"
                                        profit_per_day = total_profit_pm / calculation_days if calculation_days > 0 else 0
                                        st.metric("💵 Прибыль", f"{total_profit_pm:,.0f} ₽", delta=f"{profit_per_day:,.0f} ₽/день", delta_color=pcdm)
                                    with pkm2:
                                        st.metric("📈 Выручка", f"{total_revenue_pm:,.0f} ₽")
                                    with pkm3:
                                        st.metric("📦 Продаж", f"{total_sales_pm:,.0f} шт")
                                    with pkm4:
                                        avg_mm = (total_profit_pm / total_revenue_pm * 100) if total_revenue_pm > 0 else 0
                                        st.metric("📊 Маржа", f"{avg_mm:.1f}%")
                                    with pkm5:
                                        pcdm_month = "normal" if total_profit_month >= 0 else "inverse"
                                        profit_per_day_month = total_profit_month / 30 if total_profit_month > 0 else 0
                                        st.metric("💰 Прибыль за месяц", f"{total_profit_month:,.0f} ₽", delta=f"{profit_per_day_month:,.0f} ₽/день", delta_color=pcdm_month, help="Прибыль за первые 30 дней периода")
                                    
                                    avg_price_spp_period = (sum_spp_revenue / total_sales_pm) if total_sales_pm > 0 else 0
                                    avg_price_no_spp_period = (sum_no_spp_revenue / total_sales_pm) if total_sales_pm > 0 else 0
                                    
                                    pkm6, pkm7, pkm8, pkm9, pkm10 = st.columns(5)
                                    with pkm6:
                                        st.metric("📅 Период", f"{calculation_days} дней", delta=f"{len(calculation_details)} дней", help="Количество дней в периоде расчета")
                                    with pkm7:
                                        avg_profit_per_unit = (total_profit_pm / total_sales_pm) if total_sales_pm > 0 else 0
                                        st.metric("💵 Прибыль/ед.", f"{avg_profit_per_unit:,.0f} ₽")
                                    with pkm8:
                                        avg_profitability = (avg_profit_per_unit / ue_cost_om * 100) if ue_cost_om > 0 else 0
                                        st.metric("📊 Рентаб./ед.", f"{avg_profitability:.1f}%")
                                    with pkm9:
                                        st.metric("🏷️ Цена с СПП", f"{avg_price_spp_period:,.0f} ₽")
                                    with pkm10:
                                        st.metric("💰 Цена без СПП", f"{avg_price_no_spp_period:,.0f} ₽")
                                    
                                    with st.expander("💡 Детализация расходов на 1 ед. (период)", expanded=False):
                                        ue_period = calculate_unit_economics(
                                            cost_price=ue_cost_om,
                                            retail_price=avg_price_no_spp_period,
                                            commission_rate=ue_comm_om,
                                            logistics_cost=ue_log_om,
                                            advertising_percent=ue_adv_om,
                                            buyout_percent=ue_buy_om,
                                            tax_rate=ue_tax_om
                                        )
                                        total_expenses_period = (
                                            ue_cost_om
                                            + ue_period['Комиссия, руб']
                                            + ue_period['Логистика с учетом выкупа']
                                            + ue_period['Реклама, руб']
                                            + ue_period['Налог, руб']
                                        )
                                        st.markdown(f"**💸 Всего расходов:** {total_expenses_period:,.0f} ₽")
                                        st.markdown(f"**📈 Выручка с ед.:** {ue_period['Выручка с ед.']:,.0f} ₽")
                                        st.markdown(f"**📦 Себестоимость:** {ue_cost_om:,.0f} ₽")
                                        st.markdown(f"**🏢 Комиссия:** {ue_period['Комиссия, руб']:,.0f} ₽")
                                        st.markdown(f"**🚚 Логистика:** {ue_period['Логистика с учетом выкупа']:,.0f} ₽")
                                        st.markdown(f"**📢 Реклама:** {ue_period['Реклама, руб']:,.0f} ₽")
                                        st.markdown(f"**🏛️ Налог:** {ue_period['Налог, руб']:,.0f} ₽")
                                    
                                    with st.expander("🧾 УСН 15% (доходы минус расходы) — на 1 ед.", expanded=False):
                                        ue_no_tax = calculate_unit_economics(
                                            cost_price=ue_cost_om,
                                            retail_price=avg_price_no_spp_period,
                                            commission_rate=ue_comm_om,
                                            logistics_cost=ue_log_om,
                                            advertising_percent=ue_adv_om,
                                            buyout_percent=ue_buy_om,
                                            tax_rate=0
                                        )
                                        usn_tax_base = ue_no_tax['Выручка с ед.'] - ue_cost_om
                                        usn_tax = max(0, usn_tax_base * 0.15)
                                        total_expenses_usn = (
                                            ue_cost_om
                                            + ue_no_tax['Комиссия, руб']
                                            + ue_no_tax['Логистика с учетом выкупа']
                                            + ue_no_tax['Реклама, руб']
                                            + usn_tax
                                        )
                                        st.markdown(f"**💸 Всего расходов:** {total_expenses_usn:,.0f} ₽")
                                        st.markdown(f"**📈 Выручка с ед.:** {ue_no_tax['Выручка с ед.']:,.0f} ₽")
                                        st.markdown(f"**📦 Себестоимость:** {ue_cost_om:,.0f} ₽")
                                        st.markdown(f"**🏢 Комиссия:** {ue_no_tax['Комиссия, руб']:,.0f} ₽")
                                        st.markdown(f"**🚚 Логистика:** {ue_no_tax['Логистика с учетом выкупа']:,.0f} ₽")
                                        st.markdown(f"**📢 Реклама:** {ue_no_tax['Реклама, руб']:,.0f} ₽")
                                        st.markdown(f"**🏛️ Налог (15% от дохода-расхода):** {usn_tax:,.0f} ₽")
                                    
                                    st.info(f"📅 Период: {calculation_days} дней ({start_date.strftime('%d.%m.%Y')} - {delivery_date.strftime('%d.%m.%Y')}) | 📦 {selected_plan_display}")
                                    
                                    with st.expander("📊 KPI по УСН 15% (доходы минус расходы)", expanded=False):
                                        usn_profit_per_unit = (total_profit_pm_usn / total_sales_pm) if total_sales_pm > 0 else 0
                                        usn_margin = (total_profit_pm_usn / total_revenue_pm_usn * 100) if total_revenue_pm_usn > 0 else 0
                                        usn_profitability = (usn_profit_per_unit / ue_cost_om * 100) if ue_cost_om > 0 else 0
                                        diff_profit = total_profit_pm_usn - total_profit_pm
                                        diff_profit_per_unit = usn_profit_per_unit - ((total_profit_pm / total_sales_pm) if total_sales_pm > 0 else 0)
                                        st.markdown("**Сравнение: Доходы vs Доходы − расходы**")
                                        c1, c2, c3 = st.columns(3)
                                        with c1:
                                            st.metric("💵 Прибыль (доходы)", f"{total_profit_pm:,.0f} ₽")
                                        with c2:
                                            st.metric("💵 Прибыль (доходы−расходы)", f"{total_profit_pm_usn:,.0f} ₽", delta=f"{diff_profit:,.0f} ₽")
                                        with c3:
                                            st.metric("💵 Прибыль/ед. (дельта)", f"{diff_profit_per_unit:,.0f} ₽")
                                        st.markdown("---")
                                        uk1, uk2, uk3, uk4, uk5 = st.columns(5)
                                        with uk1:
                                            st.metric("💵 Прибыль", f"{total_profit_pm_usn:,.0f} ₽")
                                        with uk2:
                                            st.metric("📈 Выручка", f"{total_revenue_pm_usn:,.0f} ₽")
                                        with uk3:
                                            st.metric("📦 Продаж", f"{total_sales_pm:,.0f} шт")
                                        with uk4:
                                            st.metric("📊 Маржа", f"{usn_margin:.1f}%")
                                        with uk5:
                                            st.metric("💵 Прибыль/ед.", f"{usn_profit_per_unit:,.0f} ₽")
                                        uk6, uk7, uk8, uk9, uk10 = st.columns(5)
                                        with uk6:
                                            st.metric("📊 Рентаб./ед.", f"{usn_profitability:.1f}%")
                                        with uk7:
                                            st.metric("🏷️ Цена с СПП", f"{avg_price_spp_period:,.0f} ₽")
                                        with uk8:
                                            st.metric("💰 Цена без СПП", f"{avg_price_no_spp_period:,.0f} ₽")
                                        with uk9:
                                            st.metric("📦 Себестоимость", f"{ue_cost_om:,.0f} ₽")
                                        with uk10:
                                            avg_usn_tax = (total_usn_tax_pm / total_sales_pm) if total_sales_pm > 0 else 0
                                            st.metric("🏛️ Налог (УСН 15%)", f"{avg_usn_tax:,.0f} ₽")
                                    
                                    # Анализ отзывов перенесен выше, ближе к выбору комбинации
                                    
                                    # Таблица прибыли по дням (в выбранном периоде)
                                    st.markdown("#### 📅 Прибыль по дням")
                                    daily_profit_rows = []
                                    period_end_date = start_date + timedelta(days=calculation_days - 1)
                                    
                                    for i, detail in enumerate(calculation_details):
                                        day_date = detail['date']
                                        day_date_only = day_date.date() if hasattr(day_date, 'date') else pd.Timestamp(day_date).date()
                                        
                                        if day_date_only < start_date or day_date_only > period_end_date:
                                            continue
                                        
                                        day_orders = detail['orders']
                                        day_sold = day_orders * buyout_k
                                        
                                        # Получаем цену для этого дня из period_plan_data
                                        day_price_spp_m = avg_check
                                        if i < len(period_plan_data):
                                            day_detail_m = period_plan_data[i]
                                            if selected_plan_type == "low":
                                                day_price_spp_m = day_detail_m.get('Низкий план цены') or day_detail_m.get('Средняя цена') or avg_check
                                            elif selected_plan_type == "high":
                                                day_price_spp_m = day_detail_m.get('Высокий план цены') or day_detail_m.get('Средняя цена') or avg_check
                                            else:
                                                day_price_spp_m = day_detail_m.get('Средний план цены') or day_detail_m.get('Средняя цена') or avg_check
                                        
                                        day_price_no_spp_m = None
                                        if i < len(period_plan_data):
                                            day_price_no_spp_m = period_plan_data[i].get('Средняя цена без СПП')
                                        if not day_price_no_spp_m:
                                            if day_price_spp_m and day_price_spp_m > 0 and spp_fm_order > 0:
                                                day_price_no_spp_m = day_price_spp_m / spp_fm_order
                                            else:
                                                day_price_no_spp_m = avg_price_no_spp_plan or avg_price_no_spp_m
                                        
                                        day_profit_m = calculate_daily_profit(
                                            day_sold, day_price_no_spp_m, ue_cost_om, ue_comm_om,
                                            ue_log_om, ue_adv_om, ue_buy_om, tax_rate=ue_tax_om
                                        )
                                        
                                        profit_per_unit = day_profit_m.get('Прибыль с ед.', 0)
                                        profitability_per_unit = (profit_per_unit / ue_cost_om * 100) if ue_cost_om > 0 else 0
                                        
                                        daily_profit_rows.append({
                                            "Дата": day_date,
                                            "Заказы": day_orders,
                                            "Выкупы": day_sold,
                                            "Цена с СПП": day_price_spp_m,
                                            "Цена без СПП": day_price_no_spp_m,
                                            "Выручка": day_profit_m.get("Общая выручка", 0),
                                            "Прибыль": day_profit_m.get("Общая прибыль", 0),
                                            "Прибыль с ед.": profit_per_unit,
                                            "Рентабельность с ед., %": profitability_per_unit
                                        })
                                    
                                    if daily_profit_rows:
                                        daily_profit_df = pd.DataFrame(daily_profit_rows)
                                        st.dataframe(daily_profit_df, use_container_width=True)
                                    else:
                                        st.info("ℹ️ Нет данных для таблицы прибыли по дням в выбранном периоде.")
                                    
                                    # График заказов и плана
                                    # Проверяем, есть ли дни с заказами
                                    days_with_orders = [v for v in period_plan_values if v > 0]
                                    
                                    if len(days_with_orders) > 0:
                                        st.markdown("#### 📊 График заказов и плана")
                                        
                                        # Получаем данные отчета для комбинации (если есть)
                                        combo_report_key = f"report_{selected_combo_key}"
                                        report_data = st.session_state.get(combo_report_key, None)
                                        
                                        if report_data is not None and len(report_data) > 0:
                                            report_data_for_plot = report_data.copy()
                                        else:
                                            # Если нет данных отчета, создаем пустой DataFrame
                                            report_data_for_plot = pd.DataFrame(columns=['Дата', 'Продажи'])
                                        
                                        # Группируем по датам и считаем сумму заказов по комбинации
                                        if len(report_data_for_plot) > 0 and 'Дата' in report_data_for_plot.columns and 'Продажи' in report_data_for_plot.columns:
                                            daily_sum_orders = report_data_for_plot.groupby('Дата')['Продажи'].sum().reset_index()
                                            daily_sum_orders.columns = ['Дата', 'Заказы']
                                            daily_sum_orders = daily_sum_orders.sort_values('Дата')
                                        else:
                                            # Если нет исторических данных, создаем пустой DataFrame
                                            daily_sum_orders = pd.DataFrame(columns=['Дата', 'Заказы'])
                                        
                                        # Создаем DataFrame для плана
                                        plan_df = pd.DataFrame({
                                            'Дата': period_dates_with_plan,
                                            'Заказы': period_plan_values
                                        })
                                        
                                        import plotly.graph_objs as go
                                        fig = go.Figure()
                                        
                                        # Фактические заказы комбинации (исторические данные)
                                        if len(daily_sum_orders) > 0:
                                            fig.add_trace(go.Scatter(
                                                x=daily_sum_orders['Дата'],
                                                y=daily_sum_orders['Заказы'],
                                                mode='lines+markers',
                                                name='Фактические заказы (сумма по комбинации)',
                                                line=dict(color='blue', width=2)
                                            ))
                                        
                                        # План заказов для периода расчета
                                        if len(plan_df) > 0:
                                            fig.add_trace(go.Scatter(
                                                x=plan_df['Дата'],
                                                y=plan_df['Заказы'],
                                                mode='lines+markers',
                                                name=f'План заказов: {selected_plan_display.split("(")[0].strip()}',
                                                line=dict(color='orange', width=2, dash='dash'),
                                                marker=dict(size=4)
                                            ))
                                        
                                        # Вертикальные линии - начало и конец периода расчета
                                        # Преобразуем даты в строки ISO формата для Plotly (избегаем pd.Timestamp для совместимости)
                                        def format_date_for_plotly(date_obj):
                                            """Преобразует дату в строку ISO формата для Plotly"""
                                            if hasattr(date_obj, 'strftime'):
                                                return date_obj.strftime('%Y-%m-%d')
                                            elif isinstance(date_obj, pd.Timestamp):
                                                return date_obj.strftime('%Y-%m-%d')
                                            elif isinstance(date_obj, str):
                                                # Пытаемся распарсить строку и преобразовать в ISO формат
                                                try:
                                                    parsed = pd.to_datetime(date_obj)
                                                    return parsed.strftime('%Y-%m-%d')
                                                except:
                                                    return date_obj
                                            else:
                                                return str(date_obj)
                                        
                                        # Преобразуем даты в строки для Plotly (избегаем pd.Timestamp)
                                        start_date_dt = format_date_for_plotly(start_date)
                                        delivery_date_dt = format_date_for_plotly(delivery_date)
                                        
                                        fig.add_vline(
                                            x=start_date_dt,
                                            line_dash="dot",
                                            line_color="green",
                                            annotation_text=f"Начало периода",
                                            annotation_position="top"
                                        )
                                        fig.add_vline(
                                            x=delivery_date_dt,
                                            line_dash="dot",
                                            line_color="red",
                                            annotation_text=f"Конец периода (заказ: {final_order} шт)",
                                            annotation_position="top"
                                        )
                                        
                                        fig.update_layout(
                                            title=f"Продажи и прогноз для комбинации '{selected_combo_key}' ({selected_plan_display.split('(')[0].strip()})",
                                            xaxis_title="Дата",
                                            yaxis_title="Продажи, шт",
                                            hovermode='x unified',
                                            height=500
                                        )
                                        
                                        st.plotly_chart(fig, use_container_width=True, key=f"order_calc_chart_{plan_key}")
                        else:
                            st.warning(f"⚠️ Не удалось найти товары для комбинации: {selected_combo_key}")
        
        # Вкладка Прогнозирование с Prophet
        if PROPHET_AVAILABLE:
            with tab4:
                    st.subheader("🔮 Прогнозирование с Prophet")
                    
                    # Проверяем наличие данных
                    if df is not None and not df.empty:
                        # Настройки прогнозирования
                        col_settings1, col_settings2 = st.columns(2)
                        
                        with col_settings1:
                            # Выбор метрики для прогнозирования
                            numeric_columns = df.select_dtypes(include=[np.number]).columns.tolist()
                            if numeric_columns:
                                metric_choice = st.selectbox(
                                    "Выберите метрику для прогнозирования:",
                                    numeric_columns,
                                    key="prophet_metric_choice"
                                )
                            else:
                                st.warning("Нет числовых колонок для прогнозирования")
                                metric_choice = None
                        
                        with col_settings2:
                            # Выбор колонки с датами
                            date_columns = []
                            for col in df.columns:
                                if df[col].dtype == 'datetime64[ns]' or 'дата' in col.lower() or 'date' in col.lower():
                                    date_columns.append(col)
                            
                            if date_columns:
                                date_choice = st.selectbox(
                                    "Выберите колонку с датами (опционально):",
                                    ["Автоматически"] + date_columns,
                                    key="prophet_date_choice"
                                )
                                if date_choice == "Автоматически":
                                    date_choice = None
                            else:
                                date_choice = None
                                st.info("Колонка с датами не найдена, будет создана автоматически")
                        
                        # Дополнительные настройки
                        col_periods, col_seasonality = st.columns(2)
                        
                        with col_periods:
                            forecast_periods = st.number_input(
                                "Период прогнозирования (дни):",
                                min_value=1,
                                max_value=365,
                                value=30,
                                key="prophet_periods"
                            )
                        
                        with col_seasonality:
                            seasonality_mode = st.selectbox(
                                "Режим сезонности:",
                                ["additive", "multiplicative"],
                                key="prophet_seasonality"
                            )
                        
                        # Кнопка создания прогноза
                        if st.button("🔮 Создать прогноз", type="primary", key="create_forecast_btn"):
                            if metric_choice:
                                with st.spinner("Создание прогноза..."):
                                    # Подготавливаем данные
                                    df_prophet = prepare_data_for_prophet(df, metric_choice, date_choice)
                                    
                                    if df_prophet is not None and len(df_prophet) > 1:
                                        # Создаем прогноз
                                        model, forecast, future = create_prophet_forecast(
                                            df_prophet, 
                                            periods=forecast_periods,
                                            seasonality_mode=seasonality_mode
                                        )
                                        
                                        if model and forecast is not None:
                                            # Отображаем основной график прогноза
                                            st.subheader("📈 Прогноз")
                                            fig_forecast = plot_prophet_forecast(
                                                model, 
                                                forecast, 
                                                f"Прогноз {metric_choice}"
                                            )
                                            if fig_forecast:
                                                st.plotly_chart(fig_forecast, use_container_width=True)
                                            
                                            # Отображаем компоненты прогноза
                                            st.subheader("🔍 Компоненты прогноза")
                                            fig_components = plot_prophet_components(
                                                model, 
                                                forecast, 
                                                f"Компоненты прогноза {metric_choice}"
                                            )
                                            if fig_components:
                                                st.plotly_chart(fig_components, use_container_width=True)
                                            
                                            # Статистика прогноза
                                            st.subheader("📊 Статистика прогноза")
                                            
                                            # Получаем последние прогнозные значения
                                            forecast_future = forecast[forecast['ds'] > df_prophet['ds'].max()]
                                            
                                            if not forecast_future.empty:
                                                col_stat1, col_stat2, col_stat3, col_stat4 = st.columns(4)
                                                
                                                with col_stat1:
                                                    mean_forecast = forecast_future['yhat'].mean()
                                                    st.metric("Средний прогноз", f"{mean_forecast:,.0f}")
                                                
                                                with col_stat2:
                                                    max_forecast = forecast_future['yhat'].max()
                                                    st.metric("Максимальный прогноз", f"{max_forecast:,.0f}")
                                                
                                                with col_stat3:
                                                    min_forecast = forecast_future['yhat'].min()
                                                    st.metric("Минимальный прогноз", f"{min_forecast:,.0f}")
                                                
                                                with col_stat4:
                                                    trend = forecast_future['trend'].iloc[-1] - forecast_future['trend'].iloc[0]
                                                    st.metric("Изменение тренда", f"{trend:,.0f}")
                                                
                                                # Таблица с прогнозными значениями
                                                st.subheader("📋 Детальный прогноз")
                                                forecast_display = forecast_future[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].copy()
                                                forecast_display.columns = ['Дата', 'Прогноз', 'Нижняя граница', 'Верхняя граница']
                                                forecast_display['Дата'] = forecast_display['Дата'].dt.strftime('%Y-%m-%d')
                                                
                                                st.dataframe(
                                                    forecast_display,
                                                    use_container_width=True,
                                                    hide_index=True
                                                )
                                                
                                                # Экспорт прогноза
                                                csv_data = forecast_display.to_csv(index=False)
                                                st.download_button(
                                                    label="💾 Скачать прогноз (CSV)",
                                                    data=csv_data,
                                                    file_name=f"prophet_forecast_{metric_choice}.csv",
                                                    mime="text/csv"
                                                )
                                            
                                        else:
                                            st.error("Не удалось создать прогноз. Проверьте данные.")
                                    else:
                                        st.error("Недостаточно данных для создания прогноза. Нужно минимум 2 точки данных.")
                            else:
                                st.warning("Выберите метрику для прогнозирования")
                    
                    else:
                        st.info("📊 Загрузите данные в первой вкладке для создания прогнозов")


# end of file